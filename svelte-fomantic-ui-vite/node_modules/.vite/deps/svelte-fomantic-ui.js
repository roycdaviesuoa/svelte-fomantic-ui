import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_dev,
  assign,
  attr_dev,
  bubble,
  check_outros,
  compute_rest_props,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  noop,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_options,
  select_value,
  set_attributes,
  set_input_value,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-K6MJRMI7.js";

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/Helpers.ts
function uiProps(restProps) {
  let the_class = "";
  Object.keys(restProps).forEach((key, i) => {
    if (typeof restProps[key] === "boolean" && restProps[key]) {
      the_class = the_class + ((i > 0 ? " " : "") + key);
    }
  });
  if (restProps.hasOwnProperty("_")) {
    the_class = the_class + " " + restProps["_"];
  }
  return the_class;
}
function otherProps(restProps) {
  let other_props = {};
  Object.keys(restProps).forEach((key) => {
    if (typeof restProps[key] !== "boolean") {
      other_props[key] = restProps[key];
    }
  });
  return other_props;
}

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Statistics.svelte
var file = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Statistics.svelte";
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " statistics"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " statistics")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Statistics", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Statistics = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Statistics",
      options,
      id: create_fragment.name
    });
  }
  get value() {
    throw new Error("<Statistics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Statistics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Statistics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Statistics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Statistics_default = Statistics;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Statistic.svelte
var file2 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Statistic.svelte";
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " item"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file2, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " item")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Statistic", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Statistic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Statistic",
      options,
      id: create_fragment2.name
    });
  }
  get value() {
    throw new Error("<Statistic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Statistic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Statistic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Statistic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Statistic_default = Statistic;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Items.svelte
var file3 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Items.svelte";
function create_fragment3(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " items"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file3, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " items")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Items", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Items = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Items",
      options,
      id: create_fragment3.name
    });
  }
  get value() {
    throw new Error("<Items>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Items>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Items>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Items>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Items_default = Items;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Item.svelte
var file4 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Item.svelte";
function create_fragment4(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " item"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file4, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " item")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment4.name
    });
  }
  get value() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Item_default = Item;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Feed.svelte
var file5 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Feed.svelte";
function create_fragment5(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " feed"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file5, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " feed")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Feed", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Feed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Feed",
      options,
      id: create_fragment5.name
    });
  }
  get value() {
    throw new Error("<Feed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Feed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Feed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Feed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Feed_default = Feed;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Cards.svelte
var file6 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Cards.svelte";
function create_fragment6(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " cards"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file6, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " cards")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Cards", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Cards = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Cards",
      options,
      id: create_fragment6.name
    });
  }
  get value() {
    throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Cards_default = Cards;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Card.svelte
var file7 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Card.svelte";
function create_fragment7(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " card"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file7, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " card")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment7.name
    });
  }
  get value() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Advertisement.svelte
var file8 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/views/Advertisement.svelte";
function create_fragment8(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " ad"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file8, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*value*/
        1) && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        (!current || dirty & /*ui, $$restProps*/
        6 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " ad")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Advertisement", slots, ["default"]);
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, value, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, $$scope, slots];
}
var Advertisement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { value: 0, ui: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Advertisement",
      options,
      id: create_fragment8.name
    });
  }
  get value() {
    throw new Error("<Advertisement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Advertisement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Advertisement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Advertisement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Advertisement_default = Advertisement;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Dropdown.svelte
import "/home/roycdavies/Development/UofA/svelte-fomantic-ui/svelte-fomantic-ui-test/node_modules/fomantic-ui-css/semantic.css";

// node_modules/fomantic-ui-css/semantic.js
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.site = function(parameters) {
    var time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.site.settings, parameters) : $.extend({}, $.site.settings), namespace = settings.namespace, error = settings.error, moduleNamespace = "module-" + namespace, $document = $(document2), $module = $document, element2 = this, instance68 = $module.data(moduleNamespace), module, returnedValue;
    module = {
      initialize: function() {
        module.instantiate();
      },
      instantiate: function() {
        module.verbose("Storing instance of site", module);
        instance68 = module;
        $module.data(moduleNamespace, module);
      },
      normalize: function() {
        return;
      },
      fix: {
        consoleClear: function() {
          module.debug("Disabling programmatic console clearing");
          window2.console.clear = function() {
          };
        }
      },
      moduleExists: function(name) {
        return $.fn[name] !== void 0 && $.fn[name].settings !== void 0;
      },
      enabled: {
        modules: function(modules) {
          var enabledModules = [];
          modules = modules || settings.modules;
          $.each(modules, function(index, name) {
            if (module.moduleExists(name)) {
              enabledModules.push(name);
            }
          });
          return enabledModules;
        }
      },
      disabled: {
        modules: function(modules) {
          var disabledModules = [];
          modules = modules || settings.modules;
          $.each(modules, function(index, name) {
            if (!module.moduleExists(name)) {
              disabledModules.push(name);
            }
          });
          return disabledModules;
        }
      },
      change: {
        setting: function(setting, value, modules, modifyExisting) {
          modules = typeof modules === "string" ? modules === "all" ? settings.modules : [modules] : modules || settings.modules;
          modifyExisting = modifyExisting !== void 0 ? modifyExisting : true;
          $.each(modules, function(index, name) {
            var namespace2 = module.moduleExists(name) ? $.fn[name].settings.namespace || false : true, $existingModules;
            if (module.moduleExists(name)) {
              module.verbose("Changing default setting", setting, value, name);
              $.fn[name].settings[setting] = value;
              if (modifyExisting && namespace2) {
                $existingModules = $(":data(module-" + namespace2 + ")");
                if ($existingModules.length > 0) {
                  module.verbose("Modifying existing settings", $existingModules);
                  $existingModules[name]("setting", setting, value);
                }
              }
            }
          });
        },
        settings: function(newSettings, modules, modifyExisting) {
          modules = typeof modules === "string" ? [modules] : modules || settings.modules;
          modifyExisting = modifyExisting !== void 0 ? modifyExisting : true;
          $.each(modules, function(index, name) {
            var $existingModules;
            if (module.moduleExists(name)) {
              module.verbose("Changing default setting", newSettings, name);
              $.extend(true, $.fn[name].settings, newSettings);
              if (modifyExisting && namespace) {
                $existingModules = $(":data(module-" + namespace + ")");
                if ($existingModules.length > 0) {
                  module.verbose("Modifying existing settings", $existingModules);
                  $existingModules[name]("setting", newSettings);
                }
              }
            }
          });
        }
      },
      enable: {
        console: function() {
          module.console(true);
        },
        debug: function(modules, modifyExisting) {
          modules = modules || settings.modules;
          module.debug("Enabling debug for modules", modules);
          module.change.setting("debug", true, modules, modifyExisting);
        },
        verbose: function(modules, modifyExisting) {
          modules = modules || settings.modules;
          module.debug("Enabling verbose debug for modules", modules);
          module.change.setting("verbose", true, modules, modifyExisting);
        }
      },
      disable: {
        console: function() {
          module.console(false);
        },
        debug: function(modules, modifyExisting) {
          modules = modules || settings.modules;
          module.debug("Disabling debug for modules", modules);
          module.change.setting("debug", false, modules, modifyExisting);
        },
        verbose: function(modules, modifyExisting) {
          modules = modules || settings.modules;
          module.debug("Disabling verbose debug for modules", modules);
          module.change.setting("verbose", false, modules, modifyExisting);
        }
      },
      console: function(enable) {
        if (enable) {
          if (instance68.cache.console === void 0) {
            module.error(error.console);
            return;
          }
          module.debug("Restoring console function");
          window2.console = instance68.cache.console;
        } else {
          module.debug("Disabling console function");
          instance68.cache.console = window2.console;
          window2.console = {
            clear: function() {
            },
            error: function() {
            },
            group: function() {
            },
            groupCollapsed: function() {
            },
            groupEnd: function() {
            },
            info: function() {
            },
            log: function() {
            },
            table: function() {
            },
            warn: function() {
            }
          };
        }
      },
      destroy: function() {
        module.verbose("Destroying previous site for", $module);
        $module.removeData(moduleNamespace);
      },
      cache: {},
      setting: function(name, value) {
        if ($.isPlainObject(name)) {
          $.extend(true, settings, name);
        } else if (value !== void 0) {
          settings[name] = value;
        } else {
          return settings[name];
        }
      },
      internal: function(name, value) {
        if ($.isPlainObject(name)) {
          $.extend(true, module, name);
        } else if (value !== void 0) {
          module[name] = value;
        } else {
          return module[name];
        }
      },
      debug: function() {
        if (settings.debug) {
          if (settings.performance) {
            module.performance.log(arguments);
          } else {
            module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
            module.debug.apply(console, arguments);
          }
        }
      },
      verbose: function() {
        if (settings.verbose && settings.debug) {
          if (settings.performance) {
            module.performance.log(arguments);
          } else {
            module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
            module.verbose.apply(console, arguments);
          }
        }
      },
      error: function() {
        module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
        module.error.apply(console, arguments);
      },
      performance: {
        log: function(message) {
          var currentTime, executionTime, previousTime;
          if (settings.performance) {
            currentTime = Date.now();
            previousTime = time || currentTime;
            executionTime = currentTime - previousTime;
            time = currentTime;
            performance.push({
              Element: element2,
              Name: message[0],
              Arguments: [].slice.call(message, 1) || "",
              "Execution Time": executionTime
            });
          }
          clearTimeout(module.performance.timer);
          module.performance.timer = setTimeout(module.performance.display, 500);
        },
        display: function() {
          var title = settings.name + ":", totalTime = 0;
          time = false;
          clearTimeout(module.performance.timer);
          $.each(performance, function(index, data) {
            totalTime += data["Execution Time"];
          });
          title += " " + totalTime + "ms";
          if (performance.length > 0) {
            console.groupCollapsed(title);
            if (console.table) {
              console.table(performance);
            } else {
              $.each(performance, function(index, data) {
                console.log(data.Name + ": " + data["Execution Time"] + "ms");
              });
            }
            console.groupEnd();
          }
          performance = [];
        }
      },
      invoke: function(query2, passedArguments, context) {
        var object = instance68, maxDepth, found, response;
        passedArguments = passedArguments || queryArguments;
        context = context || element2;
        if (typeof query2 === "string" && object !== void 0) {
          query2 = query2.split(/[ .]/);
          maxDepth = query2.length - 1;
          $.each(query2, function(depth, value) {
            var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
            if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
              object = object[camelCaseValue];
            } else if (object[camelCaseValue] !== void 0) {
              found = object[camelCaseValue];
              return false;
            } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
              object = object[value];
            } else if (object[value] !== void 0) {
              found = object[value];
              return false;
            } else {
              module.error(error.method, query2);
              return false;
            }
          });
        }
        if (isFunction(found)) {
          response = found.apply(context, passedArguments);
        } else if (found !== void 0) {
          response = found;
        }
        if (Array.isArray(returnedValue)) {
          returnedValue.push(response);
        } else if (returnedValue !== void 0) {
          returnedValue = [returnedValue, response];
        } else if (response !== void 0) {
          returnedValue = response;
        }
        return found;
      }
    };
    if (methodInvoked) {
      if (instance68 === void 0) {
        module.initialize();
      }
      module.invoke(query);
    } else {
      if (instance68 !== void 0) {
        module.destroy();
      }
      module.initialize();
    }
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.site = $.fn.site;
  $.site.settings = {
    name: "Site",
    namespace: "site",
    error: {
      console: "Console cannot be restored, most likely it was overwritten outside of module",
      method: "The method you called is not defined."
    },
    debug: false,
    verbose: false,
    performance: true,
    modules: [
      "accordion",
      "api",
      "calendar",
      "checkbox",
      "dimmer",
      "dropdown",
      "embed",
      "flyout",
      "form",
      "modal",
      "nag",
      "popup",
      "progress",
      "rating",
      "search",
      "shape",
      "sidebar",
      "slider",
      "state",
      "sticky",
      "tab",
      "toast",
      "transition",
      "visibility"
    ],
    siteNamespace: "site",
    namespaceStub: {
      cache: {},
      config: {},
      sections: {},
      section: {},
      utilities: {}
    }
  };
  $.extend($.expr.pseudos, {
    data: $.expr.createPseudo(function(dataName) {
      return function(elem) {
        return !!$.data(elem, dataName);
      };
    })
  });
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.form = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var $module = $(this), element2 = this, formErrors = [], keyHeldDown = false, $field, $group, $message, $prompt, $submit, $clear, $reset, settings, validation, metadata, selector, className, regExp, error, namespace, moduleNamespace, eventNamespace, submitting = false, dirty = false, history = ["clean", "clean"], instance68, module;
      module = {
        initialize: function() {
          module.get.settings();
          if (methodInvoked) {
            if (instance68 === void 0) {
              module.instantiate();
            }
            module.invoke(query);
          } else {
            if (instance68 !== void 0) {
              instance68.invoke("destroy");
              module.refresh();
            }
            module.verbose("Initializing form validation", $module, settings);
            module.bindEvents();
            module.set.defaults();
            if (settings.autoCheckRequired) {
              module.set.autoCheck();
            }
            module.instantiate();
          }
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous module", instance68);
          module.removeEvents();
          $module.removeData(moduleNamespace);
        },
        refresh: function() {
          module.verbose("Refreshing selector cache");
          $field = $module.find(selector.field);
          $group = $module.find(selector.group);
          $message = $module.find(selector.message);
          $prompt = $module.find(selector.prompt);
          $submit = $module.find(selector.submit);
          $clear = $module.find(selector.clear);
          $reset = $module.find(selector.reset);
        },
        refreshEvents: function() {
          module.removeEvents();
          module.bindEvents();
        },
        submit: function() {
          module.verbose("Submitting form", $module);
          submitting = true;
          $module.trigger("submit");
        },
        attachEvents: function(selector2, action) {
          if (!action) {
            action = "submit";
          }
          $(selector2).on("click" + eventNamespace, function(event2) {
            module[action]();
            event2.preventDefault();
          });
        },
        bindEvents: function() {
          module.verbose("Attaching form events");
          $module.on("submit" + eventNamespace, module.validate.form).on("blur" + eventNamespace, selector.field, module.event.field.blur).on("click" + eventNamespace, selector.submit, module.submit).on("click" + eventNamespace, selector.reset, module.reset).on("click" + eventNamespace, selector.clear, module.clear);
          if (settings.keyboardShortcuts) {
            $module.on("keydown" + eventNamespace, selector.field, module.event.field.keydown);
          }
          $field.each(function(index, el) {
            var $input = $(el), type = $input.prop("type"), inputEvent = module.get.changeEvent(type, $input);
            $input.on(inputEvent + eventNamespace, module.event.field.change);
          });
          if (settings.preventLeaving) {
            $(window2).on("beforeunload" + eventNamespace, module.event.beforeUnload);
          }
          $field.on("change click keyup keydown blur", function(e) {
            module.determine.isDirty();
          });
          $module.on("dirty" + eventNamespace, function(e) {
            settings.onDirty.call();
          });
          $module.on("clean" + eventNamespace, function(e) {
            settings.onClean.call();
          });
        },
        clear: function() {
          $field.each(function(index, el) {
            var $field2 = $(el), $element = $field2.parent(), $fieldGroup = $field2.closest($group), $prompt2 = $fieldGroup.find(selector.prompt), $calendar = $field2.closest(selector.uiCalendar), defaultValue = $field2.data(metadata.defaultValue) || "", isCheckbox = $field2.is(selector.checkbox), isDropdown = $element.is(selector.uiDropdown) && module.can.useElement("dropdown"), isCalendar = $calendar.length > 0 && module.can.useElement("calendar"), isErrored = $fieldGroup.hasClass(className.error);
            if (isErrored) {
              module.verbose("Resetting error on field", $fieldGroup);
              $fieldGroup.removeClass(className.error);
              $prompt2.remove();
            }
            if (isDropdown) {
              module.verbose("Resetting dropdown value", $element, defaultValue);
              $element.dropdown("clear", true);
            } else if (isCheckbox) {
              $field2.prop("checked", false);
            } else if (isCalendar) {
              $calendar.calendar("clear");
            } else {
              module.verbose("Resetting field value", $field2, defaultValue);
              $field2.val("");
            }
          });
          module.remove.states();
        },
        reset: function() {
          $field.each(function(index, el) {
            var $field2 = $(el), $element = $field2.parent(), $fieldGroup = $field2.closest($group), $calendar = $field2.closest(selector.uiCalendar), $prompt2 = $fieldGroup.find(selector.prompt), defaultValue = $field2.data(metadata.defaultValue), isCheckbox = $field2.is(selector.checkbox), isDropdown = $element.is(selector.uiDropdown) && module.can.useElement("dropdown"), isCalendar = $calendar.length > 0 && module.can.useElement("calendar"), isErrored = $fieldGroup.hasClass(className.error);
            if (defaultValue === void 0) {
              return;
            }
            if (isErrored) {
              module.verbose("Resetting error on field", $fieldGroup);
              $fieldGroup.removeClass(className.error);
              $prompt2.remove();
            }
            if (isDropdown) {
              module.verbose("Resetting dropdown value", $element, defaultValue);
              $element.dropdown("restore defaults", true);
            } else if (isCheckbox) {
              module.verbose("Resetting checkbox value", $field2, defaultValue);
              $field2.prop("checked", defaultValue);
            } else if (isCalendar) {
              $calendar.calendar("set date", defaultValue);
            } else {
              module.verbose("Resetting field value", $field2, defaultValue);
              $field2.val(defaultValue);
            }
          });
          module.remove.states();
        },
        determine: {
          isValid: function() {
            var allValid = true;
            $.each(validation, function(fieldName, field) {
              if (!module.validate.field(field, fieldName, true)) {
                allValid = false;
              }
            });
            return allValid;
          },
          isDirty: function(e) {
            var formIsDirty = false;
            $field.each(function(index, el) {
              var $el = $(el), isCheckbox = $el.filter(selector.checkbox).length > 0, isDirty;
              isDirty = isCheckbox ? module.is.checkboxDirty($el) : module.is.fieldDirty($el);
              $el.data(settings.metadata.isDirty, isDirty);
              formIsDirty = formIsDirty || isDirty;
            });
            if (formIsDirty) {
              module.set.dirty();
            } else {
              module.set.clean();
            }
          }
        },
        is: {
          bracketedRule: function(rule) {
            return rule.type && rule.type.match(settings.regExp.bracket);
          },
          // duck type rule test
          shorthandRules: function(rules) {
            return typeof rules === "string" || Array.isArray(rules);
          },
          empty: function($field2) {
            if (!$field2 || $field2.length === 0) {
              return true;
            }
            if ($field2.is(selector.checkbox)) {
              return !$field2.is(":checked");
            }
            return module.is.blank($field2);
          },
          blank: function($field2) {
            return String($field2.val()).trim() === "";
          },
          valid: function(field, showErrors) {
            var allValid = true;
            if (field) {
              module.verbose("Checking if field is valid", field);
              return module.validate.field(validation[field], field, !!showErrors);
            }
            module.verbose("Checking if form is valid");
            $.each(validation, function(fieldName, field2) {
              if (!module.is.valid(fieldName, showErrors)) {
                allValid = false;
              }
            });
            return allValid;
          },
          dirty: function() {
            return dirty;
          },
          clean: function() {
            return !dirty;
          },
          fieldDirty: function($el) {
            var initialValue = $el.data(metadata.defaultValue);
            if (initialValue === void 0 || initialValue === null) {
              initialValue = "";
            } else if (Array.isArray(initialValue)) {
              initialValue = initialValue.toString();
            }
            var currentValue = $el.val();
            if (currentValue === void 0 || currentValue === null) {
              currentValue = "";
            } else if (Array.isArray(currentValue)) {
              currentValue = currentValue.toString();
            }
            var boolRegex = /^(true|false)$/i;
            var isBoolValue = boolRegex.test(initialValue) && boolRegex.test(currentValue);
            if (isBoolValue) {
              var regex = new RegExp("^" + initialValue + "$", "i");
              return !regex.test(currentValue);
            }
            return currentValue !== initialValue;
          },
          checkboxDirty: function($el) {
            var initialValue = $el.data(metadata.defaultValue);
            var currentValue = $el.is(":checked");
            return initialValue !== currentValue;
          },
          justDirty: function() {
            return history[0] === "dirty";
          },
          justClean: function() {
            return history[0] === "clean";
          }
        },
        removeEvents: function() {
          $module.off(eventNamespace);
          $field.off(eventNamespace);
          $submit.off(eventNamespace);
        },
        event: {
          field: {
            keydown: function(event2) {
              var $field2 = $(this), key = event2.which, isInput = $field2.is(selector.input), isCheckbox = $field2.is(selector.checkbox), isInDropdown = $field2.closest(selector.uiDropdown).length > 0, keyCode = {
                enter: 13,
                escape: 27
              };
              if (key === keyCode.escape) {
                module.verbose("Escape key pressed blurring field");
                $field2[0].blur();
              }
              if (!event2.ctrlKey && key === keyCode.enter && isInput && !isInDropdown && !isCheckbox) {
                if (!keyHeldDown) {
                  $field2.one("keyup" + eventNamespace, module.event.field.keyup);
                  module.submit();
                  module.debug("Enter pressed on input submitting form");
                  event2.preventDefault();
                }
                keyHeldDown = true;
              }
            },
            keyup: function() {
              keyHeldDown = false;
            },
            blur: function(event2) {
              var $field2 = $(this), $fieldGroup = $field2.closest($group), validationRules = module.get.validation($field2);
              if (validationRules && (settings.on === "blur" || $fieldGroup.hasClass(className.error) && settings.revalidate)) {
                module.debug("Revalidating field", $field2, validationRules);
                module.validate.field(validationRules);
                if (!settings.inline) {
                  module.validate.form(false, true);
                }
              }
            },
            change: function(event2) {
              var $field2 = $(this), $fieldGroup = $field2.closest($group), validationRules = module.get.validation($field2);
              if (validationRules && (settings.on === "change" || $fieldGroup.hasClass(className.error) && settings.revalidate)) {
                clearTimeout(module.timer);
                module.timer = setTimeout(function() {
                  module.debug("Revalidating field", $field2, validationRules);
                  module.validate.field(validationRules);
                  if (!settings.inline) {
                    module.validate.form(false, true);
                  }
                }, settings.delay);
              }
            }
          },
          beforeUnload: function(event2) {
            if (module.is.dirty() && !submitting) {
              event2 = event2 || window2.event;
              if (event2) {
                event2.returnValue = settings.text.leavingMessage;
              }
              return settings.text.leavingMessage;
            }
          }
        },
        get: {
          ancillaryValue: function(rule) {
            if (!rule.type || !rule.value && !module.is.bracketedRule(rule)) {
              return false;
            }
            return rule.value !== void 0 ? rule.value : rule.type.match(settings.regExp.bracket)[1] + "";
          },
          ruleName: function(rule) {
            if (module.is.bracketedRule(rule)) {
              return rule.type.replace(rule.type.match(settings.regExp.bracket)[0], "");
            }
            return rule.type;
          },
          changeEvent: function(type, $input) {
            if (type === "checkbox" || type === "radio" || type === "hidden" || $input.is("select")) {
              return "change";
            }
            return module.get.inputEvent();
          },
          inputEvent: function() {
            return document2.createElement("input").oninput !== void 0 ? "input" : document2.createElement("input").onpropertychange !== void 0 ? "propertychange" : "keyup";
          },
          fieldsFromShorthand: function(fields) {
            var fullFields = {};
            $.each(fields, function(name, rules) {
              if (!Array.isArray(rules) && typeof rules === "object") {
                fullFields[name] = rules;
              } else {
                if (typeof rules === "string") {
                  rules = [rules];
                }
                fullFields[name] = {
                  rules: []
                };
                $.each(rules, function(index, rule) {
                  fullFields[name].rules.push({ type: rule });
                });
              }
            });
            return fullFields;
          },
          prompt: function(rule, field) {
            var ruleName = module.get.ruleName(rule), ancillary = module.get.ancillaryValue(rule), $field2 = module.get.field(field.identifier), value = $field2.val(), prompt = isFunction(rule.prompt) ? rule.prompt(value) : rule.prompt || settings.prompt[ruleName] || settings.text.unspecifiedRule, requiresValue = prompt.search("{value}") !== -1, requiresName = prompt.search("{name}") !== -1, parts, suffixPrompt;
            if (ancillary && ["integer", "decimal", "number", "size"].indexOf(ruleName) >= 0 && ancillary.indexOf("..") >= 0) {
              parts = ancillary.split("..", 2);
              if (!rule.prompt && ruleName !== "size") {
                suffixPrompt = parts[0] === "" ? settings.prompt.maxValue.replace(/{ruleValue}/g, "{max}") : parts[1] === "" ? settings.prompt.minValue.replace(/{ruleValue}/g, "{min}") : settings.prompt.range;
                prompt += suffixPrompt.replace(/{name}/g, " " + settings.text.and);
              }
              prompt = prompt.replace(/{min}/g, parts[0]);
              prompt = prompt.replace(/{max}/g, parts[1]);
            }
            if (ancillary && ["match", "different"].indexOf(ruleName) >= 0) {
              prompt = prompt.replace(/{ruleValue}/g, module.get.fieldLabel(ancillary, true));
            }
            if (requiresValue) {
              prompt = prompt.replace(/{value}/g, $field2.val());
            }
            if (requiresName) {
              prompt = prompt.replace(/{name}/g, module.get.fieldLabel($field2));
            }
            prompt = prompt.replace(/{identifier}/g, field.identifier);
            prompt = prompt.replace(/{ruleValue}/g, ancillary);
            if (!rule.prompt) {
              module.verbose("Using default validation prompt for type", prompt, ruleName);
            }
            return prompt;
          },
          settings: function() {
            if ($.isPlainObject(parameters)) {
              if (parameters.fields) {
                parameters.fields = module.get.fieldsFromShorthand(parameters.fields);
              }
              settings = $.extend(true, {}, $.fn.form.settings, parameters);
              validation = $.extend(true, {}, $.fn.form.settings.defaults, settings.fields);
              module.verbose("Extending settings", validation, settings);
            } else {
              settings = $.extend(true, {}, $.fn.form.settings);
              validation = $.extend(true, {}, $.fn.form.settings.defaults);
              module.verbose("Using default form validation", validation, settings);
            }
            namespace = settings.namespace;
            metadata = settings.metadata;
            selector = settings.selector;
            className = settings.className;
            regExp = settings.regExp;
            error = settings.error;
            moduleNamespace = "module-" + namespace;
            eventNamespace = "." + namespace;
            instance68 = $module.data(moduleNamespace);
            (instance68 || module).refresh();
          },
          field: function(identifier, strict) {
            module.verbose("Finding field with identifier", identifier);
            identifier = module.escape.string(identifier);
            var t;
            t = $field.filter("#" + identifier);
            if (t.length > 0) {
              return t;
            }
            t = $field.filter('[name="' + identifier + '"]');
            if (t.length > 0) {
              return t;
            }
            t = $field.filter('[name="' + identifier + '[]"]');
            if (t.length > 0) {
              return t;
            }
            t = $field.filter("[data-" + metadata.validate + '="' + identifier + '"]');
            if (t.length > 0) {
              return t;
            }
            module.error(error.noField.replace("{identifier}", identifier));
            return strict ? $() : $("<input/>");
          },
          fields: function(fields, strict) {
            var $fields = $();
            $.each(fields, function(index, name) {
              $fields = $fields.add(module.get.field(name, strict));
            });
            return $fields;
          },
          fieldLabel: function(identifier, useIdAsFallback) {
            var $field2 = typeof identifier === "string" ? module.get.field(identifier) : identifier, $label = $field2.closest(selector.group).find("label").eq(0);
            return $label.length === 1 ? $label.text() : $field2.prop("placeholder") || (useIdAsFallback ? identifier : settings.text.unspecifiedField);
          },
          validation: function($field2) {
            var fieldValidation, identifier;
            if (!validation) {
              return false;
            }
            $.each(validation, function(fieldName, field) {
              identifier = field.identifier || fieldName;
              $.each(module.get.field(identifier), function(index, groupField) {
                if (groupField == $field2[0]) {
                  field.identifier = identifier;
                  fieldValidation = field;
                  return false;
                }
              });
            });
            return fieldValidation || false;
          },
          value: function(field, strict) {
            var fields = [], results, resultKeys;
            fields.push(field);
            results = module.get.values.call(element2, fields, strict);
            resultKeys = Object.keys(results);
            return resultKeys.length > 0 ? results[resultKeys[0]] : void 0;
          },
          values: function(fields, strict) {
            var $fields = Array.isArray(fields) && fields.length > 0 ? module.get.fields(fields, strict) : $field, values = {};
            $fields.each(function(index, field) {
              var $field2 = $(field), $calendar = $field2.closest(selector.uiCalendar), name = $field2.prop("name"), value = $field2.val(), isCheckbox = $field2.is(selector.checkbox), isRadio = $field2.is(selector.radio), isMultiple = name.indexOf("[]") !== -1, isCalendar = $calendar.length > 0 && module.can.useElement("calendar"), isChecked = isCheckbox ? $field2.is(":checked") : false;
              if (name) {
                if (isMultiple) {
                  name = name.replace("[]", "");
                  if (!values[name]) {
                    values[name] = [];
                  }
                  if (isCheckbox) {
                    if (isChecked) {
                      values[name].push(value || true);
                    } else {
                      values[name].push(false);
                    }
                  } else {
                    values[name].push(value);
                  }
                } else {
                  if (isRadio) {
                    if (values[name] === void 0 || values[name] === false) {
                      values[name] = isChecked ? value || true : false;
                    }
                  } else if (isCheckbox) {
                    values[name] = isChecked ? value || true : false;
                  } else if (isCalendar) {
                    var date = $calendar.calendar("get date");
                    if (date !== null) {
                      switch (settings.dateHandling) {
                        case "date": {
                          values[name] = date;
                          break;
                        }
                        case "input": {
                          values[name] = $calendar.calendar("get input date");
                          break;
                        }
                        case "formatter": {
                          var type = $calendar.calendar("setting", "type");
                          switch (type) {
                            case "date": {
                              values[name] = settings.formatter.date(date);
                              break;
                            }
                            case "datetime": {
                              values[name] = settings.formatter.datetime(date);
                              break;
                            }
                            case "time": {
                              values[name] = settings.formatter.time(date);
                              break;
                            }
                            case "month": {
                              values[name] = settings.formatter.month(date);
                              break;
                            }
                            case "year": {
                              values[name] = settings.formatter.year(date);
                              break;
                            }
                            default: {
                              module.debug("Wrong calendar mode", $calendar, type);
                              values[name] = "";
                            }
                          }
                          break;
                        }
                      }
                    } else {
                      values[name] = "";
                    }
                  } else {
                    values[name] = value;
                  }
                }
              }
            });
            return values;
          },
          dirtyFields: function() {
            return $field.filter(function(index, e) {
              return $(e).data(metadata.isDirty);
            });
          }
        },
        has: {
          field: function(identifier) {
            module.verbose("Checking for existence of a field with identifier", identifier);
            return module.get.field(identifier, true).length > 0;
          }
        },
        can: {
          useElement: function(element3) {
            if ($.fn[element3] !== void 0) {
              return true;
            }
            module.error(error.noElement.replace("{element}", element3));
            return false;
          }
        },
        escape: {
          string: function(text) {
            text = String(text);
            return text.replace(regExp.escape, "\\$&");
          }
        },
        checkErrors: function(errors, internal) {
          if (!errors || errors.length === 0) {
            if (!internal) {
              module.error(settings.error.noErrorMessage);
            }
            return false;
          }
          if (!internal) {
            errors = typeof errors === "string" ? [errors] : errors;
          }
          return errors;
        },
        add: {
          // alias
          rule: function(name, rules) {
            module.add.field(name, rules);
          },
          field: function(name, rules) {
            if (validation[name] === void 0 || validation[name].rules === void 0) {
              validation[name] = {
                rules: []
              };
            }
            var newValidation = {
              rules: []
            };
            if (module.is.shorthandRules(rules)) {
              rules = Array.isArray(rules) ? rules : [rules];
              $.each(rules, function(_index, rule) {
                newValidation.rules.push({ type: rule });
              });
            } else {
              newValidation.rules = rules.rules;
            }
            $.each(newValidation.rules, function(_index, rule) {
              if ($.grep(validation[name].rules, function(item) {
                return item.type === rule.type;
              }).length === 0) {
                validation[name].rules.push(rule);
              }
            });
            module.debug("Adding rules", newValidation.rules, validation);
            module.refreshEvents();
          },
          fields: function(fields) {
            validation = $.extend(true, {}, validation, module.get.fieldsFromShorthand(fields));
            module.refreshEvents();
          },
          prompt: function(identifier, errors, internal) {
            errors = module.checkErrors(errors);
            if (errors === false) {
              return;
            }
            var $field2 = module.get.field(identifier), $fieldGroup = $field2.closest($group), $prompt2 = $fieldGroup.children(selector.prompt), promptExists = $prompt2.length > 0;
            module.verbose("Adding field error state", identifier);
            if (!internal) {
              $fieldGroup.addClass(className.error);
            }
            if (settings.inline) {
              if (!promptExists) {
                $prompt2 = $("<div/>").addClass(className.label);
                $prompt2.appendTo($fieldGroup);
              }
              $prompt2.html(settings.templates.prompt(errors));
              if (!promptExists) {
                if (settings.transition && module.can.useElement("transition")) {
                  module.verbose("Displaying error with css transition", settings.transition);
                  $prompt2.transition(settings.transition + " in", settings.duration);
                } else {
                  module.verbose("Displaying error with fallback javascript animation");
                  $prompt2.fadeIn(settings.duration);
                }
              } else {
                module.verbose("Inline errors are disabled, no inline error added", identifier);
              }
            }
          },
          errors: function(errors) {
            errors = module.checkErrors(errors);
            if (errors === false) {
              return;
            }
            module.debug("Adding form error messages", errors);
            module.set.error();
            var customErrors = [], tempErrors;
            if ($.isPlainObject(errors)) {
              $.each(Object.keys(errors), function(i, id) {
                if (module.checkErrors(errors[id], true) !== false) {
                  if (settings.inline) {
                    module.add.prompt(id, errors[id]);
                  } else {
                    tempErrors = module.checkErrors(errors[id]);
                    if (tempErrors !== false) {
                      $.each(tempErrors, function(index, tempError) {
                        customErrors.push(settings.prompt.addErrors.replace(/{name}/g, module.get.fieldLabel(id)).replace(/{error}/g, tempError));
                      });
                    }
                  }
                }
              });
            } else {
              customErrors = errors;
            }
            if (customErrors.length > 0) {
              $message.html(settings.templates.error(customErrors));
            }
          }
        },
        remove: {
          errors: function() {
            module.debug("Removing form error messages");
            $message.empty();
          },
          states: function() {
            $module.removeClass(className.error).removeClass(className.success);
            if (!settings.inline) {
              module.remove.errors();
            }
            module.determine.isDirty();
          },
          rule: function(field, rule) {
            var rules = Array.isArray(rule) ? rule : [rule];
            if (validation[field] === void 0 || !Array.isArray(validation[field].rules)) {
              return;
            }
            if (rule === void 0) {
              module.debug("Removed all rules");
              if (module.has.field(field)) {
                validation[field].rules = [];
              } else {
                delete validation[field];
              }
              return;
            }
            $.each(validation[field].rules, function(index, rule2) {
              if (rule2 && rules.indexOf(rule2.type) !== -1) {
                module.debug("Removed rule", rule2.type);
                validation[field].rules.splice(index, 1);
              }
            });
          },
          field: function(field) {
            var fields = Array.isArray(field) ? field : [field];
            $.each(fields, function(index, field2) {
              module.remove.rule(field2);
            });
            module.refreshEvents();
          },
          // alias
          rules: function(field, rules) {
            if (Array.isArray(field)) {
              $.each(field, function(index, field2) {
                module.remove.rule(field2, rules);
              });
            } else {
              module.remove.rule(field, rules);
            }
          },
          fields: function(fields) {
            module.remove.field(fields);
          },
          prompt: function(identifier) {
            var $field2 = module.get.field(identifier), $fieldGroup = $field2.closest($group), $prompt2 = $fieldGroup.children(selector.prompt);
            $fieldGroup.removeClass(className.error);
            if (settings.inline && $prompt2.is(":visible")) {
              module.verbose("Removing prompt for field", identifier);
              if (settings.transition && module.can.useElement("transition")) {
                $prompt2.transition(settings.transition + " out", settings.duration, function() {
                  $prompt2.remove();
                });
              } else {
                $prompt2.fadeOut(settings.duration, function() {
                  $prompt2.remove();
                });
              }
            }
          }
        },
        set: {
          success: function() {
            $module.removeClass(className.error).addClass(className.success);
          },
          defaults: function() {
            $field.each(function(index, el) {
              var $el = $(el), $parent = $el.parent(), isCheckbox = $el.filter(selector.checkbox).length > 0, isDropdown = ($parent.is(selector.uiDropdown) || $el.is(selector.uiDropdown)) && module.can.useElement("dropdown"), $calendar = $el.closest(selector.uiCalendar), isCalendar = $calendar.length > 0 && module.can.useElement("calendar"), value = isCheckbox ? $el.is(":checked") : $el.val();
              if (isDropdown) {
                if ($parent.is(selector.uiDropdown)) {
                  $parent.dropdown("save defaults");
                } else {
                  $el.dropdown("save defaults");
                }
              } else if (isCalendar) {
                $calendar.calendar("refresh");
              }
              $el.data(metadata.defaultValue, value);
              $el.data(metadata.isDirty, false);
            });
          },
          error: function() {
            $module.removeClass(className.success).addClass(className.error);
          },
          value: function(field, value) {
            var fields = {};
            fields[field] = value;
            return module.set.values.call(element2, fields);
          },
          values: function(fields) {
            if ($.isEmptyObject(fields)) {
              return;
            }
            $.each(fields, function(key, value) {
              var $field2 = module.get.field(key), $element = $field2.parent(), $calendar = $field2.closest(selector.uiCalendar), isMultiple = Array.isArray(value), isCheckbox = $element.is(selector.uiCheckbox) && module.can.useElement("checkbox"), isDropdown = $element.is(selector.uiDropdown) && module.can.useElement("dropdown"), isRadio = $field2.is(selector.radio) && isCheckbox, isCalendar = $calendar.length > 0 && module.can.useElement("calendar"), fieldExists = $field2.length > 0, $multipleField;
              if (fieldExists) {
                if (isMultiple && isCheckbox) {
                  module.verbose("Selecting multiple", value, $field2);
                  $element.checkbox("uncheck");
                  $.each(value, function(index, value2) {
                    $multipleField = $field2.filter('[value="' + value2 + '"]');
                    $element = $multipleField.parent();
                    if ($multipleField.length > 0) {
                      $element.checkbox("check");
                    }
                  });
                } else if (isRadio) {
                  module.verbose("Selecting radio value", value, $field2);
                  $field2.filter('[value="' + value + '"]').parent(selector.uiCheckbox).checkbox("check");
                } else if (isCheckbox) {
                  module.verbose("Setting checkbox value", value, $element);
                  if (value === true || value === 1 || value === "on") {
                    $element.checkbox("check");
                  } else {
                    $element.checkbox("uncheck");
                  }
                  if (typeof value === "string") {
                    $field2.val(value);
                  }
                } else if (isDropdown) {
                  module.verbose("Setting dropdown value", value, $element);
                  $element.dropdown("set selected", value);
                } else if (isCalendar) {
                  $calendar.calendar("set date", value);
                } else {
                  module.verbose("Setting field value", value, $field2);
                  $field2.val(value);
                }
              }
            });
          },
          dirty: function() {
            module.verbose("Setting state dirty");
            dirty = true;
            history[0] = history[1];
            history[1] = "dirty";
            if (module.is.justClean()) {
              $module.trigger("dirty");
            }
          },
          clean: function() {
            module.verbose("Setting state clean");
            dirty = false;
            history[0] = history[1];
            history[1] = "clean";
            if (module.is.justDirty()) {
              $module.trigger("clean");
            }
          },
          asClean: function() {
            module.set.defaults();
            module.set.clean();
          },
          asDirty: function() {
            module.set.defaults();
            module.set.dirty();
          },
          autoCheck: function() {
            module.debug("Enabling auto check on required fields");
            if (validation) {
              $.each(validation, function(fieldName) {
                if (!module.has.field(fieldName)) {
                  module.verbose("Field not found, removing from validation", fieldName);
                  module.remove.field(fieldName);
                }
              });
            }
            $field.each(function(_index, el) {
              var $el = $(el), $elGroup = $el.closest($group), isCheckbox = $el.filter(selector.checkbox).length > 0, isRequired = $el.prop("required") || $elGroup.hasClass(className.required) || $elGroup.parent().hasClass(className.required), isDisabled = $el.is(":disabled") || $elGroup.hasClass(className.disabled) || $elGroup.parent().hasClass(className.disabled), validation2 = module.get.validation($el), hasEmptyRule = validation2 ? $.grep(validation2.rules, function(rule) {
                return rule.type === "empty";
              }) !== 0 : false, identifier = validation2.identifier || $el.attr("id") || $el.attr("name") || $el.data(metadata.validate);
              if (isRequired && !isDisabled && !hasEmptyRule && identifier !== void 0) {
                if (isCheckbox) {
                  module.verbose("Adding 'checked' rule on field", identifier);
                  module.add.rule(identifier, "checked");
                } else {
                  module.verbose("Adding 'empty' rule on field", identifier);
                  module.add.rule(identifier, "empty");
                }
              }
            });
          },
          optional: function(identifier, bool) {
            bool = bool !== false;
            $.each(validation, function(fieldName, field) {
              if (identifier === fieldName || identifier === field.identifier) {
                field.optional = bool;
              }
            });
          }
        },
        validate: {
          form: function(event2, ignoreCallbacks) {
            var values = module.get.values();
            if (keyHeldDown) {
              return false;
            }
            formErrors = [];
            if (module.determine.isValid()) {
              module.debug("Form has no validation errors, submitting");
              module.set.success();
              if (!settings.inline) {
                module.remove.errors();
              }
              if (ignoreCallbacks !== true) {
                return settings.onSuccess.call(element2, event2, values);
              }
            } else {
              module.debug("Form has errors");
              submitting = false;
              module.set.error();
              if (!settings.inline) {
                module.add.errors(formErrors);
              }
              if (event2 && $module.data("moduleApi") !== void 0) {
                event2.stopImmediatePropagation();
              }
              if (settings.errorFocus && ignoreCallbacks !== true) {
                var $focusElement, hasTabIndex = true;
                if (typeof settings.errorFocus === "string") {
                  $focusElement = $(document2).find(settings.errorFocus);
                  hasTabIndex = $focusElement.is("[tabindex]");
                  if (!hasTabIndex) {
                    $focusElement.attr("tabindex", -1);
                  }
                } else {
                  $focusElement = $group.filter("." + className.error).first().find(selector.field);
                }
                $focusElement.trigger("focus");
                if (!hasTabIndex) {
                  $focusElement.removeAttr("tabindex");
                }
              }
              if (ignoreCallbacks !== true) {
                return settings.onFailure.call(element2, formErrors, values);
              }
            }
          },
          // takes a validation object and returns whether field passes validation
          field: function(field, fieldName, showErrors) {
            showErrors = showErrors !== void 0 ? showErrors : true;
            if (typeof field === "string") {
              module.verbose("Validating field", field);
              fieldName = field;
              field = validation[field];
            }
            if (!field) {
              module.debug("Unable to find field validation. Skipping", fieldName);
              return true;
            }
            var identifier = field.identifier || fieldName, $field2 = module.get.field(identifier), $dependsField = field.depends ? module.get.field(field.depends) : false, fieldValid = true, fieldErrors = [];
            if (!field.identifier) {
              module.debug("Using field name as identifier", identifier);
              field.identifier = identifier;
            }
            var isDisabled = $field2.filter(":not(:disabled)").length === 0;
            if (isDisabled) {
              module.debug("Field is disabled. Skipping", identifier);
            } else if (field.optional && module.is.blank($field2)) {
              module.debug("Field is optional and blank. Skipping", identifier);
            } else if (field.depends && module.is.empty($dependsField)) {
              module.debug("Field depends on another value that is not present or empty. Skipping", $dependsField);
            } else if (field.rules !== void 0) {
              if (showErrors) {
                $field2.closest($group).removeClass(className.error);
              }
              $.each(field.rules, function(index, rule) {
                if (module.has.field(identifier)) {
                  var invalidFields = module.validate.rule(field, rule, true) || [];
                  if (invalidFields.length > 0) {
                    module.debug("Field is invalid", identifier, rule.type);
                    fieldErrors.push(module.get.prompt(rule, field));
                    fieldValid = false;
                    if (showErrors) {
                      $(invalidFields).closest($group).addClass(className.error);
                    }
                  }
                }
              });
            }
            if (fieldValid) {
              if (showErrors) {
                module.remove.prompt(identifier, fieldErrors);
                settings.onValid.call($field2);
              }
            } else {
              if (showErrors) {
                formErrors = formErrors.concat(fieldErrors);
                module.add.prompt(identifier, fieldErrors, true);
                settings.onInvalid.call($field2, fieldErrors);
              }
              return false;
            }
            return true;
          },
          // takes validation rule and returns whether field passes rule
          rule: function(field, rule, internal) {
            var $field2 = module.get.field(field.identifier), ancillary = module.get.ancillaryValue(rule), ruleName = module.get.ruleName(rule), ruleFunction = settings.rules[ruleName], invalidFields = [], isCheckbox = $field2.is(selector.checkbox), isValid = function(field2) {
              var value = isCheckbox ? $(field2).filter(":checked").val() : $(field2).val();
              value = value === void 0 || value === "" || value === null ? "" : settings.shouldTrim && rule.shouldTrim !== false || rule.shouldTrim ? String(value + "").trim() : String(value + "");
              return ruleFunction.call(field2, value, ancillary, module);
            };
            if (!isFunction(ruleFunction)) {
              module.error(error.noRule, ruleName);
              return;
            }
            if (isCheckbox) {
              if (!isValid($field2)) {
                invalidFields = $field2;
              }
            } else {
              $.each($field2, function(index, field2) {
                if (!isValid(field2)) {
                  invalidFields.push(field2);
                }
              });
            }
            return internal ? invalidFields : invalidFields.length === 0;
          }
        },
        setting: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            settings[name] = value;
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      module.initialize();
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.form.settings = {
    name: "Form",
    namespace: "form",
    debug: false,
    verbose: false,
    performance: true,
    fields: false,
    keyboardShortcuts: true,
    on: "submit",
    inline: false,
    delay: 200,
    revalidate: true,
    shouldTrim: true,
    transition: "scale",
    duration: 200,
    autoCheckRequired: false,
    preventLeaving: false,
    errorFocus: true,
    dateHandling: "date",
    // 'date', 'input', 'formatter'
    onValid: function() {
    },
    onInvalid: function() {
    },
    onSuccess: function() {
      return true;
    },
    onFailure: function() {
      return false;
    },
    onDirty: function() {
    },
    onClean: function() {
    },
    metadata: {
      defaultValue: "default",
      validate: "validate",
      isDirty: "isDirty"
    },
    regExp: {
      htmlID: /^[A-Za-z][\w.:-]*$/g,
      bracket: /\[(.*)]/i,
      decimal: /^\d+\.?\d*$/,
      email: /^[\w!#$%&'*+./=?^`{|}~-]+@[\da-z]([\da-z-]*[\da-z])?(\.[\da-z]([\da-z-]*[\da-z])?)*$/i,
      escape: /[$()*+,./:=?@[\\\]^{|}-]/g,
      flags: /^\/(.*)\/(.*)?/,
      integer: /^-?\d+$/,
      number: /^-?\d*(\.\d+)?$/,
      url: /(https?:\/\/(?:www\.|(?!www))[^\s.]+\.\S{2,}|www\.\S+\.\S{2,})/i
    },
    text: {
      and: "and",
      unspecifiedRule: "Please enter a valid value",
      unspecifiedField: "This field",
      leavingMessage: "There are unsaved changes on this page which will be discarded if you continue."
    },
    prompt: {
      range: "{name} must be in a range from {min} to {max}",
      maxValue: "{name} must have a maximum value of {ruleValue}",
      minValue: "{name} must have a minimum value of {ruleValue}",
      empty: "{name} must have a value",
      checked: "{name} must be checked",
      email: "{name} must be a valid e-mail",
      url: "{name} must be a valid url",
      regExp: "{name} is not formatted correctly",
      integer: "{name} must be an integer",
      decimal: "{name} must be a decimal number",
      number: "{name} must be set to a number",
      is: '{name} must be "{ruleValue}"',
      isExactly: '{name} must be exactly "{ruleValue}"',
      not: '{name} cannot be set to "{ruleValue}"',
      notExactly: '{name} cannot be set to exactly "{ruleValue}"',
      contain: '{name} must contain "{ruleValue}"',
      containExactly: '{name} must contain exactly "{ruleValue}"',
      doesntContain: '{name} cannot contain "{ruleValue}"',
      doesntContainExactly: '{name} cannot contain exactly "{ruleValue}"',
      minLength: "{name} must be at least {ruleValue} characters",
      exactLength: "{name} must be exactly {ruleValue} characters",
      maxLength: "{name} cannot be longer than {ruleValue} characters",
      size: "{name} must have a length between {min} and {max} characters",
      match: "{name} must match {ruleValue} field",
      different: "{name} must have a different value than {ruleValue} field",
      creditCard: "{name} must be a valid credit card number",
      minCount: "{name} must have at least {ruleValue} choices",
      exactCount: "{name} must have exactly {ruleValue} choices",
      maxCount: "{name} must have {ruleValue} or less choices",
      addErrors: "{name}: {error}"
    },
    selector: {
      checkbox: 'input[type="checkbox"], input[type="radio"]',
      clear: ".clear",
      field: 'input:not(.search):not([type="file"]):not([type="reset"]):not([type="button"]):not([type="submit"]), textarea, select',
      group: ".field",
      input: 'input:not([type="file"])',
      message: ".error.message",
      prompt: ".prompt.label",
      radio: 'input[type="radio"]',
      reset: '.reset:not([type="reset"])',
      submit: '.submit:not([type="submit"])',
      uiCheckbox: ".ui.checkbox",
      uiDropdown: ".ui.dropdown",
      uiCalendar: ".ui.calendar"
    },
    className: {
      error: "error",
      label: "ui basic red pointing prompt label",
      pressed: "down",
      success: "success",
      required: "required",
      disabled: "disabled"
    },
    error: {
      method: "The method you called is not defined.",
      noRule: "There is no rule matching the one you specified",
      noField: "Field identifier {identifier} not found",
      noElement: "This module requires ui {element}",
      noErrorMessage: "No error message provided"
    },
    templates: {
      // template that produces error message
      error: function(errors) {
        var html = '<ul class="list">';
        $.each(errors, function(index, value) {
          html += "<li>" + value + "</li>";
        });
        html += "</ul>";
        return html;
      },
      // template that produces label content
      prompt: function(errors) {
        if (errors.length === 1) {
          return errors[0];
        }
        var html = '<ul class="ui list">';
        $.each(errors, function(index, value) {
          html += "<li>" + value + "</li>";
        });
        html += "</ul>";
        return html;
      }
    },
    formatter: {
      date: function(date) {
        return Intl.DateTimeFormat("en-GB").format(date);
      },
      datetime: function(date) {
        return Intl.DateTimeFormat("en-GB", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        }).format(date);
      },
      time: function(date) {
        return Intl.DateTimeFormat("en-GB", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        }).format(date);
      },
      month: function(date) {
        return Intl.DateTimeFormat("en-GB", {
          month: "2-digit",
          year: "numeric"
        }).format(date);
      },
      year: function(date) {
        return Intl.DateTimeFormat("en-GB", {
          year: "numeric"
        }).format(date);
      }
    },
    rules: {
      // is not empty or blank string
      empty: function(value) {
        return !(value === void 0 || value === "" || Array.isArray(value) && value.length === 0);
      },
      // checkbox checked
      checked: function() {
        return $(this).filter(":checked").length > 0;
      },
      // is most likely an email
      email: function(value) {
        return $.fn.form.settings.regExp.email.test(value);
      },
      // value is most likely url
      url: function(value) {
        return $.fn.form.settings.regExp.url.test(value);
      },
      // matches specified regExp
      regExp: function(value, regExp) {
        if (regExp instanceof RegExp) {
          return value.match(regExp);
        }
        var regExpParts = regExp.match($.fn.form.settings.regExp.flags), flags;
        if (regExpParts) {
          regExp = regExpParts.length >= 2 ? regExpParts[1] : regExp;
          flags = regExpParts.length >= 3 ? regExpParts[2] : "";
        }
        return value.match(new RegExp(regExp, flags));
      },
      minValue: function(value, range) {
        return $.fn.form.settings.rules.range(value, range + "..", "number");
      },
      maxValue: function(value, range) {
        return $.fn.form.settings.rules.range(value, ".." + range, "number");
      },
      // is valid integer or matches range
      integer: function(value, range) {
        return $.fn.form.settings.rules.range(value, range, "integer");
      },
      range: function(value, range, regExp, testLength) {
        if (typeof regExp === "string") {
          regExp = $.fn.form.settings.regExp[regExp];
        }
        if (!(regExp instanceof RegExp)) {
          regExp = $.fn.form.settings.regExp.integer;
        }
        var min, max, parts;
        if (!range || ["", ".."].indexOf(range) !== -1) {
        } else if (range.indexOf("..") === -1) {
          if (regExp.test(range)) {
            min = range - 0;
            max = min;
          }
        } else {
          parts = range.split("..", 2);
          if (regExp.test(parts[0])) {
            min = parts[0] - 0;
          }
          if (regExp.test(parts[1])) {
            max = parts[1] - 0;
          }
        }
        if (testLength) {
          value = value.length;
        }
        return regExp.test(value) && (min === void 0 || value >= min) && (max === void 0 || value <= max);
      },
      // is valid number (with decimal)
      decimal: function(value, range) {
        return $.fn.form.settings.rules.range(value, range, "decimal");
      },
      // is valid number
      number: function(value, range) {
        return $.fn.form.settings.rules.range(value, range, "number");
      },
      // is value (case insensitive)
      is: function(value, text) {
        text = typeof text === "string" ? text.toLowerCase() : text;
        value = typeof value === "string" ? value.toLowerCase() : value;
        return value == text;
      },
      // is value
      isExactly: function(value, text) {
        return value == text;
      },
      // value is not another value (case insensitive)
      not: function(value, notValue) {
        value = typeof value === "string" ? value.toLowerCase() : value;
        notValue = typeof notValue === "string" ? notValue.toLowerCase() : notValue;
        return value != notValue;
      },
      // value is not another value (case sensitive)
      notExactly: function(value, notValue) {
        return value != notValue;
      },
      // value contains text (insensitive)
      contains: function(value, text) {
        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
        return value.search(new RegExp(text, "i")) !== -1;
      },
      // value contains text (case sensitive)
      containsExactly: function(value, text) {
        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
        return value.search(new RegExp(text)) !== -1;
      },
      // value contains text (insensitive)
      doesntContain: function(value, text) {
        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
        return value.search(new RegExp(text, "i")) === -1;
      },
      // value contains text (case sensitive)
      doesntContainExactly: function(value, text) {
        text = text.replace($.fn.form.settings.regExp.escape, "\\$&");
        return value.search(new RegExp(text)) === -1;
      },
      // is at least string length
      minLength: function(value, minLength) {
        return $.fn.form.settings.rules.range(value, minLength + "..", "integer", true);
      },
      // is exactly length
      exactLength: function(value, requiredLength) {
        return $.fn.form.settings.rules.range(value, requiredLength + ".." + requiredLength, "integer", true);
      },
      // is less than length
      maxLength: function(value, maxLength) {
        return $.fn.form.settings.rules.range(value, ".." + maxLength, "integer", true);
      },
      size: function(value, range) {
        return $.fn.form.settings.rules.range(value, range, "integer", true);
      },
      // matches another field
      match: function(value, identifier, module) {
        var matchingValue = module.get.value(identifier, true);
        return matchingValue !== void 0 ? value.toString() === matchingValue.toString() : false;
      },
      // different than another field
      different: function(value, identifier, module) {
        var matchingValue = module.get.value(identifier, true);
        return matchingValue !== void 0 ? value.toString() !== matchingValue.toString() : false;
      },
      creditCard: function(cardNumber, cardTypes) {
        var cards = {
          visa: {
            pattern: /^4/,
            length: [16]
          },
          amex: {
            pattern: /^3[47]/,
            length: [15]
          },
          mastercard: {
            pattern: /^5[1-5]/,
            length: [16]
          },
          discover: {
            pattern: /^(6011|622(12[6-9]|1[3-9]\d|[2-8]\d{2}|9[01]\d|92[0-5]|64[4-9])|65)/,
            length: [16]
          },
          unionPay: {
            pattern: /^(62|88)/,
            length: [16, 17, 18, 19]
          },
          jcb: {
            pattern: /^35(2[89]|[3-8]\d)/,
            length: [16]
          },
          maestro: {
            pattern: /^(5018|5020|5038|6304|6759|676[1-3])/,
            length: [12, 13, 14, 15, 16, 17, 18, 19]
          },
          dinersClub: {
            pattern: /^(30[0-5]|^36)/,
            length: [14]
          },
          laser: {
            pattern: /^(6304|670[69]|6771)/,
            length: [16, 17, 18, 19]
          },
          visaElectron: {
            pattern: /^(4026|417500|4508|4844|491(3|7))/,
            length: [16]
          }
        }, valid = {}, validCard = false, requiredTypes = typeof cardTypes === "string" ? cardTypes.split(",") : false, unionPay, validation;
        if (typeof cardNumber !== "string" || cardNumber.length === 0) {
          return;
        }
        cardNumber = cardNumber.replace(/[\s-]/g, "");
        if (requiredTypes) {
          $.each(requiredTypes, function(index, type) {
            validation = cards[type];
            if (validation) {
              valid = {
                length: $.inArray(cardNumber.length, validation.length) !== -1,
                pattern: cardNumber.search(validation.pattern) !== -1
              };
              if (valid.length > 0 && valid.pattern) {
                validCard = true;
              }
            }
          });
          if (!validCard) {
            return false;
          }
        }
        unionPay = {
          number: $.inArray(cardNumber.length, cards.unionPay.length) !== -1,
          pattern: cardNumber.search(cards.unionPay.pattern) !== -1
        };
        if (unionPay.number && unionPay.pattern) {
          return true;
        }
        var length = cardNumber.length, multiple = 0, producedValue = [
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
          [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]
        ], sum = 0;
        while (length--) {
          sum += producedValue[multiple][parseInt(cardNumber.charAt(length), 10)];
          multiple ^= 1;
        }
        return sum % 10 === 0 && sum > 0;
      },
      minCount: function(value, minCount) {
        minCount = Number(minCount);
        if (minCount === 0) {
          return true;
        }
        if (minCount === 1) {
          return value !== "";
        }
        return value.split(",").length >= minCount;
      },
      exactCount: function(value, exactCount) {
        exactCount = Number(exactCount);
        if (exactCount === 0) {
          return value === "";
        }
        if (exactCount === 1) {
          return value !== "" && value.search(",") === -1;
        }
        return value.split(",").length === exactCount;
      },
      maxCount: function(value, maxCount) {
        maxCount = Number(maxCount);
        if (maxCount === 0) {
          return false;
        }
        if (maxCount === 1) {
          return value.search(",") === -1;
        }
        return value.split(",").length <= maxCount;
      }
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.accordion = function(parameters) {
    var $allModules = $(this), time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.accordion.settings, parameters) : $.extend({}, $.fn.accordion.settings), className = settings.className, namespace = settings.namespace, selector = settings.selector, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, moduleSelector = $allModules.selector || "", $module = $(this), $title = $module.find(selector.title), $content = $module.find(selector.content), element2 = this, instance68 = $module.data(moduleNamespace), observer, module;
      module = {
        initialize: function() {
          module.debug("Initializing", $module);
          module.bind.events();
          if (settings.observeChanges) {
            module.observeChanges();
          }
          module.instantiate();
        },
        instantiate: function() {
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.debug("Destroying previous instance", $module);
          $module.off(eventNamespace).removeData(moduleNamespace);
        },
        refresh: function() {
          $title = $module.find(selector.title);
          $content = $module.find(selector.content);
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            observer = new MutationObserver(function(mutations) {
              module.debug("DOM tree modified, updating selector cache");
              module.refresh();
            });
            observer.observe(element2, {
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", observer);
          }
        },
        bind: {
          events: function() {
            module.debug("Binding delegated events");
            $module.on(settings.on + eventNamespace, selector.trigger, module.event.click);
          }
        },
        event: {
          click: function(event2) {
            if ($(event2.target).closest(selector.ignore).length === 0) {
              module.toggle.call(this);
            }
          }
        },
        toggle: function(query2) {
          var $activeTitle = query2 !== void 0 ? typeof query2 === "number" ? $title.eq(query2) : $(query2).closest(selector.title) : $(this).closest(selector.title), $activeContent = $activeTitle.next($content), isAnimating = $activeContent.hasClass(className.animating), isActive = $activeContent.hasClass(className.active), isOpen = isActive && !isAnimating, isOpening = !isActive && isAnimating;
          module.debug("Toggling visibility of content", $activeTitle);
          if (isOpen || isOpening) {
            if (settings.collapsible) {
              module.close.call($activeTitle);
            } else {
              module.debug("Cannot close accordion content collapsing is disabled");
            }
          } else {
            module.open.call($activeTitle);
          }
        },
        open: function(query2) {
          var $activeTitle = query2 !== void 0 ? typeof query2 === "number" ? $title.eq(query2) : $(query2).closest(selector.title) : $(this).closest(selector.title), $activeContent = $activeTitle.next($content), isAnimating = $activeContent.hasClass(className.animating), isActive = $activeContent.hasClass(className.active), isOpen = isActive || isAnimating;
          if (isOpen) {
            module.debug("Accordion already open, skipping", $activeContent);
            return;
          }
          module.debug("Opening accordion content", $activeTitle);
          settings.onOpening.call($activeContent);
          settings.onChanging.call($activeContent);
          if (settings.exclusive) {
            module.closeOthers.call($activeTitle);
          }
          $activeTitle.addClass(className.active);
          $activeContent.stop(true, true).addClass(className.animating);
          if (settings.animateChildren) {
            if ($.fn.transition !== void 0) {
              $activeContent.children().transition({
                animation: "fade in",
                queue: false,
                useFailSafe: true,
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                duration: settings.duration,
                skipInlineHidden: true,
                onComplete: function() {
                  $activeContent.children().removeClass(className.transition);
                }
              });
            } else {
              $activeContent.children().stop(true, true).animate({
                opacity: 1
              }, settings.duration, module.resetOpacity);
            }
          }
          $activeContent.slideDown(settings.duration, settings.easing, function() {
            $activeContent.removeClass(className.animating).addClass(className.active);
            module.reset.display.call(this);
            settings.onOpen.call(this);
            settings.onChange.call(this);
          });
        },
        close: function(query2) {
          var $activeTitle = query2 !== void 0 ? typeof query2 === "number" ? $title.eq(query2) : $(query2).closest(selector.title) : $(this).closest(selector.title), $activeContent = $activeTitle.next($content), isAnimating = $activeContent.hasClass(className.animating), isActive = $activeContent.hasClass(className.active), isOpening = !isActive && isAnimating, isClosing = isActive && isAnimating;
          if ((isActive || isOpening) && !isClosing) {
            module.debug("Closing accordion content", $activeContent);
            settings.onClosing.call($activeContent);
            settings.onChanging.call($activeContent);
            $activeTitle.removeClass(className.active);
            $activeContent.stop(true, true).addClass(className.animating);
            if (settings.animateChildren) {
              if ($.fn.transition !== void 0) {
                $activeContent.children().transition({
                  animation: "fade out",
                  queue: false,
                  useFailSafe: true,
                  debug: settings.debug,
                  verbose: settings.verbose,
                  silent: settings.silent,
                  duration: settings.duration,
                  skipInlineHidden: true
                });
              } else {
                $activeContent.children().stop(true, true).animate({
                  opacity: 0
                }, settings.duration, module.resetOpacity);
              }
            }
            $activeContent.slideUp(settings.duration, settings.easing, function() {
              $activeContent.removeClass(className.animating).removeClass(className.active);
              module.reset.display.call(this);
              settings.onClose.call(this);
              settings.onChange.call(this);
            });
          }
        },
        closeOthers: function(index) {
          var $activeTitle = index !== void 0 ? $title.eq(index) : $(this).closest(selector.title), $parentTitles = $activeTitle.parents(selector.content).prev(selector.title), $activeAccordion = $activeTitle.closest(selector.accordion), activeSelector = selector.title + "." + className.active + ":visible", activeContent = selector.content + "." + className.active + ":visible", $openTitles, $nestedTitles, $openContents;
          if (settings.closeNested) {
            $openTitles = $activeAccordion.find(activeSelector).not($parentTitles);
            $openContents = $openTitles.next($content);
          } else {
            $openTitles = $activeAccordion.find(activeSelector).not($parentTitles);
            $nestedTitles = $activeAccordion.find(activeContent).find(activeSelector).not($parentTitles);
            $openTitles = $openTitles.not($nestedTitles);
            $openContents = $openTitles.next($content);
          }
          if ($openTitles.length > 0) {
            module.debug("Exclusive enabled, closing other content", $openTitles);
            $openTitles.removeClass(className.active);
            $openContents.removeClass(className.animating).stop(true, true);
            if (settings.animateChildren) {
              if ($.fn.transition !== void 0) {
                $openContents.children().transition({
                  animation: "fade out",
                  useFailSafe: true,
                  debug: settings.debug,
                  verbose: settings.verbose,
                  silent: settings.silent,
                  duration: settings.duration,
                  skipInlineHidden: true
                });
              } else {
                $openContents.children().stop(true, true).animate({
                  opacity: 0
                }, settings.duration, module.resetOpacity);
              }
            }
            $openContents.slideUp(settings.duration, settings.easing, function() {
              $(this).removeClass(className.active);
              module.reset.display.call(this);
            });
          }
        },
        reset: {
          display: function() {
            module.verbose("Removing inline display from element", this);
            var $element = $(this);
            $element.css("display", "");
            if ($element.attr("style") === "") {
              $element.attr("style", "").removeAttr("style");
            }
          },
          opacity: function() {
            module.verbose("Removing inline opacity from element", this);
            var $element = $(this);
            $element.css("opacity", "");
            if ($element.attr("style") === "") {
              $element.attr("style", "").removeAttr("style");
            }
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          module.debug("Changing internal", name, value);
          if (value !== void 0) {
            if ($.isPlainObject(name)) {
              $.extend(true, module, name);
            } else {
              module[name] = value;
            }
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.accordion.settings = {
    name: "Accordion",
    namespace: "accordion",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    on: "click",
    // event on title that opens accordion
    observeChanges: true,
    // whether accordion should automatically refresh on DOM insertion
    exclusive: true,
    // whether a single accordion content panel should be open at once
    collapsible: true,
    // whether accordion content can be closed
    closeNested: false,
    // whether nested content should be closed when a panel is closed
    animateChildren: true,
    // whether children opacity should be animated
    duration: 350,
    // duration of animation
    easing: "easeOutQuad",
    // easing equation for animation
    onOpening: function() {
    },
    // callback before open animation
    onClosing: function() {
    },
    // callback before closing animation
    onChanging: function() {
    },
    // callback before closing or opening animation
    onOpen: function() {
    },
    // callback after open animation
    onClose: function() {
    },
    // callback after closing animation
    onChange: function() {
    },
    // callback after closing or opening animation
    error: {
      method: "The method you called is not defined"
    },
    className: {
      active: "active",
      animating: "animating",
      transition: "transition"
    },
    selector: {
      accordion: ".accordion",
      title: ".title",
      trigger: ".title",
      ignore: ".ui.dropdown",
      content: ".content"
    }
  };
  $.extend($.easing, {
    easeOutQuad: function(x) {
      return 1 - (1 - x) * (1 - x);
    }
  });
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.calendar = function(parameters) {
    var $allModules = $(this), $document = $(document2), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue, timeGapTable = {
      5: { row: 4, column: 3 },
      10: { row: 3, column: 2 },
      15: { row: 2, column: 2 },
      20: { row: 3, column: 1 },
      30: { row: 2, column: 1 }
    }, numberText = ["", "one", "two", "three", "four", "five", "six", "seven", "eight"];
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.calendar.settings, parameters) : $.extend({}, $.fn.calendar.settings), className = settings.className, namespace = settings.namespace, selector = settings.selector, formatter = settings.formatter, parser = settings.parser, metadata = settings.metadata, timeGap = timeGapTable[settings.minTimeGap], error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $input = $module.find(selector.input), $activator = $module.find(selector.activator), element2 = this, instance68 = $module.data(moduleNamespace), $container = instance68 && instance68.popupId ? $document.find("#" + instance68.popupId) : $module.find(selector.popup), isTouch, isTouchDown = false, isInverted = $module.hasClass(className.inverted), focusDateUsedForRange = false, selectionComplete = false, classObserver, module;
      module = {
        initialize: function() {
          module.debug("Initializing calendar for", element2, $module);
          isTouch = module.get.isTouch();
          module.setup.config();
          module.setup.popup();
          module.setup.inline();
          module.setup.input();
          module.setup.date();
          module.create.calendar();
          module.bind.events();
          module.observeChanges();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of calendar");
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        destroy: function() {
          module.verbose("Destroying previous calendar for", element2);
          $module.removeData(moduleNamespace);
          module.unbind.events();
          module.disconnect.classObserver();
        },
        setup: {
          config: function() {
            if (module.get.minDate() !== null) {
              module.set.minDate($module.data(metadata.minDate));
            }
            if (module.get.maxDate() !== null) {
              module.set.maxDate($module.data(metadata.maxDate));
            }
            module.setting("type", module.get.type());
            module.setting("on", settings.on || "click");
          },
          popup: function() {
            if (settings.inline) {
              return;
            }
            if ($activator.length === 0) {
              $activator = $module.children().first();
              if ($activator.length === 0) {
                return;
              }
            }
            if ($.fn.popup === void 0) {
              module.error(error.popup);
              return;
            }
            if ($container.length === 0) {
              if (settings.context) {
                module.popupId = namespace + "_popup_" + (Math.random().toString(16) + "000000000").slice(2, 10);
                $container = $("<div/>", { id: module.popupId }).addClass(className.popup).appendTo($document.find(settings.context));
              } else {
                var $activatorParent = $activator.parent(), domPositionFunction = $activatorParent.closest(selector.append).length > 0 ? "appendTo" : "prependTo";
                $container = $("<div/>").addClass(className.popup)[domPositionFunction]($activatorParent);
              }
            }
            $container.addClass(className.calendar);
            if (isInverted) {
              $container.addClass(className.inverted);
            }
            var onVisible = function() {
              module.refreshTooltips();
              return settings.onVisible.apply($container, arguments);
            };
            var onHidden = function() {
              module.blur();
              return settings.onHidden.apply($container, arguments);
            };
            if ($input.length === 0) {
              $container.attr("tabindex", "0");
              onVisible = function() {
                module.refreshTooltips();
                module.focus();
                return settings.onVisible.apply($container, arguments);
              };
            }
            var onShow = function() {
              module.set.focusDate(module.get.date());
              module.set.mode(module.get.validatedMode(settings.startMode));
              return settings.onShow.apply($container, arguments);
            };
            var on = module.setting("on");
            var options = $.extend({}, settings.popupOptions, {
              popup: $container,
              movePopup: !settings.context,
              on,
              hoverable: on === "hover",
              closable: on === "click",
              onShow,
              onVisible,
              onHide: settings.onHide,
              onHidden
            });
            module.popup(options);
          },
          inline: function() {
            if ($activator.length > 0 && !settings.inline) {
              return;
            }
            settings.inline = true;
            $container = $("<div/>").addClass(className.calendar).appendTo($module);
            if ($input.length === 0) {
              $container.attr("tabindex", "0");
            }
          },
          input: function() {
            if (settings.touchReadonly && $input.length > 0 && isTouch) {
              $input.prop("readonly", true);
            }
            module.check.disabled();
          },
          date: function() {
            var date;
            if (settings.initialDate) {
              date = parser.date(settings.initialDate, settings);
            } else if ($module.data(metadata.date) !== void 0) {
              date = parser.date($module.data(metadata.date), settings);
            } else if ($input.length > 0) {
              date = parser.date($input.val(), settings);
            }
            module.set.date(date, settings.formatInput, false);
            module.set.mode(module.get.mode(), false);
          }
        },
        trigger: {
          change: function() {
            var inputElement = $input[0];
            if (inputElement) {
              var events = document2.createEvent("HTMLEvents");
              module.verbose("Triggering native change event");
              events.initEvent("change", true, false);
              inputElement.dispatchEvent(events);
            }
          }
        },
        create: {
          calendar: function() {
            var i, r, c, p, row, cell, pageGrid;
            var mode = module.get.mode(), today = new Date(), date = module.get.date(), focusDate = module.get.focusDate(), display = module.helper.dateInRange(focusDate || date || parser.date(settings.initialDate, settings) || today);
            if (!focusDate) {
              focusDate = display;
              module.set.focusDate(focusDate, false, false);
            }
            var isYear = mode === "year", isMonth = mode === "month", isDay = mode === "day", isHour = mode === "hour", isMinute = mode === "minute", isTimeOnly = settings.type === "time";
            var multiMonth = Math.max(settings.multiMonth, 1);
            var monthOffset = !isDay ? 0 : module.get.monthOffset();
            var minute = display.getMinutes(), hour = display.getHours(), day = display.getDate(), startMonth = display.getMonth() + monthOffset, year = display.getFullYear();
            var columns = isDay ? settings.showWeekNumbers ? 8 : 7 : isHour ? 4 : timeGap.column;
            var rows = isDay || isHour ? 6 : timeGap.row;
            var pages = isDay ? multiMonth : 1;
            var container = $container;
            var tooltipPosition = container.hasClass("left") ? "right center" : "left center";
            container.empty();
            if (pages > 1) {
              pageGrid = $("<div/>").addClass(className.grid).appendTo(container);
            }
            for (p = 0; p < pages; p++) {
              if (pages > 1) {
                var pageColumn = $("<div/>").addClass(className.column).appendTo(pageGrid);
                container = pageColumn;
              }
              var month = startMonth + p;
              var firstMonthDayColumn = (new Date(year, month, 1).getDay() - settings.firstDayOfWeek % 7 + 7) % 7;
              if (!settings.constantHeight && isDay) {
                var requiredCells = new Date(year, month + 1, 0).getDate() + firstMonthDayColumn;
                rows = Math.ceil(requiredCells / 7);
              }
              var yearChange = isYear ? 10 : isMonth ? 1 : 0, monthChange = isDay ? 1 : 0, dayChange = isHour || isMinute ? 1 : 0, prevNextDay = isHour || isMinute ? day : 1, prevDate = new Date(year - yearChange, month - monthChange, prevNextDay - dayChange, hour), nextDate = new Date(year + yearChange, month + monthChange, prevNextDay + dayChange, hour), prevLast = isYear ? new Date(Math.ceil(year / 10) * 10 - 9, 0, 0) : isMonth ? new Date(year, 0, 0) : isDay ? new Date(year, month, 0) : new Date(year, month, day, -1), nextFirst = isYear ? new Date(Math.ceil(year / 10) * 10 + 1, 0, 1) : isMonth ? new Date(year + 1, 0, 1) : isDay ? new Date(year, month + 1, 1) : new Date(year, month, day + 1);
              var tempMode = mode;
              if (isDay && settings.showWeekNumbers) {
                tempMode += " andweek";
              }
              var table = $("<table/>").addClass(className.table).addClass(tempMode).addClass(numberText[columns] + " column").appendTo(container);
              if (isInverted) {
                table.addClass(className.inverted);
              }
              var textColumns = columns;
              if (!isTimeOnly) {
                var thead = $("<thead/>").appendTo(table);
                row = $("<tr/>").appendTo(thead);
                cell = $("<th/>").attr("colspan", "" + columns).appendTo(row);
                var headerDate = isYear || isMonth ? new Date(year, 0, 1) : isDay ? new Date(year, month, 1) : new Date(year, month, day, hour, minute);
                var headerText = $("<span/>").addClass(className.link).appendTo(cell);
                headerText.text(module.helper.dateFormat(formatter[mode + "Header"], headerDate));
                var newMode = isMonth ? settings.disableYear ? "day" : "year" : isDay ? settings.disableMonth ? "year" : "month" : "day";
                headerText.data(metadata.mode, newMode);
                if (p === 0) {
                  var prev = $("<span/>").addClass(className.prev).appendTo(cell);
                  prev.data(metadata.focusDate, prevDate);
                  prev.toggleClass(className.disabledCell, !module.helper.isDateInRange(prevLast, mode));
                  $("<i/>").addClass(className.prevIcon).appendTo(prev);
                }
                if (p === pages - 1) {
                  var next = $("<span/>").addClass(className.next).appendTo(cell);
                  next.data(metadata.focusDate, nextDate);
                  next.toggleClass(className.disabledCell, !module.helper.isDateInRange(nextFirst, mode));
                  $("<i/>").addClass(className.nextIcon).appendTo(next);
                }
                if (isDay) {
                  row = $("<tr/>").appendTo(thead);
                  if (settings.showWeekNumbers) {
                    cell = $("<th/>").appendTo(row);
                    cell.text(settings.text.weekNo);
                    cell.addClass(className.weekCell);
                    textColumns--;
                  }
                  for (i = 0; i < textColumns; i++) {
                    cell = $("<th/>").appendTo(row);
                    cell.text(formatter.dayColumnHeader((i + settings.firstDayOfWeek) % 7, settings));
                  }
                }
              }
              var tbody = $("<tbody/>").appendTo(table);
              i = isYear ? Math.ceil(year / 10) * 10 - 9 : isDay ? 1 - firstMonthDayColumn : 0;
              for (r = 0; r < rows; r++) {
                row = $("<tr/>").appendTo(tbody);
                if (isDay && settings.showWeekNumbers) {
                  cell = $("<th/>").appendTo(row);
                  cell.text(module.get.weekOfYear(year, month, i + 1 - settings.firstDayOfWeek));
                  cell.addClass(className.weekCell);
                }
                for (c = 0; c < textColumns; c++, i++) {
                  var cellDate = isYear ? new Date(i, month, 1, hour, minute) : isMonth ? new Date(year, i, 1, hour, minute) : isDay ? new Date(year, month, i, hour, minute) : isHour ? new Date(year, month, day, i) : new Date(year, month, day, hour, i * settings.minTimeGap);
                  var cellText = isYear ? i : isMonth ? settings.text.monthsShort[i] : isDay ? cellDate.getDate() : module.helper.dateFormat(formatter.cellTime, cellDate);
                  cell = $("<td/>").addClass(className.cell).appendTo(row);
                  cell.text(cellText);
                  cell.data(metadata.date, cellDate);
                  var adjacent = isDay && cellDate.getMonth() !== (month + 12) % 12;
                  var disabled = !settings.selectAdjacentDays && adjacent || !module.helper.isDateInRange(cellDate, mode) || settings.isDisabled(cellDate, mode) || module.helper.isDisabled(cellDate, mode) || !module.helper.isEnabled(cellDate, mode);
                  var eventDate;
                  if (disabled) {
                    var disabledDate = module.helper.findDayAsObject(cellDate, mode, settings.disabledDates);
                    if (disabledDate !== null && disabledDate[metadata.message]) {
                      cell.attr("data-tooltip", disabledDate[metadata.message]);
                      cell.attr("data-position", disabledDate[metadata.position] || tooltipPosition);
                      if (disabledDate[metadata.inverted] || isInverted && disabledDate[metadata.inverted] === void 0) {
                        cell.attr("data-inverted", "");
                      }
                      if (disabledDate[metadata.variation]) {
                        cell.attr("data-variation", disabledDate[metadata.variation]);
                      }
                    }
                    if (mode === "hour") {
                      var disabledHour = module.helper.findHourAsObject(cellDate, mode, settings.disabledHours);
                      if (disabledHour !== null && disabledHour[metadata.message]) {
                        cell.attr("data-tooltip", disabledHour[metadata.message]);
                        cell.attr("data-position", disabledHour[metadata.position] || tooltipPosition);
                        if (disabledHour[metadata.inverted] || isInverted && disabledHour[metadata.inverted] === void 0) {
                          cell.attr("data-inverted", "");
                        }
                        if (disabledHour[metadata.variation]) {
                          cell.attr("data-variation", disabledHour[metadata.variation]);
                        }
                      }
                    }
                  } else {
                    eventDate = module.helper.findDayAsObject(cellDate, mode, settings.eventDates);
                    if (eventDate !== null) {
                      cell.addClass(eventDate[metadata.class] || settings.eventClass);
                      if (eventDate[metadata.message]) {
                        cell.attr("data-tooltip", eventDate[metadata.message]);
                        cell.attr("data-position", eventDate[metadata.position] || tooltipPosition);
                        if (eventDate[metadata.inverted] || isInverted && eventDate[metadata.inverted] === void 0) {
                          cell.attr("data-inverted", "");
                        }
                        if (eventDate[metadata.variation]) {
                          cell.attr("data-variation", eventDate[metadata.variation]);
                        }
                      }
                    }
                  }
                  var active = module.helper.dateEqual(cellDate, date, mode);
                  var isToday = module.helper.dateEqual(cellDate, today, mode);
                  cell.toggleClass(className.adjacentCell, adjacent && !eventDate);
                  cell.toggleClass(className.disabledCell, disabled);
                  cell.toggleClass(className.activeCell, active && !(adjacent && disabled));
                  if (!isHour && !isMinute) {
                    cell.toggleClass(className.todayCell, !adjacent && isToday);
                  }
                  var cellOptions = {
                    mode,
                    adjacent,
                    disabled,
                    active,
                    today: isToday
                  };
                  formatter.cell(cell, cellDate, cellOptions);
                  if (module.helper.dateEqual(cellDate, focusDate, mode)) {
                    module.set.focusDate(cellDate, false, false);
                  }
                }
              }
              if (settings.today) {
                var todayRow = $("<tr/>").appendTo(tbody);
                var todayButton = $("<td/>").attr("colspan", "" + columns).addClass(className.today).appendTo(todayRow);
                todayButton.text(formatter.today(settings));
                todayButton.data(metadata.date, today);
              }
              module.update.focus(false, table);
              if (settings.inline) {
                module.refreshTooltips();
              }
            }
          }
        },
        update: {
          focus: function(updateRange, container) {
            container = container || $container;
            var mode = module.get.mode();
            var date = module.get.date();
            var focusDate = module.get.focusDate();
            var startDate = module.get.startDate();
            var endDate = module.get.endDate();
            var rangeDate = (updateRange ? focusDate : null) || date || (!isTouch ? focusDate : null);
            container.find("td").each(function() {
              var $cell = $(this);
              var cellDate = $cell.data(metadata.date);
              if (!cellDate) {
                return;
              }
              var disabled = $cell.hasClass(className.disabledCell);
              var active = $cell.hasClass(className.activeCell);
              var adjacent = $cell.hasClass(className.adjacentCell);
              var focused = module.helper.dateEqual(cellDate, focusDate, mode);
              var inRange = !rangeDate ? false : !!startDate && module.helper.isDateInRange(cellDate, mode, startDate, rangeDate) || !!endDate && module.helper.isDateInRange(cellDate, mode, rangeDate, endDate);
              $cell.toggleClass(className.focusCell, focused && (!isTouch || isTouchDown) && (!adjacent || settings.selectAdjacentDays && adjacent) && !disabled);
              if (module.helper.isTodayButton($cell)) {
                return;
              }
              $cell.toggleClass(className.rangeCell, inRange && !active && !disabled);
            });
          }
        },
        refresh: function() {
          module.create.calendar();
        },
        refreshTooltips: function() {
          var winWidth = $(window2).width();
          $container.find("td[data-position]").each(function() {
            var $cell = $(this);
            var tooltipWidth = window2.getComputedStyle($cell[0], "::after").width.replace(/[^\d.]/g, "");
            var tooltipPosition = $cell.attr("data-position");
            var calcPosition = winWidth - $cell.width() - (parseInt(tooltipWidth, 10) || 250) > $cell.offset().left ? "right" : "left";
            if (tooltipPosition.indexOf(calcPosition) === -1) {
              $cell.attr("data-position", tooltipPosition.replace(/(left|right)/, calcPosition));
            }
          });
        },
        bind: {
          events: function() {
            module.debug("Binding events");
            $container.on("mousedown" + eventNamespace, module.event.mousedown);
            $container.on("touchstart" + eventNamespace, module.event.mousedown);
            $container.on("mouseup" + eventNamespace, module.event.mouseup);
            $container.on("touchend" + eventNamespace, module.event.mouseup);
            $container.on("mouseover" + eventNamespace, module.event.mouseover);
            if ($input.length > 0) {
              $input.on("input" + eventNamespace, module.event.inputChange);
              $input.on("focus" + eventNamespace, module.event.inputFocus);
              $input.on("blur" + eventNamespace, module.event.inputBlur);
              $input.on("keydown" + eventNamespace, module.event.keydown);
            } else {
              $container.on("keydown" + eventNamespace, module.event.keydown);
            }
          }
        },
        unbind: {
          events: function() {
            module.debug("Unbinding events");
            $container.off(eventNamespace);
            if ($input.length > 0) {
              $input.off(eventNamespace);
            }
          }
        },
        event: {
          mouseover: function(event2) {
            var target = $(event2.target);
            var date = target.data(metadata.date);
            var mousedown = event2.buttons === 1;
            if (date) {
              module.set.focusDate(date, false, true, mousedown);
            }
          },
          mousedown: function(event2) {
            if ($input.length > 0) {
              event2.preventDefault();
            }
            isTouchDown = event2.type.indexOf("touch") >= 0;
            var target = $(event2.target);
            var date = target.data(metadata.date);
            if (date) {
              module.set.focusDate(date, false, true, true);
            }
          },
          mouseup: function(event2) {
            module.focus();
            event2.preventDefault();
            event2.stopPropagation();
            isTouchDown = false;
            var target = $(event2.target);
            if (target.hasClass("disabled")) {
              return;
            }
            var parent = target.parent();
            if (parent.data(metadata.date) || parent.data(metadata.focusDate) || parent.data(metadata.mode)) {
              target = parent;
            }
            var date = target.data(metadata.date);
            var focusDate = target.data(metadata.focusDate);
            var mode = target.data(metadata.mode);
            if (date && settings.onSelect.call(element2, date, module.get.mode()) !== false) {
              var forceSet = target.hasClass(className.today);
              module.selectDate(date, forceSet);
            } else if (focusDate) {
              module.set.focusDate(focusDate);
            } else if (mode) {
              module.set.mode(mode);
            }
          },
          keydown: function(event2) {
            var keyCode = event2.which;
            if (keyCode === 9) {
              module.popup("hide");
            }
            if (module.popup("is visible")) {
              var mode = module.get.mode();
              switch (keyCode) {
                case 37:
                case 38:
                case 39:
                case 40: {
                  var bigIncrement = mode === "day" ? 7 : mode === "hour" ? 4 : mode === "minute" ? timeGap.column : 3;
                  var increment = keyCode === 37 ? -1 : keyCode === 38 ? -bigIncrement : keyCode === 39 ? 1 : bigIncrement;
                  increment *= mode === "minute" ? settings.minTimeGap : 1;
                  var focusDate = module.get.focusDate() || module.get.date() || new Date();
                  var year = focusDate.getFullYear() + (mode === "year" ? increment : 0);
                  var month = focusDate.getMonth() + (mode === "month" ? increment : 0);
                  var day = focusDate.getDate() + (mode === "day" ? increment : 0);
                  var hour = focusDate.getHours() + (mode === "hour" ? increment : 0);
                  var minute = focusDate.getMinutes() + (mode === "minute" ? increment : 0);
                  var newFocusDate = new Date(year, month, day, hour, minute);
                  if (settings.type === "time") {
                    newFocusDate = module.helper.mergeDateTime(focusDate, newFocusDate);
                  }
                  if (module.helper.isDateInRange(newFocusDate, mode)) {
                    module.set.focusDate(newFocusDate);
                  }
                  break;
                }
                case 13: {
                  var date = module.get.focusDate();
                  if (date && !settings.isDisabled(date, mode) && !module.helper.isDisabled(date, mode) && module.helper.isEnabled(date, mode)) {
                    if (settings.onSelect.call(element2, date, module.get.mode()) !== false) {
                      module.selectDate(date);
                    }
                  }
                  event2.preventDefault();
                  event2.stopPropagation();
                  break;
                }
                case 27: {
                  module.popup("hide");
                  event2.stopPropagation();
                  break;
                }
              }
            }
            if (keyCode === 38 || keyCode === 40) {
              event2.preventDefault();
              module.popup("show");
            }
          },
          inputChange: function() {
            var val = $input.val();
            var date = parser.date(val, settings);
            module.set.date(date, false);
          },
          inputFocus: function() {
            $container.addClass(className.active);
          },
          inputBlur: function() {
            $container.removeClass(className.active);
            if (settings.formatInput) {
              var date = module.get.date();
              var text = module.helper.dateFormat(formatter[settings.type], date);
              $input.val(text);
            }
            if (selectionComplete) {
              module.trigger.change();
              selectionComplete = false;
            }
          },
          class: {
            mutation: function(mutations) {
              mutations.forEach(function(mutation) {
                if (mutation.attributeName === "class") {
                  module.check.disabled();
                }
              });
            }
          }
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            classObserver = new MutationObserver(module.event.class.mutation);
            module.debug("Setting up mutation observer", classObserver);
            module.observe.class();
          }
        },
        disconnect: {
          classObserver: function() {
            if ($input.length > 0 && classObserver) {
              classObserver.disconnect();
            }
          }
        },
        observe: {
          class: function() {
            if ($input.length > 0 && classObserver) {
              classObserver.observe($module[0], {
                attributes: true
              });
            }
          }
        },
        is: {
          disabled: function() {
            return $module.hasClass(className.disabled);
          }
        },
        check: {
          disabled: function() {
            $input.attr("tabindex", module.is.disabled() ? -1 : 0);
          }
        },
        get: {
          weekOfYear: function(weekYear, weekMonth, weekDay) {
            var ms1d = 24 * 3600 * 1e3, ms7d = 7 * ms1d, DC3 = Date.UTC(weekYear, weekMonth, weekDay + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = new Date(AWN * ms7d).getUTCFullYear();
            return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
          },
          formattedDate: function(format, date) {
            return module.helper.dateFormat(format || formatter[settings.type], date || module.get.date());
          },
          date: function() {
            return module.helper.sanitiseDate($module.data(metadata.date)) || null;
          },
          inputDate: function() {
            return $input.val();
          },
          focusDate: function() {
            return $module.data(metadata.focusDate) || null;
          },
          startDate: function() {
            var startModule = module.get.calendarModule(settings.startCalendar);
            return (startModule ? startModule.get.date() : $module.data(metadata.startDate)) || null;
          },
          endDate: function() {
            var endModule = module.get.calendarModule(settings.endCalendar);
            return (endModule ? endModule.get.date() : $module.data(metadata.endDate)) || null;
          },
          minDate: function() {
            return $module.data(metadata.minDate) || null;
          },
          maxDate: function() {
            return $module.data(metadata.maxDate) || null;
          },
          monthOffset: function() {
            return $module.data(metadata.monthOffset) || settings.monthOffset || 0;
          },
          mode: function() {
            var mode = $module.data(metadata.mode) || settings.startMode;
            return module.get.validatedMode(mode);
          },
          validatedMode: function(mode) {
            var validModes = module.get.validModes();
            if ($.inArray(mode, validModes) >= 0) {
              return mode;
            }
            return settings.type === "time" ? "hour" : settings.type === "month" ? "month" : settings.type === "year" ? "year" : "day";
          },
          type: function() {
            return $module.data(metadata.type) || settings.type;
          },
          validModes: function() {
            var validModes = [];
            if (settings.type !== "time") {
              if (!settings.disableYear || settings.type === "year") {
                validModes.push("year");
              }
              if (!(settings.disableMonth || settings.type === "year") || settings.type === "month") {
                validModes.push("month");
              }
              if (settings.type.indexOf("date") >= 0) {
                validModes.push("day");
              }
            }
            if (settings.type.indexOf("time") >= 0) {
              validModes.push("hour");
              if (!settings.disableMinute) {
                validModes.push("minute");
              }
            }
            return validModes;
          },
          isTouch: function() {
            try {
              document2.createEvent("TouchEvent");
              return true;
            } catch (e) {
              return false;
            }
          },
          calendarModule: function(selector2) {
            if (!selector2) {
              return null;
            }
            if (!(selector2 instanceof $)) {
              selector2 = $document.find(selector2).first();
            }
            return selector2.data(moduleNamespace);
          }
        },
        set: {
          date: function(date, updateInput, fireChange) {
            updateInput = updateInput !== false;
            fireChange = fireChange !== false;
            date = module.helper.sanitiseDate(date);
            date = module.helper.dateInRange(date);
            var mode = module.get.mode();
            var text = module.helper.dateFormat(formatter[settings.type], date);
            if (fireChange && settings.onBeforeChange.call(element2, date, text, mode) === false) {
              return false;
            }
            module.set.focusDate(date);
            if (settings.isDisabled(date, mode)) {
              return false;
            }
            var endDate = module.get.endDate();
            if (!!endDate && !!date && date > endDate) {
              module.set.endDate();
            }
            module.set.dataKeyValue(metadata.date, date);
            if (updateInput && $input.length > 0) {
              $input.val(text);
            }
            if (fireChange) {
              settings.onChange.call(element2, date, text, mode);
            }
          },
          startDate: function(date, refreshCalendar) {
            date = module.helper.sanitiseDate(date);
            var startModule = module.get.calendarModule(settings.startCalendar);
            if (startModule) {
              startModule.set.date(date);
            }
            module.set.dataKeyValue(metadata.startDate, date, refreshCalendar);
          },
          endDate: function(date, refreshCalendar) {
            date = module.helper.sanitiseDate(date);
            var endModule = module.get.calendarModule(settings.endCalendar);
            if (endModule) {
              endModule.set.date(date);
            }
            module.set.dataKeyValue(metadata.endDate, date, refreshCalendar);
          },
          focusDate: function(date, refreshCalendar, updateFocus, updateRange) {
            date = module.helper.sanitiseDate(date);
            date = module.helper.dateInRange(date);
            var isDay = module.get.mode() === "day";
            var oldFocusDate = module.get.focusDate();
            if (isDay && date && oldFocusDate) {
              var yearDelta = date.getFullYear() - oldFocusDate.getFullYear();
              var monthDelta = yearDelta * 12 + date.getMonth() - oldFocusDate.getMonth();
              if (monthDelta) {
                var monthOffset = module.get.monthOffset() - monthDelta;
                module.set.monthOffset(monthOffset, false);
              }
            }
            var changed = module.set.dataKeyValue(metadata.focusDate, date, !!date && refreshCalendar);
            updateFocus = updateFocus !== false && changed && refreshCalendar === false || focusDateUsedForRange != updateRange;
            focusDateUsedForRange = updateRange;
            if (updateFocus) {
              module.update.focus(updateRange);
            }
          },
          minDate: function(date) {
            date = module.helper.sanitiseDate(date);
            if (settings.maxDate !== null && settings.maxDate <= date) {
              module.verbose("Unable to set minDate variable bigger that maxDate variable", date, settings.maxDate);
            } else {
              module.setting("minDate", date);
              module.set.dataKeyValue(metadata.minDate, date);
            }
          },
          maxDate: function(date) {
            date = module.helper.sanitiseDate(date);
            if (settings.minDate !== null && settings.minDate >= date) {
              module.verbose("Unable to set maxDate variable lower that minDate variable", date, settings.minDate);
            } else {
              module.setting("maxDate", date);
              module.set.dataKeyValue(metadata.maxDate, date);
            }
          },
          monthOffset: function(monthOffset, refreshCalendar) {
            var multiMonth = Math.max(settings.multiMonth, 1);
            monthOffset = Math.max(1 - multiMonth, Math.min(0, monthOffset));
            module.set.dataKeyValue(metadata.monthOffset, monthOffset, refreshCalendar);
          },
          mode: function(mode, refreshCalendar) {
            module.set.dataKeyValue(metadata.mode, mode, refreshCalendar);
          },
          dataKeyValue: function(key, value, refreshCalendar) {
            var oldValue = $module.data(key);
            var equal = oldValue === value || oldValue <= value && oldValue >= value;
            if (value) {
              $module.data(key, value);
            } else {
              $module.removeData(key);
            }
            refreshCalendar = refreshCalendar !== false && !equal;
            if (refreshCalendar) {
              module.refresh();
            }
            return !equal;
          }
        },
        selectDate: function(date, forceSet) {
          module.verbose("New date selection", date);
          var mode = module.get.mode();
          var complete = forceSet || mode === "minute" || settings.disableMinute && mode === "hour" || settings.type === "date" && mode === "day" || settings.type === "month" && mode === "month" || settings.type === "year" && mode === "year";
          if (complete) {
            var canceled = module.set.date(date) === false;
            if (!canceled) {
              selectionComplete = true;
              if (settings.closable) {
                module.popup("hide");
                var endModule = module.get.calendarModule(settings.endCalendar);
                if (endModule) {
                  endModule.refresh();
                  if (endModule.setting("on") !== "focus") {
                    endModule.popup("show");
                  }
                  endModule.focus();
                }
              }
            }
          } else {
            var newMode = mode === "year" ? !settings.disableMonth ? "month" : "day" : mode === "month" ? "day" : mode === "day" ? "hour" : "minute";
            module.set.mode(newMode);
            if (mode === "hour" || mode === "day" && module.get.date()) {
              module.set.date(date, true, false);
            } else {
              module.set.focusDate(date);
            }
          }
        },
        changeDate: function(date) {
          module.set.date(date);
        },
        clear: function() {
          module.set.date();
        },
        popup: function() {
          return $activator.popup.apply($activator, arguments);
        },
        focus: function() {
          if ($input.length > 0) {
            $input.trigger("focus");
          } else {
            $container.trigger("focus");
          }
        },
        blur: function() {
          if ($input.length > 0) {
            $input.trigger("blur");
          } else {
            $container.trigger("blur");
          }
        },
        helper: {
          dateFormat: function(format, date) {
            if (!(date instanceof Date)) {
              return "";
            }
            if (typeof format === "function") {
              return format.call(module, date, settings);
            }
            var D = date.getDate(), M = date.getMonth(), Y = date.getFullYear(), d = date.getDay(), H = date.getHours(), m = date.getMinutes(), s = date.getSeconds(), w = module.get.weekOfYear(Y, M, D + 1 - settings.firstDayOfWeek), h = H % 12 || 12, a = H < 12 ? settings.text.am.toLowerCase() : settings.text.pm.toLowerCase(), tokens = {
              D,
              DD: ("0" + D).slice(-2),
              M: M + 1,
              MM: ("0" + (M + 1)).slice(-2),
              MMM: settings.text.monthsShort[M],
              MMMM: settings.text.months[M],
              Y,
              YY: String(Y).slice(2),
              YYYY: Y,
              d,
              dd: settings.text.dayNamesShort[d].slice(0, 2),
              ddd: settings.text.dayNamesShort[d],
              dddd: settings.text.dayNames[d],
              h,
              hh: ("0" + h).slice(-2),
              H,
              HH: ("0" + H).slice(-2),
              m,
              mm: ("0" + m).slice(-2),
              s,
              ss: ("0" + s).slice(-2),
              a,
              A: a.toUpperCase(),
              S: ["th", "st", "nd", "rd"][D % 10 > 3 ? 0 : D % 100 - D % 10 === 10 ? 0 : D % 10],
              w,
              ww: ("0" + w).slice(-2)
            };
            return format.replace(settings.regExp.token, function(match) {
              if (match in tokens) {
                return tokens[match];
              }
              return match.slice(1, -1);
            });
          },
          isDisabled: function(date, mode) {
            return (mode === "day" || mode === "month" || mode === "year" || mode === "hour") && (mode === "day" && settings.disabledDaysOfWeek.indexOf(date.getDay()) !== -1 || settings.disabledDates.some(function(d) {
              var blocked = false;
              if (typeof d === "string") {
                d = module.helper.sanitiseDate(d);
              }
              if (d instanceof Date) {
                blocked = module.helper.dateEqual(date, d, mode);
              } else if (d !== null && typeof d === "object") {
                if (d[metadata.year]) {
                  if (typeof d[metadata.year] === "number") {
                    blocked = date.getFullYear() === d[metadata.year];
                  } else if (Array.isArray(d[metadata.year])) {
                    blocked = d[metadata.year].indexOf(date.getFullYear()) > -1;
                  }
                } else if (d[metadata.month]) {
                  if (typeof d[metadata.month] === "number") {
                    blocked = date.getMonth() === d[metadata.month];
                  } else if (Array.isArray(d[metadata.month])) {
                    blocked = d[metadata.month].indexOf(date.getMonth()) > -1;
                  } else if (d[metadata.month] instanceof Date) {
                    var sdate = module.helper.sanitiseDate(d[metadata.month]);
                    blocked = date.getMonth() === sdate.getMonth() && date.getFullYear() === sdate.getFullYear();
                  }
                } else if (d[metadata.date] && mode === "day") {
                  if (d[metadata.date] instanceof Date) {
                    blocked = module.helper.dateEqual(date, module.helper.sanitiseDate(d[metadata.date]), mode);
                  } else if (Array.isArray(d[metadata.date])) {
                    blocked = d[metadata.date].some(function(idate) {
                      return module.helper.dateEqual(date, idate, mode);
                    });
                  }
                }
              }
              return blocked;
            }) || mode === "hour" && settings.disabledHours.some(function(d) {
              var blocked = false;
              if (typeof d === "string") {
                d = module.helper.sanitiseDate(d);
              }
              if (d instanceof Date) {
                blocked = module.helper.dateEqual(date, d, mode);
              } else if (typeof d === "number") {
                blocked = date.getHours() === d;
              } else if (d !== null && typeof d === "object") {
                if (d[metadata.date]) {
                  if (d[metadata.date] instanceof Date) {
                    blocked = module.helper.dateEqual(date, module.helper.sanitiseDate(d[metadata.date]));
                  } else if (Array.isArray(d[metadata.date])) {
                    blocked = d[metadata.date].some(function(idate) {
                      return module.helper.dateEqual(date, idate, mode);
                    });
                  }
                }
                if (d[metadata.days]) {
                  if (typeof d[metadata.days] === "number") {
                    blocked = date.getDay() === d[metadata.days];
                  } else if (Array.isArray(d[metadata.days])) {
                    blocked = d[metadata.days].indexOf(date.getDay()) > -1;
                  }
                }
                if (d[metadata.hours]) {
                  if (typeof d[metadata.hours] === "number") {
                    blocked = blocked && date.getHours() === d[metadata.hours];
                  } else if (Array.isArray(d[metadata.hours])) {
                    blocked = blocked && d[metadata.hours].indexOf(date.getHours()) > -1;
                  }
                }
              }
              return blocked;
            }));
          },
          isEnabled: function(date, mode) {
            if (mode === "day") {
              return settings.enabledDates.length === 0 || settings.enabledDates.some(function(d) {
                var enabled = false;
                if (typeof d === "string") {
                  d = module.helper.sanitiseDate(d);
                }
                if (d instanceof Date) {
                  enabled = module.helper.dateEqual(date, d, mode);
                } else if (d !== null && typeof d === "object" && d[metadata.date]) {
                  enabled = module.helper.dateEqual(date, module.helper.sanitiseDate(d[metadata.date]), mode);
                }
                return enabled;
              });
            }
            return true;
          },
          findDayAsObject: function(date, mode, dates) {
            if (mode === "day" || mode === "month" || mode === "year") {
              var d;
              for (var i = 0; i < dates.length; i++) {
                d = dates[i];
                if (typeof d === "string") {
                  d = module.helper.sanitiseDate(d);
                }
                if (d instanceof Date && module.helper.dateEqual(date, d, mode)) {
                  var dateObject = {};
                  dateObject[metadata.date] = d;
                  return dateObject;
                }
                if (d !== null && typeof d === "object") {
                  if (d[metadata.year]) {
                    if (typeof d[metadata.year] === "number" && date.getFullYear() === d[metadata.year]) {
                      return d;
                    }
                    if (Array.isArray(d[metadata.year])) {
                      if (d[metadata.year].indexOf(date.getFullYear()) > -1) {
                        return d;
                      }
                    }
                  } else if (d[metadata.month]) {
                    if (typeof d[metadata.month] === "number" && date.getMonth() === d[metadata.month]) {
                      return d;
                    }
                    if (Array.isArray(d[metadata.month])) {
                      if (d[metadata.month].indexOf(date.getMonth()) > -1) {
                        return d;
                      }
                    } else if (d[metadata.month] instanceof Date) {
                      var sdate = module.helper.sanitiseDate(d[metadata.month]);
                      if (date.getMonth() === sdate.getMonth() && date.getFullYear() === sdate.getFullYear()) {
                        return d;
                      }
                    }
                  } else if (d[metadata.date] && mode === "day") {
                    if (d[metadata.date] instanceof Date && module.helper.dateEqual(date, module.helper.sanitiseDate(d[metadata.date]), mode)) {
                      return d;
                    }
                    if (Array.isArray(d[metadata.date])) {
                      if (d[metadata.date].some(function(idate) {
                        return module.helper.dateEqual(date, idate, mode);
                      })) {
                        return d;
                      }
                    }
                  }
                }
              }
            }
            return null;
          },
          findHourAsObject: function(date, mode, hours) {
            if (mode === "hour") {
              var d;
              var hourCheck = function(date2, d2) {
                if (d2[metadata.hours]) {
                  if (typeof d2[metadata.hours] === "number" && date2.getHours() === d2[metadata.hours]) {
                    return d2;
                  }
                  if (Array.isArray(d2[metadata.hours])) {
                    if (d2[metadata.hours].indexOf(date2.getHours()) > -1) {
                      return d2;
                    }
                  }
                }
              };
              for (var i = 0; i < hours.length; i++) {
                d = hours[i];
                if (typeof d === "number" && date.getHours() === d) {
                  return null;
                }
                if (d !== null && typeof d === "object") {
                  if (d[metadata.days] && hourCheck(date, d)) {
                    if (typeof d[metadata.days] === "number" && date.getDay() === d[metadata.days]) {
                      return d;
                    }
                    if (Array.isArray(d[metadata.days])) {
                      if (d[metadata.days].indexOf(date.getDay()) > -1) {
                        return d;
                      }
                    }
                  } else if (d[metadata.date] && hourCheck(date, d)) {
                    if (d[metadata.date] instanceof Date && module.helper.dateEqual(date, module.helper.sanitiseDate(d[metadata.date]))) {
                      return d;
                    }
                    if (Array.isArray(d[metadata.date])) {
                      if (d[metadata.date].some(function(idate) {
                        return module.helper.dateEqual(date, idate, mode);
                      })) {
                        return d;
                      }
                    }
                  } else if (hourCheck(date, d)) {
                    return d;
                  }
                }
              }
            }
            return null;
          },
          sanitiseDate: function(date) {
            if (!(date instanceof Date)) {
              date = parser.date("" + date, settings);
            }
            if (!date || isNaN(date.getTime())) {
              return null;
            }
            return date;
          },
          dateDiff: function(date1, date2, mode) {
            if (!mode) {
              mode = "day";
            }
            var isTimeOnly = settings.type === "time";
            var isYear = mode === "year";
            var isYearOrMonth = isYear || mode === "month";
            var isMinute = mode === "minute";
            var isHourOrMinute = isMinute || mode === "hour";
            date1 = new Date(
              isTimeOnly ? 2e3 : date1.getFullYear(),
              isTimeOnly ? 0 : isYear ? 0 : date1.getMonth(),
              isTimeOnly ? 1 : isYearOrMonth ? 1 : date1.getDate(),
              !isHourOrMinute ? 0 : date1.getHours(),
              !isMinute ? 0 : settings.minTimeGap * Math.floor(date1.getMinutes() / settings.minTimeGap)
            );
            date2 = new Date(
              isTimeOnly ? 2e3 : date2.getFullYear(),
              isTimeOnly ? 0 : isYear ? 0 : date2.getMonth(),
              isTimeOnly ? 1 : isYearOrMonth ? 1 : date2.getDate(),
              !isHourOrMinute ? 0 : date2.getHours(),
              !isMinute ? 0 : settings.minTimeGap * Math.floor(date2.getMinutes() / settings.minTimeGap)
            );
            return date2.getTime() - date1.getTime();
          },
          dateEqual: function(date1, date2, mode) {
            return !!date1 && !!date2 && module.helper.dateDiff(date1, date2, mode) === 0;
          },
          isDateInRange: function(date, mode, minDate, maxDate) {
            if (!minDate && !maxDate) {
              var startDate = module.get.startDate();
              minDate = startDate && settings.minDate ? new Date(Math.max(startDate, settings.minDate)) : startDate || settings.minDate;
              maxDate = settings.maxDate;
            }
            minDate = minDate && new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate(), minDate.getHours(), settings.minTimeGap * Math.ceil(minDate.getMinutes() / settings.minTimeGap));
            return !(!date || minDate && module.helper.dateDiff(date, minDate, mode) > 0 || maxDate && module.helper.dateDiff(maxDate, date, mode) > 0);
          },
          dateInRange: function(date, minDate, maxDate) {
            if (!minDate && !maxDate) {
              var startDate = module.get.startDate();
              minDate = startDate && settings.minDate ? new Date(Math.max(startDate, settings.minDate)) : startDate || settings.minDate;
              maxDate = settings.maxDate;
            }
            minDate = minDate && new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate(), minDate.getHours(), settings.minTimeGap * Math.ceil(minDate.getMinutes() / settings.minTimeGap));
            var isTimeOnly = settings.type === "time";
            return !date ? date : minDate && module.helper.dateDiff(date, minDate, "minute") > 0 ? isTimeOnly ? module.helper.mergeDateTime(date, minDate) : minDate : maxDate && module.helper.dateDiff(maxDate, date, "minute") > 0 ? isTimeOnly ? module.helper.mergeDateTime(date, maxDate) : maxDate : date;
          },
          mergeDateTime: function(date, time2) {
            return !date || !time2 ? time2 : new Date(date.getFullYear(), date.getMonth(), date.getDate(), time2.getHours(), time2.getMinutes());
          },
          isTodayButton: function(element3) {
            return element3.text() === settings.text.today;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.calendar.settings = {
    name: "Calendar",
    namespace: "calendar",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    context: false,
    type: "datetime",
    // picker type, can be 'datetime', 'date', 'time', 'month', or 'year'
    firstDayOfWeek: 0,
    // day for first day column (0 = Sunday)
    constantHeight: true,
    // add rows to shorter months to keep day calendar height consistent (6 rows)
    today: false,
    // show a 'today/now' button at the bottom of the calendar
    closable: true,
    // close the popup after selecting a date/time
    monthFirst: true,
    // month before day when parsing date from text
    touchReadonly: true,
    // set input to readonly on touch devices
    inline: false,
    // create the calendar inline instead of inside a popup
    on: null,
    // when to show the popup (defaults to 'focus' for input, 'click' for others)
    initialDate: null,
    // date to display initially when no date is selected (null = now)
    startMode: false,
    // display mode to start in, can be 'year', 'month', 'day', 'hour', 'minute' (false = 'day')
    minDate: null,
    // minimum date/time that can be selected, dates/times before are disabled
    maxDate: null,
    // maximum date/time that can be selected, dates/times after are disabled
    disableYear: false,
    // disable year selection mode
    disableMonth: false,
    // disable month selection mode
    disableMinute: false,
    // disable minute selection mode
    formatInput: true,
    // format the input text upon input blur and module creation
    startCalendar: null,
    // jquery object or selector for another calendar that represents the start date of a date range
    endCalendar: null,
    // jquery object or selector for another calendar that represents the end date of a date range
    multiMonth: 1,
    // show multiple months when in 'day' mode
    monthOffset: 0,
    // position current month by offset when multimonth > 1
    minTimeGap: 5,
    showWeekNumbers: false,
    // show Number of Week at the very first column of a dayView
    disabledHours: [],
    // specific hour(s) which won't be selectable and contain additional information.
    disabledDates: [],
    // specific day(s) which won't be selectable and contain additional information.
    disabledDaysOfWeek: [],
    // day(s) which won't be selectable(s) (0 = Sunday)
    enabledDates: [],
    // specific day(s) which will be selectable, all other days will be disabled
    eventDates: [],
    // specific day(s) which will be shown in a different color and using tooltips
    centuryBreak: 60,
    // starting short year until 99 where it will be assumed to belong to the last century
    currentCentury: 2e3,
    // century to be added to 2-digit years (00 to {centuryBreak}-1)
    selectAdjacentDays: false,
    // The calendar can show dates from adjacent month. These adjacent month dates can also be made selectable.
    // popup options ('popup', 'on', 'hoverable', and show/hide callbacks are overridden)
    popupOptions: {
      position: "bottom left",
      lastResort: "bottom left",
      prefer: "opposite",
      observeChanges: false,
      hideOnScroll: false
    },
    text: {
      days: ["S", "M", "T", "W", "T", "F", "S"],
      dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      today: "Today",
      now: "Now",
      am: "AM",
      pm: "PM",
      weekNo: "Week"
    },
    formatter: {
      yearHeader: function(date, settings) {
        var decadeYear = Math.ceil(date.getFullYear() / 10) * 10;
        return decadeYear - 9 + " - " + (decadeYear + 2);
      },
      monthHeader: "YYYY",
      dayHeader: "MMMM YYYY",
      hourHeader: "MMMM D, YYYY",
      minuteHeader: "MMMM D, YYYY",
      dayColumnHeader: function(day, settings) {
        return settings.text.days[day];
      },
      datetime: "MMMM D, YYYY h:mm A",
      date: "MMMM D, YYYY",
      time: "h:mm A",
      cellTime: "h:mm A",
      month: "MMMM YYYY",
      year: "YYYY",
      today: function(settings) {
        return settings.type === "date" ? settings.text.today : settings.text.now;
      },
      cell: function(cell, date, cellOptions) {
      }
    },
    parser: {
      date: function(text, settings) {
        if (text instanceof Date) {
          return text;
        }
        if (!text) {
          return null;
        }
        text = String(text).trim().replace(/([./:-])\s+/g, "$1").replace(/\s+([./:-])/g, "$1").replace(/\s+/g, " ");
        if (text.length === 0) {
          return null;
        }
        if (/^\d{4}(?:[./-]\d{1,2}){2}$/.test(text)) {
          text = text.replace(/[./-]/g, "/") + " 00:00:00";
        }
        text = settings.monthFirst || !/^\d{1,2}[./-]/.test(text) ? text : text.replace(/[./-]/g, "/").replace(/(\d+)\/(\d+)/, "$2/$1");
        var textDate = new Date(text);
        var numberOnly = text.match(/^\d+$/) !== null;
        if (!numberOnly && !isNaN(textDate.getDate())) {
          return textDate;
        }
        text = text.toLowerCase();
        var i, j, k;
        var minute = -1, hour = -1, day = -1, month = -1, year = -1;
        var isAm;
        var isTimeOnly = settings.type === "time";
        var isDateOnly = settings.type.indexOf("time") < 0;
        var words = text.split(settings.regExp.dateWords), word;
        var numbers = text.split(settings.regExp.dateNumbers), number;
        var parts;
        var monthString;
        if (!isDateOnly) {
          isAm = $.inArray(settings.text.am.toLowerCase(), words) >= 0 ? true : $.inArray(settings.text.pm.toLowerCase(), words) >= 0 ? false : void 0;
          for (i = 0; i < numbers.length; i++) {
            number = numbers[i];
            if (number.indexOf(":") >= 0) {
              if (hour < 0 || minute < 0) {
                parts = number.split(":");
                for (k = 0; k < Math.min(2, parts.length); k++) {
                  j = parseInt(parts[k], 10);
                  if (isNaN(j)) {
                    j = 0;
                  }
                  if (k === 0) {
                    hour = j % 24;
                  } else {
                    minute = j % 60;
                  }
                }
              }
              numbers.splice(i, 1);
            }
          }
        }
        if (!isTimeOnly) {
          for (i = 0; i < words.length; i++) {
            word = words[i];
            if (word.length <= 0) {
              continue;
            }
            for (j = 0; j < settings.text.months.length; j++) {
              monthString = settings.text.months[j];
              monthString = monthString.slice(0, word.length).toLowerCase();
              if (monthString === word) {
                month = j + 1;
                break;
              }
            }
            if (month >= 0) {
              break;
            }
          }
          for (i = 0; i < numbers.length; i++) {
            j = parseInt(numbers[i], 10);
            if (isNaN(j)) {
              continue;
            }
            if (j >= settings.centuryBreak && i === numbers.length - 1) {
              if (j <= 99) {
                j += settings.currentCentury - 100;
              }
              year = j;
              numbers.splice(i, 1);
              break;
            }
          }
          if (month < 0) {
            for (i = 0; i < numbers.length; i++) {
              k = i > 1 || settings.monthFirst ? i : i === 1 ? 0 : 1;
              j = parseInt(numbers[k], 10);
              if (isNaN(j)) {
                continue;
              }
              if (j >= 1 && j <= 12) {
                month = j;
                numbers.splice(k, 1);
                break;
              }
            }
          }
          for (i = 0; i < numbers.length; i++) {
            j = parseInt(numbers[i], 10);
            if (isNaN(j)) {
              continue;
            }
            if (j >= 1 && j <= 31) {
              day = j;
              numbers.splice(i, 1);
              break;
            }
          }
          if (year < 0) {
            for (i = numbers.length - 1; i >= 0; i--) {
              j = parseInt(numbers[i], 10);
              if (isNaN(j)) {
                continue;
              }
              if (j <= 99) {
                j += settings.currentCentury;
              }
              year = j;
              numbers.splice(i, 1);
              break;
            }
          }
        }
        if (!isDateOnly) {
          if (hour < 0) {
            for (i = 0; i < numbers.length; i++) {
              j = parseInt(numbers[i], 10);
              if (isNaN(j)) {
                continue;
              }
              if (j >= 0 && j <= 23) {
                hour = j;
                numbers.splice(i, 1);
                break;
              }
            }
          }
          if (minute < 0) {
            for (i = 0; i < numbers.length; i++) {
              j = parseInt(numbers[i], 10);
              if (isNaN(j)) {
                continue;
              }
              if (j >= 0 && j <= 59) {
                minute = j;
                numbers.splice(i, 1);
                break;
              }
            }
          }
        }
        if (minute < 0 && hour < 0 && day < 0 && month < 0 && year < 0) {
          return null;
        }
        if (minute < 0) {
          minute = 0;
        }
        if (hour < 0) {
          hour = 0;
        }
        if (day < 0) {
          day = 1;
        }
        if (month < 0) {
          month = 1;
        }
        if (year < 0) {
          year = new Date().getFullYear();
        }
        if (isAm !== void 0) {
          if (isAm) {
            if (hour === 12) {
              hour = 0;
            }
          } else if (hour < 12) {
            hour += 12;
          }
        }
        var date = new Date(year, month - 1, day, hour, minute);
        if (date.getMonth() !== month - 1 || date.getFullYear() !== year) {
          date = new Date(year, month, 0, hour, minute);
        }
        return isNaN(date.getTime()) ? null : date;
      }
    },
    // callback before date is changed, return false to cancel the change
    onBeforeChange: function(date, text, mode) {
      return true;
    },
    // callback when date changes
    onChange: function(date, text, mode) {
    },
    // callback before show animation, return false to prevent show
    onShow: function() {
    },
    // callback after show animation
    onVisible: function() {
    },
    // callback before hide animation, return false to prevent hide
    onHide: function() {
    },
    // callback after hide animation
    onHidden: function() {
    },
    // callback before item is selected, return false to prevent selection
    onSelect: function(date, mode) {
    },
    // is the given date disabled?
    isDisabled: function(date, mode) {
      return false;
    },
    selector: {
      popup: ".ui.popup",
      input: "input",
      activator: "input",
      append: ".inline.field,.inline.fields"
    },
    regExp: {
      dateWords: /[^A-Za-z\u00C0-\u024F]+/g,
      dateNumbers: /[^\d:]+/g,
      token: /d{1,4}|D{1,2}|M{1,4}|YY(?:YY)?|([Hhmsw])\1?|[ASYa]|"[^"]*"|'[^']*'/g
    },
    error: {
      popup: "UI Popup, a required component is not included in this page",
      method: "The method you called is not defined."
    },
    className: {
      calendar: "calendar",
      active: "active",
      popup: "ui popup",
      grid: "ui equal width grid",
      column: "column",
      table: "ui celled center aligned unstackable table",
      inverted: "inverted",
      prev: "prev link",
      next: "next link",
      prevIcon: "chevron left icon",
      nextIcon: "chevron right icon",
      link: "link",
      cell: "link",
      disabledCell: "disabled",
      weekCell: "disabled",
      adjacentCell: "adjacent",
      activeCell: "active",
      rangeCell: "range",
      focusCell: "focus",
      todayCell: "today",
      today: "today link",
      disabled: "disabled"
    },
    metadata: {
      date: "date",
      focusDate: "focusDate",
      startDate: "startDate",
      endDate: "endDate",
      minDate: "minDate",
      maxDate: "maxDate",
      mode: "mode",
      type: "type",
      monthOffset: "monthOffset",
      message: "message",
      class: "class",
      inverted: "inverted",
      variation: "variation",
      position: "position",
      month: "month",
      year: "year",
      hours: "hours",
      days: "days"
    },
    eventClass: "blue"
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.checkbox = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.extend(true, {}, $.fn.checkbox.settings, parameters), className = settings.className, namespace = settings.namespace, selector = settings.selector, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $label = $(this).children(selector.label), $input = $(this).children(selector.input), input = $input[0], initialLoad = false, shortcutPressed = false, instance68 = $module.data(moduleNamespace), observer, element2 = this, module;
      module = {
        initialize: function() {
          module.verbose("Initializing checkbox", settings);
          module.create.label();
          module.bind.events();
          module.set.tabbable();
          module.hide.input();
          module.observeChanges();
          module.instantiate();
          module.setup();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying module");
          module.unbind.events();
          module.show.input();
          $module.removeData(moduleNamespace);
        },
        fix: {
          reference: function() {
            if ($module.is(selector.input)) {
              module.debug("Behavior called on <input> adjusting invoked element");
              $module = $module.closest(selector.checkbox);
              module.refresh();
            }
          }
        },
        setup: function() {
          module.set.initialLoad();
          if (module.is.indeterminate()) {
            module.debug("Initial value is indeterminate");
            module.indeterminate();
          } else if (module.is.checked()) {
            module.debug("Initial value is checked");
            module.check();
          } else {
            module.debug("Initial value is unchecked");
            module.uncheck();
          }
          module.remove.initialLoad();
        },
        refresh: function() {
          $label = $module.children(selector.label);
          $input = $module.children(selector.input);
          input = $input[0];
        },
        hide: {
          input: function() {
            module.verbose("Modifying <input> z-index to be unselectable");
            $input.addClass(className.hidden);
          }
        },
        show: {
          input: function() {
            module.verbose("Modifying <input> z-index to be selectable");
            $input.removeClass(className.hidden);
          }
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            observer = new MutationObserver(function(mutations) {
              module.debug("DOM tree modified, updating selector cache");
              module.refresh();
            });
            observer.observe(element2, {
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", observer);
          }
        },
        attachEvents: function(selector2, event2) {
          var $element = $(selector2);
          event2 = isFunction(module[event2]) ? module[event2] : module.toggle;
          if ($element.length > 0) {
            module.debug("Attaching checkbox events to element", selector2, event2);
            $element.on("click" + eventNamespace, event2);
          } else {
            module.error(error.notFound);
          }
        },
        preventDefaultOnInputTarget: function() {
          if (event !== void 0 && event !== null && $(event.target).is(selector.input)) {
            module.verbose("Preventing default check action after manual check action");
            event.preventDefault();
          }
        },
        event: {
          change: function(event2) {
            if (!module.should.ignoreCallbacks()) {
              settings.onChange.call(input);
            }
          },
          click: function(event2) {
            var $target = $(event2.target);
            if ($target.is(selector.input)) {
              module.verbose("Using default check action on initialized checkbox");
              return;
            }
            if ($target.is(selector.link)) {
              module.debug("Clicking link inside checkbox, skipping toggle");
              return;
            }
            module.toggle();
            $input.trigger("focus");
            event2.preventDefault();
          },
          keydown: function(event2) {
            var key = event2.which, keyCode = {
              enter: 13,
              space: 32,
              escape: 27,
              left: 37,
              up: 38,
              right: 39,
              down: 40
            };
            var r = module.get.radios(), rIndex = r.index($module), rLen = r.length, checkIndex = false;
            if (key === keyCode.left || key === keyCode.up) {
              checkIndex = (rIndex === 0 ? rLen : rIndex) - 1;
            } else if (key === keyCode.right || key === keyCode.down) {
              checkIndex = rIndex === rLen - 1 ? 0 : rIndex + 1;
            }
            if (!module.should.ignoreCallbacks() && checkIndex !== false) {
              if (settings.beforeUnchecked.apply(input) === false) {
                module.verbose("Option not allowed to be unchecked, cancelling key navigation");
                return false;
              }
              if (settings.beforeChecked.apply($(r[checkIndex]).children(selector.input)[0]) === false) {
                module.verbose("Next option should not allow check, cancelling key navigation");
                return false;
              }
            }
            shortcutPressed = false;
            if (key === keyCode.escape) {
              module.verbose("Escape key pressed blurring field");
              $input.trigger("blur");
              shortcutPressed = true;
              event2.stopPropagation();
            } else if (!event2.ctrlKey && module.can.change()) {
              if (key === keyCode.space || key === keyCode.enter && settings.enableEnterKey) {
                module.verbose("Enter/space key pressed, toggling checkbox");
                module.toggle();
                shortcutPressed = true;
              } else if ($module.is(".toggle, .slider") && !module.is.radio()) {
                if (key === keyCode.left && module.is.checked()) {
                  module.uncheck();
                  shortcutPressed = true;
                } else if (key === keyCode.right && module.is.unchecked()) {
                  module.check();
                  shortcutPressed = true;
                }
              }
            }
          },
          keyup: function(event2) {
            if (shortcutPressed) {
              event2.preventDefault();
            }
          }
        },
        check: function() {
          if (!module.should.allowCheck()) {
            return;
          }
          module.debug("Checking checkbox", $input);
          module.set.checked();
          if (!module.should.ignoreCallbacks()) {
            settings.onChecked.call(input);
            module.trigger.change();
          }
          module.preventDefaultOnInputTarget();
        },
        uncheck: function() {
          if (!module.should.allowUncheck()) {
            return;
          }
          module.debug("Unchecking checkbox");
          module.set.unchecked();
          if (!module.should.ignoreCallbacks()) {
            settings.onUnchecked.call(input);
            module.trigger.change();
          }
          module.preventDefaultOnInputTarget();
        },
        indeterminate: function() {
          if (module.should.allowIndeterminate()) {
            module.debug("Checkbox is already indeterminate");
            return;
          }
          module.debug("Making checkbox indeterminate");
          module.set.indeterminate();
          if (!module.should.ignoreCallbacks()) {
            settings.onIndeterminate.call(input);
            module.trigger.change();
          }
        },
        determinate: function() {
          if (module.should.allowDeterminate()) {
            module.debug("Checkbox is already determinate");
            return;
          }
          module.debug("Making checkbox determinate");
          module.set.determinate();
          if (!module.should.ignoreCallbacks()) {
            settings.onDeterminate.call(input);
            module.trigger.change();
          }
        },
        enable: function() {
          if (module.is.enabled()) {
            module.debug("Checkbox is already enabled");
            return;
          }
          module.debug("Enabling checkbox");
          module.set.enabled();
          if (!module.should.ignoreCallbacks()) {
            settings.onEnable.call(input);
            settings.onEnabled.call(input);
          }
        },
        disable: function() {
          if (module.is.disabled()) {
            module.debug("Checkbox is already disabled");
            return;
          }
          module.debug("Disabling checkbox");
          module.set.disabled();
          if (!module.should.ignoreCallbacks()) {
            settings.onDisable.call(input);
            settings.onDisabled.call(input);
          }
        },
        get: {
          radios: function() {
            var name = module.get.name();
            return $('input[name="' + name + '"]').closest(selector.checkbox);
          },
          otherRadios: function() {
            return module.get.radios().not($module);
          },
          name: function() {
            return $input.attr("name");
          }
        },
        is: {
          initialLoad: function() {
            return initialLoad;
          },
          radio: function() {
            return $input.hasClass(className.radio) || $input.attr("type") === "radio";
          },
          indeterminate: function() {
            return $input.prop("indeterminate") !== void 0 && $input.prop("indeterminate");
          },
          checked: function() {
            return $input.prop("checked") !== void 0 && $input.prop("checked");
          },
          disabled: function() {
            return $input.prop("disabled") !== void 0 && $input.prop("disabled");
          },
          enabled: function() {
            return !module.is.disabled();
          },
          determinate: function() {
            return !module.is.indeterminate();
          },
          unchecked: function() {
            return !module.is.checked();
          }
        },
        should: {
          allowCheck: function() {
            if (module.is.determinate() && module.is.checked() && !module.is.initialLoad()) {
              module.debug("Should not allow check, checkbox is already checked");
              return false;
            }
            if (!module.should.ignoreCallbacks() && settings.beforeChecked.apply(input) === false) {
              module.debug("Should not allow check, beforeChecked cancelled");
              return false;
            }
            return true;
          },
          allowUncheck: function() {
            if (module.is.determinate() && module.is.unchecked() && !module.is.initialLoad()) {
              module.debug("Should not allow uncheck, checkbox is already unchecked");
              return false;
            }
            if (!module.should.ignoreCallbacks() && settings.beforeUnchecked.apply(input) === false) {
              module.debug("Should not allow uncheck, beforeUnchecked cancelled");
              return false;
            }
            return true;
          },
          allowIndeterminate: function() {
            if (module.is.indeterminate() && !module.is.initialLoad()) {
              module.debug("Should not allow indeterminate, checkbox is already indeterminate");
              return false;
            }
            if (!module.should.ignoreCallbacks() && settings.beforeIndeterminate.apply(input) === false) {
              module.debug("Should not allow indeterminate, beforeIndeterminate cancelled");
              return false;
            }
            return true;
          },
          allowDeterminate: function() {
            if (module.is.determinate() && !module.is.initialLoad()) {
              module.debug("Should not allow determinate, checkbox is already determinate");
              return false;
            }
            if (!module.should.ignoreCallbacks() && settings.beforeDeterminate.apply(input) === false) {
              module.debug("Should not allow determinate, beforeDeterminate cancelled");
              return false;
            }
            return true;
          },
          ignoreCallbacks: function() {
            return initialLoad && !settings.fireOnInit;
          }
        },
        can: {
          change: function() {
            return !($module.hasClass(className.disabled) || $module.hasClass(className.readOnly) || $input.prop("disabled") || $input.prop("readonly"));
          },
          uncheck: function() {
            return typeof settings.uncheckable === "boolean" ? settings.uncheckable : !module.is.radio();
          }
        },
        set: {
          initialLoad: function() {
            initialLoad = true;
          },
          checked: function() {
            module.verbose("Setting class to checked");
            $module.removeClass(className.indeterminate).addClass(className.checked);
            if (module.is.radio()) {
              module.uncheckOthers();
            }
            if (!module.is.indeterminate() && module.is.checked()) {
              module.debug("Input is already checked, skipping input property change");
              return;
            }
            module.verbose("Setting state to checked", input);
            $input.prop("indeterminate", false).prop("checked", true);
          },
          unchecked: function() {
            module.verbose("Removing checked class");
            $module.removeClass(className.indeterminate).removeClass(className.checked);
            if (!module.is.indeterminate() && module.is.unchecked()) {
              module.debug("Input is already unchecked");
              return;
            }
            module.debug("Setting state to unchecked");
            $input.prop("indeterminate", false).prop("checked", false);
          },
          indeterminate: function() {
            module.verbose("Setting class to indeterminate");
            $module.addClass(className.indeterminate);
            if (module.is.indeterminate()) {
              module.debug("Input is already indeterminate, skipping input property change");
              return;
            }
            module.debug("Setting state to indeterminate");
            $input.prop("indeterminate", true);
          },
          determinate: function() {
            module.verbose("Removing indeterminate class");
            $module.removeClass(className.indeterminate);
            if (module.is.determinate()) {
              module.debug("Input is already determinate, skipping input property change");
              return;
            }
            module.debug("Setting state to determinate");
            $input.prop("indeterminate", false);
          },
          disabled: function() {
            module.verbose("Setting class to disabled");
            $module.addClass(className.disabled);
            if (module.is.disabled()) {
              module.debug("Input is already disabled, skipping input property change");
              return;
            }
            module.debug("Setting state to disabled");
            $input.prop("disabled", "disabled");
          },
          enabled: function() {
            module.verbose("Removing disabled class");
            $module.removeClass(className.disabled);
            if (module.is.enabled()) {
              module.debug("Input is already enabled, skipping input property change");
              return;
            }
            module.debug("Setting state to enabled");
            $input.prop("disabled", false);
          },
          tabbable: function() {
            module.verbose("Adding tabindex to checkbox");
            if ($input.attr("tabindex") === void 0) {
              $input.attr("tabindex", 0);
            }
          }
        },
        remove: {
          initialLoad: function() {
            initialLoad = false;
          }
        },
        trigger: {
          change: function() {
            var inputElement = $input[0];
            if (inputElement) {
              var events = document2.createEvent("HTMLEvents");
              module.verbose("Triggering native change event");
              events.initEvent("change", true, false);
              inputElement.dispatchEvent(events);
            }
          }
        },
        create: {
          label: function() {
            if ($input.prevAll(selector.label).length > 0) {
              $input.prev(selector.label).detach().insertAfter($input);
              module.debug("Moving existing label", $label);
            } else if (!module.has.label()) {
              $label = $("<label>").insertAfter($input);
              module.debug("Creating label", $label);
            }
          }
        },
        has: {
          label: function() {
            return $label.length > 0;
          }
        },
        bind: {
          events: function() {
            module.verbose("Attaching checkbox events");
            $module.on("click" + eventNamespace, module.event.click).on("change" + eventNamespace, module.event.change).on("keydown" + eventNamespace, selector.input, module.event.keydown).on("keyup" + eventNamespace, selector.input, module.event.keyup);
          }
        },
        unbind: {
          events: function() {
            module.debug("Removing events");
            $module.off(eventNamespace);
          }
        },
        uncheckOthers: function() {
          var $radios = module.get.otherRadios();
          module.debug("Unchecking other radios", $radios);
          $radios.removeClass(className.checked);
        },
        toggle: function() {
          if (!module.can.change()) {
            if (!module.is.radio()) {
              module.debug("Checkbox is read-only or disabled, ignoring toggle");
            }
            return;
          }
          if (module.is.indeterminate() || module.is.unchecked()) {
            module.debug("Currently unchecked");
            module.check();
          } else if (module.is.checked() && module.can.uncheck()) {
            module.debug("Currently checked");
            module.uncheck();
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.checkbox.settings = {
    name: "Checkbox",
    namespace: "checkbox",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    // delegated event context
    uncheckable: "auto",
    fireOnInit: false,
    enableEnterKey: true,
    onChange: function() {
    },
    beforeChecked: function() {
    },
    beforeUnchecked: function() {
    },
    beforeDeterminate: function() {
    },
    beforeIndeterminate: function() {
    },
    onChecked: function() {
    },
    onUnchecked: function() {
    },
    onDeterminate: function() {
    },
    onIndeterminate: function() {
    },
    onEnable: function() {
    },
    onDisable: function() {
    },
    // preserve misspelled callbacks (will be removed in 3.0)
    onEnabled: function() {
    },
    onDisabled: function() {
    },
    className: {
      checked: "checked",
      indeterminate: "indeterminate",
      disabled: "disabled",
      hidden: "hidden",
      radio: "radio",
      readOnly: "read-only"
    },
    error: {
      method: "The method you called is not defined"
    },
    selector: {
      checkbox: ".ui.checkbox",
      label: "label",
      input: 'input[type="checkbox"], input[type="radio"]',
      link: "a[href]"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.dimmer = function(parameters) {
    var $allModules = $(this), time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.dimmer.settings, parameters) : $.extend({}, $.fn.dimmer.settings), selector = settings.selector, namespace = settings.namespace, className = settings.className, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, moduleSelector = $allModules.selector || "", clickEvent = "ontouchstart" in document2.documentElement ? "touchstart" : "click", $module = $(this), $dimmer, $dimmable, element2 = this, instance68 = $module.data(moduleNamespace), module;
      module = {
        preinitialize: function() {
          if (module.is.dimmer()) {
            $dimmable = $module.parent();
            $dimmer = $module;
          } else {
            $dimmable = $module;
            if (module.has.dimmer()) {
              $dimmer = settings.dimmerName ? $dimmable.find(selector.dimmer).filter("." + settings.dimmerName) : $dimmable.find(selector.dimmer);
            } else {
              $dimmer = module.create();
            }
          }
        },
        initialize: function() {
          module.debug("Initializing dimmer", settings);
          module.bind.events();
          module.set.dimmable();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        destroy: function() {
          module.verbose("Destroying previous module", $dimmer);
          module.unbind.events();
          module.remove.variation();
          $dimmable.off(eventNamespace);
        },
        bind: {
          events: function() {
            if (settings.on === "hover") {
              $dimmable.on("mouseenter" + eventNamespace, module.show).on("mouseleave" + eventNamespace, module.hide);
            } else if (settings.on === "click") {
              $dimmable.on(clickEvent + eventNamespace, module.toggle);
            }
            if (module.is.page()) {
              module.debug("Setting as a page dimmer", $dimmable);
              module.set.pageDimmer();
            }
            if (module.is.closable()) {
              module.verbose("Adding dimmer close event", $dimmer);
              $dimmable.on(clickEvent + eventNamespace, selector.dimmer, module.event.click);
            }
          }
        },
        unbind: {
          events: function() {
            $module.removeData(moduleNamespace);
            $dimmable.off(eventNamespace);
          }
        },
        event: {
          click: function(event2) {
            module.verbose("Determining if event occurred on dimmer", event2);
            if ($dimmer.find(event2.target).length === 0 || $(event2.target).is(selector.content)) {
              module.hide();
              event2.stopImmediatePropagation();
            }
          }
        },
        addContent: function(element3) {
          var $content = $(element3);
          module.debug("Add content to dimmer", $content);
          if ($content.parent()[0] !== $dimmer[0]) {
            $content.detach().appendTo($dimmer);
          }
        },
        create: function() {
          var $element = $(settings.template.dimmer(settings));
          if (settings.dimmerName) {
            module.debug("Creating named dimmer", settings.dimmerName);
            $element.addClass(settings.dimmerName);
          }
          $element.appendTo($dimmable);
          return $element;
        },
        show: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if ((!module.is.dimmed() || module.is.animating()) && module.is.enabled()) {
            if (settings.onShow.call(element2) === false) {
              module.verbose("Show callback returned false cancelling dimmer show");
              return;
            }
            module.debug("Showing dimmer", $dimmer, settings);
            module.set.variation();
            module.animate.show(callback);
            settings.onChange.call(element2);
          } else {
            module.debug("Dimmer is already shown or disabled");
          }
        },
        hide: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (module.is.dimmed() || module.is.animating()) {
            if (settings.onHide.call(element2) === false) {
              module.verbose("Hide callback returned false cancelling dimmer hide");
              return;
            }
            module.debug("Hiding dimmer", $dimmer);
            module.animate.hide(callback);
            settings.onChange.call(element2);
          } else {
            module.debug("Dimmer is not visible");
          }
        },
        toggle: function() {
          module.verbose("Toggling dimmer visibility", $dimmer);
          if (!module.is.dimmed()) {
            module.show();
          } else {
            if (module.is.closable()) {
              module.hide();
            }
          }
        },
        animate: {
          show: function(callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            if (settings.useCSS && $.fn.transition !== void 0) {
              if (settings.useFlex) {
                module.debug("Using flex dimmer");
                module.remove.legacy();
              } else {
                module.debug("Using legacy non-flex dimmer");
                module.set.legacy();
              }
              if (settings.opacity !== "auto") {
                module.set.opacity();
              }
              $dimmer.transition({
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                displayType: settings.useFlex ? "flex" : "block",
                animation: (settings.transition.showMethod || settings.transition) + " in",
                queue: false,
                duration: module.get.duration(),
                useFailSafe: true,
                onStart: function() {
                  module.set.dimmed();
                },
                onComplete: function() {
                  module.set.active();
                  settings.onVisible.call($dimmer);
                  callback();
                }
              });
            } else {
              module.verbose("Showing dimmer animation with javascript");
              module.set.dimmed();
              if (settings.opacity === "auto") {
                settings.opacity = 0.8;
              }
              $dimmer.stop().css({
                opacity: 0,
                width: "100%",
                height: "100%"
              }).fadeTo(module.get.duration(), settings.opacity, function() {
                $dimmer.removeAttr("style");
                module.set.active();
                settings.onVisible.call($dimmer);
                callback();
              });
            }
          },
          hide: function(callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            if (settings.useCSS && $.fn.transition !== void 0) {
              module.verbose("Hiding dimmer with css");
              $dimmer.transition({
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                displayType: settings.useFlex ? "flex" : "block",
                animation: (settings.transition.hideMethod || settings.transition) + " out",
                queue: false,
                duration: module.get.duration(),
                useFailSafe: true,
                onComplete: function() {
                  module.remove.dimmed();
                  module.remove.variation();
                  module.remove.active();
                  settings.onHidden.call($dimmer);
                  callback();
                }
              });
            } else {
              module.verbose("Hiding dimmer with javascript");
              $dimmer.stop().fadeOut(module.get.duration(), function() {
                module.remove.dimmed();
                module.remove.active();
                $dimmer.removeAttr("style");
                settings.onHidden.call($dimmer);
                callback();
              });
            }
          }
        },
        get: {
          dimmer: function() {
            return $dimmer;
          },
          duration: function() {
            if (module.is.active()) {
              return settings.transition.hideDuration || settings.duration.hide || settings.duration;
            }
            return settings.transition.showDuration || settings.duration.show || settings.duration;
          }
        },
        has: {
          dimmer: function() {
            if (settings.dimmerName) {
              return $module.find(selector.dimmer).filter("." + settings.dimmerName).length > 0;
            }
            return $module.find(selector.dimmer).length > 0;
          }
        },
        is: {
          active: function() {
            return $dimmer.hasClass(className.active);
          },
          animating: function() {
            return $dimmer.is(":animated") || $dimmer.hasClass(className.animating);
          },
          closable: function() {
            if (settings.closable === "auto") {
              return settings.on !== "hover";
            }
            return settings.closable;
          },
          dimmer: function() {
            return $module.hasClass(className.dimmer);
          },
          dimmable: function() {
            return $module.hasClass(className.dimmable);
          },
          dimmed: function() {
            return $dimmable.hasClass(className.dimmed);
          },
          disabled: function() {
            return $dimmable.hasClass(className.disabled);
          },
          enabled: function() {
            return !module.is.disabled();
          },
          page: function() {
            return $dimmable.is("body");
          },
          pageDimmer: function() {
            return $dimmer.hasClass(className.pageDimmer);
          }
        },
        can: {
          show: function() {
            return !$dimmer.hasClass(className.disabled);
          }
        },
        set: {
          opacity: function(opacity) {
            var color = $dimmer.css("background-color"), colorArray = color.split(","), isRGB = colorArray && colorArray.length >= 3;
            opacity = settings.opacity === 0 ? 0 : settings.opacity || opacity;
            if (isRGB) {
              colorArray[2] = colorArray[2].replace(")", "");
              colorArray[3] = opacity + ")";
              color = colorArray.join(",");
            } else {
              color = "rgba(0, 0, 0, " + opacity + ")";
            }
            module.debug("Setting opacity to", opacity);
            $dimmer.css("background-color", color);
          },
          legacy: function() {
            $dimmer.addClass(className.legacy);
          },
          active: function() {
            $dimmer.addClass(className.active);
          },
          dimmable: function() {
            $dimmable.addClass(className.dimmable);
          },
          dimmed: function() {
            $dimmable.addClass(className.dimmed);
          },
          pageDimmer: function() {
            $dimmer.addClass(className.pageDimmer);
          },
          disabled: function() {
            $dimmer.addClass(className.disabled);
          },
          variation: function(variation) {
            variation = variation || settings.variation;
            if (variation) {
              $dimmer.addClass(variation);
            }
          }
        },
        remove: {
          active: function() {
            $dimmer.removeClass(className.active);
          },
          legacy: function() {
            $dimmer.removeClass(className.legacy);
          },
          dimmed: function() {
            $dimmable.removeClass(className.dimmed);
          },
          disabled: function() {
            $dimmer.removeClass(className.disabled);
          },
          variation: function(variation) {
            variation = variation || settings.variation;
            if (variation) {
              $dimmer.removeClass(variation);
            }
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      module.preinitialize();
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.dimmer.settings = {
    name: "Dimmer",
    namespace: "dimmer",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    // whether should use flex layout
    useFlex: true,
    // name to distinguish between multiple dimmers in context
    dimmerName: false,
    // whether to add a variation type
    variation: false,
    // whether to bind close events
    closable: "auto",
    // whether to use css animations
    useCSS: true,
    // css animation to use
    transition: "fade",
    // event to bind to
    on: false,
    // overriding opacity value
    opacity: "auto",
    // transition durations
    duration: {
      show: 500,
      hide: 500
    },
    // whether the dynamically created dimmer should have a loader
    displayLoader: false,
    loaderText: false,
    loaderVariation: "",
    onChange: function() {
    },
    onShow: function() {
    },
    onHide: function() {
    },
    onVisible: function() {
    },
    onHidden: function() {
    },
    error: {
      method: "The method you called is not defined."
    },
    className: {
      active: "active",
      animating: "animating",
      dimmable: "dimmable",
      dimmed: "dimmed",
      dimmer: "dimmer",
      disabled: "disabled",
      hide: "hide",
      legacy: "legacy",
      pageDimmer: "page",
      show: "show",
      loader: "ui loader"
    },
    selector: {
      dimmer: "> .ui.dimmer",
      content: ".ui.dimmer > .content, .ui.dimmer > .content > .center"
    },
    template: {
      dimmer: function(settings) {
        var d = $("<div/>").addClass("ui dimmer"), l;
        if (settings.displayLoader) {
          l = $("<div/>").addClass(settings.className.loader).addClass(settings.loaderVariation);
          if (settings.loaderText) {
            l.text(settings.loaderText);
            l.addClass("text");
          }
          d.append(l);
        }
        return d;
      }
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.dropdown = function(parameters) {
    var $allModules = $(this), $document = $(document2), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function(elementIndex) {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.dropdown.settings, parameters) : $.extend({}, $.fn.dropdown.settings), className = settings.className, message = settings.message, fields = settings.fields, keys = settings.keys, metadata = settings.metadata, namespace = settings.namespace, regExp = settings.regExp, selector = settings.selector, error = settings.error, templates = settings.templates, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $(settings.context), $text = $module.find(selector.text), $search = $module.find(selector.search), $sizer = $module.find(selector.sizer), $input = $module.find(selector.input), $icon = $module.find(selector.icon), $clear = $module.find(selector.clearIcon), $combo = $module.prev().find(selector.text).length > 0 ? $module.prev().find(selector.text) : $module.prev(), $menu = $module.children(selector.menu), $item = $menu.find(selector.item), $divider = settings.hideDividers ? $item.parent().children(selector.divider) : $(), activated = false, itemActivated = false, internalChange = false, iconClicked = false, element2 = this, focused = false, instance68 = $module.data(moduleNamespace), selectActionActive, initialLoad, pageLostFocus, willRefocus, elementNamespace, id, selectObserver, menuObserver, classObserver, module;
      module = {
        initialize: function() {
          module.debug("Initializing dropdown", settings);
          if (module.is.alreadySetup()) {
            module.setup.reference();
          } else {
            if (settings.ignoreDiacritics && !String.prototype.normalize) {
              settings.ignoreDiacritics = false;
              module.error(error.noNormalize, element2);
            }
            module.create.id();
            module.setup.layout();
            if (settings.values) {
              module.set.initialLoad();
              module.change.values(settings.values);
              module.remove.initialLoad();
            }
            module.refreshData();
            module.save.defaults();
            module.restore.selected();
            module.bind.events();
            module.observeChanges();
            module.instantiate();
          }
        },
        instantiate: function() {
          module.verbose("Storing instance of dropdown", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous dropdown", $module);
          module.remove.tabbable();
          module.remove.active();
          $menu.transition("stop all");
          $menu.removeClass(className.visible).addClass(className.hidden);
          $module.off(eventNamespace).removeData(moduleNamespace);
          $menu.off(eventNamespace);
          $document.off(elementNamespace);
          module.disconnect.menuObserver();
          module.disconnect.selectObserver();
          module.disconnect.classObserver();
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            selectObserver = new MutationObserver(module.event.select.mutation);
            menuObserver = new MutationObserver(module.event.menu.mutation);
            classObserver = new MutationObserver(module.event.class.mutation);
            module.debug("Setting up mutation observer", selectObserver, menuObserver, classObserver);
            module.observe.select();
            module.observe.menu();
            module.observe.class();
          }
        },
        disconnect: {
          menuObserver: function() {
            if (menuObserver) {
              menuObserver.disconnect();
            }
          },
          selectObserver: function() {
            if (selectObserver) {
              selectObserver.disconnect();
            }
          },
          classObserver: function() {
            if (classObserver) {
              classObserver.disconnect();
            }
          }
        },
        observe: {
          select: function() {
            if (module.has.input() && selectObserver) {
              selectObserver.observe($module[0], {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
          },
          menu: function() {
            if (module.has.menu() && menuObserver) {
              menuObserver.observe($menu[0], {
                childList: true,
                subtree: true
              });
            }
          },
          class: function() {
            if (module.has.search() && classObserver) {
              classObserver.observe($module[0], {
                attributes: true
              });
            }
          }
        },
        create: {
          id: function() {
            id = (Math.random().toString(16) + "000000000").slice(2, 10);
            elementNamespace = "." + id;
            module.verbose("Creating unique id for element", id);
          },
          userChoice: function(values) {
            var $userChoices, $userChoice, html;
            values = values || module.get.userValues();
            if (!values) {
              return false;
            }
            values = Array.isArray(values) ? values : [values];
            $.each(values, function(index, value) {
              if (module.get.item(value) === false) {
                html = settings.templates.addition(module.add.variables(message.addResult, value));
                $userChoice = $("<div />").html(html).attr("data-" + metadata.value, value).attr("data-" + metadata.text, value).addClass(className.addition).addClass(className.item);
                if (settings.hideAdditions) {
                  $userChoice.addClass(className.hidden);
                }
                $userChoices = $userChoices === void 0 ? $userChoice : $userChoices.add($userChoice);
                module.verbose("Creating user choices for value", value, $userChoice);
              }
            });
            return $userChoices;
          },
          userLabels: function(value) {
            var userValues = module.get.userValues();
            if (userValues) {
              module.debug("Adding user labels", userValues);
              $.each(userValues, function(index, value2) {
                module.verbose("Adding custom user value");
                module.add.label(value2, value2);
              });
            }
          },
          menu: function() {
            $menu = $("<div />").addClass(className.menu).appendTo($module);
          },
          sizer: function() {
            $sizer = $("<span />").addClass(className.sizer).insertAfter($search);
          }
        },
        search: function(query2) {
          query2 = query2 !== void 0 ? query2 : module.get.query();
          module.verbose("Searching for query", query2);
          if (settings.fireOnInit === false && module.is.initialLoad()) {
            module.verbose("Skipping callback on initial load", settings.onSearch);
          } else if (module.has.minCharacters(query2) && settings.onSearch.call(element2, query2) !== false) {
            module.filter(query2);
          } else {
            module.hide(null, true);
          }
        },
        select: {
          firstUnfiltered: function() {
            module.verbose("Selecting first non-filtered element");
            module.remove.selectedItem();
            $item.not(selector.unselectable).not(selector.addition + selector.hidden).eq(0).addClass(className.selected);
          },
          nextAvailable: function($selected) {
            $selected = $selected.eq(0);
            var $nextAvailable = $selected.nextAll(selector.item).not(selector.unselectable).eq(0), $prevAvailable = $selected.prevAll(selector.item).not(selector.unselectable).eq(0), hasNext = $nextAvailable.length > 0;
            if (hasNext) {
              module.verbose("Moving selection to", $nextAvailable);
              $nextAvailable.addClass(className.selected);
            } else {
              module.verbose("Moving selection to", $prevAvailable);
              $prevAvailable.addClass(className.selected);
            }
          }
        },
        setup: {
          api: function() {
            var apiSettings = {
              debug: settings.debug,
              urlData: {
                value: module.get.value(),
                query: module.get.query()
              },
              on: false
            };
            module.verbose("First request, initializing API");
            $module.api(apiSettings);
          },
          layout: function() {
            if ($module.is("select")) {
              module.setup.select();
              module.setup.returnedObject();
            }
            if (!module.has.menu()) {
              module.create.menu();
            }
            if (module.is.clearable() && !module.has.clearItem()) {
              module.verbose("Adding clear icon");
              $clear = $("<i />").addClass("remove icon").insertBefore($text);
            }
            if (module.is.search() && !module.has.search()) {
              module.verbose("Adding search input");
              var labelNode = $module.prev("label");
              $search = $("<input />").addClass(className.search).prop("autocomplete", module.is.chrome() ? "fomantic-search" : "off");
              if (labelNode.length > 0) {
                if (!labelNode.attr("id")) {
                  labelNode.attr("id", "_" + module.get.id() + "_formLabel");
                }
                $search.attr("aria-labelledby", labelNode.attr("id"));
              }
              $search.insertBefore($text);
            }
            if (module.is.multiple() && module.is.searchSelection() && !module.has.sizer()) {
              module.create.sizer();
            }
            if (settings.allowTab) {
              module.set.tabbable();
            }
          },
          select: function() {
            var selectValues = module.get.selectValues();
            module.debug("Dropdown initialized on a select", selectValues);
            if ($module.is("select")) {
              $input = $module;
            }
            if ($input.parent(selector.dropdown).length > 0) {
              module.debug("UI dropdown already exists. Creating dropdown menu only");
              $module = $input.closest(selector.dropdown);
              if (!module.has.menu()) {
                module.create.menu();
              }
              $menu = $module.children(selector.menu);
              module.setup.menu(selectValues);
            } else {
              module.debug("Creating entire dropdown from select");
              $module = $("<div />").attr("class", $input.attr("class")).addClass(className.selection).addClass(className.dropdown).html(templates.dropdown(selectValues, fields, settings.preserveHTML, settings.className)).insertBefore($input);
              if ($input.hasClass(className.multiple) && $input.prop("multiple") === false) {
                module.error(error.missingMultiple);
                $input.prop("multiple", true);
              }
              if ($input.is("[multiple]")) {
                module.set.multiple();
              }
              if ($input.prop("disabled")) {
                module.debug("Disabling dropdown");
                $module.addClass(className.disabled);
              }
              if ($input.is("[required]")) {
                settings.forceSelection = true;
              }
              if (!settings.allowTab) {
                $input.removeAttr("tabindex");
              }
              $input.prop("required", false).removeAttr("class").detach().prependTo($module);
            }
            module.refresh();
          },
          menu: function(values) {
            $menu.html(templates.menu(values, fields, settings.preserveHTML, settings.className));
            $item = $menu.find(selector.item);
            $divider = settings.hideDividers ? $item.parent().children(selector.divider) : $();
          },
          reference: function() {
            module.debug("Dropdown behavior was called on select, replacing with closest dropdown");
            $module = $module.parent(selector.dropdown);
            instance68 = $module.data(moduleNamespace);
            element2 = $module[0];
            module.refresh();
            module.setup.returnedObject();
          },
          returnedObject: function() {
            var $firstModules = $allModules.slice(0, elementIndex), $lastModules = $allModules.slice(elementIndex + 1);
            $allModules = $firstModules.add($module).add($lastModules);
          }
        },
        refresh: function() {
          module.refreshSelectors();
          module.refreshData();
        },
        refreshItems: function() {
          $item = $menu.find(selector.item);
          $divider = settings.hideDividers ? $item.parent().children(selector.divider) : $();
        },
        refreshSelectors: function() {
          module.verbose("Refreshing selector cache");
          $text = $module.find(selector.text);
          $search = $module.find(selector.search);
          $input = $module.find(selector.input);
          $icon = $module.find(selector.icon);
          $combo = $module.prev().find(selector.text).length > 0 ? $module.prev().find(selector.text) : $module.prev();
          $menu = $module.children(selector.menu);
          $item = $menu.find(selector.item);
          $divider = settings.hideDividers ? $item.parent().children(selector.divider) : $();
        },
        refreshData: function() {
          module.verbose("Refreshing cached metadata");
          $item.removeData(metadata.text).removeData(metadata.value);
        },
        clearData: function() {
          module.verbose("Clearing metadata");
          $item.removeData(metadata.text).removeData(metadata.value);
          $module.removeData(metadata.defaultText).removeData(metadata.defaultValue).removeData(metadata.placeholderText);
        },
        clearItems: function() {
          $menu.empty();
          module.refreshItems();
        },
        toggle: function() {
          module.verbose("Toggling menu visibility");
          if (!module.is.active()) {
            module.show();
          } else {
            module.hide();
          }
        },
        show: function(callback, preventFocus) {
          callback = isFunction(callback) ? callback : function() {
          };
          if ((focused || iconClicked) && module.is.remote() && module.is.noApiCache()) {
            module.clearItems();
          }
          if (!module.can.show() && module.is.remote()) {
            module.debug("No API results retrieved, searching before show");
            module.queryRemote(module.get.query(), module.show, [callback, preventFocus]);
          }
          if (module.can.show() && !module.is.active()) {
            module.debug("Showing dropdown");
            if (module.has.message() && !(module.has.maxSelections() || module.has.allResultsFiltered())) {
              module.remove.message();
            }
            if (module.is.allFiltered()) {
              return true;
            }
            if (settings.onShow.call(element2) !== false) {
              module.remove.empty();
              module.animate.show(function() {
                module.bind.intent();
                if (module.has.search() && !preventFocus) {
                  module.focusSearch();
                }
                module.set.visible();
                callback.call(element2);
              });
            }
          }
        },
        hide: function(callback, preventBlur) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (module.is.active() && !module.is.animatingOutward()) {
            module.debug("Hiding dropdown");
            if (settings.onHide.call(element2) !== false) {
              module.animate.hide(function() {
                module.remove.visible();
                if (module.is.focusedOnSearch() && preventBlur !== true) {
                  $search.trigger("blur");
                }
                callback.call(element2);
              });
              var $subMenu = $module.find(selector.menu);
              if ($subMenu.length > 0) {
                module.verbose("Hiding sub-menu", $subMenu);
                $subMenu.each(function() {
                  module.animate.hide(false, $(this));
                });
              }
            }
          } else {
            module.unbind.intent();
          }
          iconClicked = false;
          focused = false;
        },
        hideOthers: function() {
          module.verbose("Finding other dropdowns to hide");
          $allModules.not($module).has(selector.menu + "." + className.visible).dropdown("hide");
        },
        hideMenu: function() {
          module.verbose("Hiding menu  instantaneously");
          module.remove.active();
          module.remove.visible();
          $menu.transition("destroy").transition("hide");
        },
        hideSubMenus: function() {
          var $subMenus = $menu.children(selector.item).find(selector.menu);
          module.verbose("Hiding sub menus", $subMenus);
          $subMenus.transition("hide");
        },
        bind: {
          events: function() {
            module.bind.keyboardEvents();
            module.bind.inputEvents();
            module.bind.mouseEvents();
          },
          keyboardEvents: function() {
            module.verbose("Binding keyboard events");
            $module.on("keydown" + eventNamespace, module.event.keydown);
            if (module.has.search()) {
              $module.on(module.get.inputEvent() + eventNamespace, selector.search, module.event.input);
            }
            if (module.is.multiple()) {
              $document.on("keydown" + elementNamespace, module.event.document.keydown);
            }
          },
          inputEvents: function() {
            module.verbose("Binding input change events");
            $module.on("change" + eventNamespace, selector.input, module.event.change);
            if (module.is.multiple() && module.is.searchSelection()) {
              $module.on("paste" + eventNamespace, selector.search, module.event.paste);
            }
          },
          mouseEvents: function() {
            module.verbose("Binding mouse events");
            if (module.is.multiple()) {
              $module.on("click" + eventNamespace, selector.label, module.event.label.click).on("click" + eventNamespace, selector.remove, module.event.remove.click);
            }
            if (module.is.searchSelection()) {
              $module.on("mousedown" + eventNamespace, module.event.mousedown).on("mouseup" + eventNamespace, module.event.mouseup).on("mousedown" + eventNamespace, selector.menu, module.event.menu.mousedown).on("mouseup" + eventNamespace, selector.menu, module.event.menu.mouseup).on("click" + eventNamespace, selector.icon, module.event.icon.click).on("click" + eventNamespace, selector.clearIcon, module.event.clearIcon.click).on("focus" + eventNamespace, selector.search, module.event.search.focus).on("click" + eventNamespace, selector.search, module.event.search.focus).on("blur" + eventNamespace, selector.search, module.event.search.blur).on("click" + eventNamespace, selector.text, module.event.text.focus);
              if (module.is.multiple()) {
                $module.on("click" + eventNamespace, module.event.click).on("click" + eventNamespace, module.event.search.focus);
              }
            } else {
              if (settings.on === "click") {
                $module.on("click" + eventNamespace, selector.icon, module.event.icon.click).on("click" + eventNamespace, module.event.test.toggle);
              } else if (settings.on === "hover") {
                $module.on("mouseenter" + eventNamespace, module.delay.show).on("mouseleave" + eventNamespace, module.delay.hide).on("touchstart" + eventNamespace, module.event.test.toggle).on("touchstart" + eventNamespace, selector.icon, module.event.icon.click);
              } else {
                $module.on(settings.on + eventNamespace, module.toggle);
              }
              $module.on("mousedown" + eventNamespace, module.event.mousedown).on("mouseup" + eventNamespace, module.event.mouseup).on("focus" + eventNamespace, module.event.focus).on("click" + eventNamespace, selector.clearIcon, module.event.clearIcon.click);
              if (module.has.menuSearch()) {
                $module.on("blur" + eventNamespace, selector.search, module.event.search.blur);
              } else {
                $module.on("blur" + eventNamespace, module.event.blur);
              }
            }
            $menu.on("mouseenter" + eventNamespace, selector.item, module.event.item.mouseenter).on("touchstart" + eventNamespace, selector.item, module.event.item.mouseenter).on("mouseleave" + eventNamespace, selector.item, module.event.item.mouseleave).on("click" + eventNamespace, selector.item, module.event.item.click);
          },
          intent: function() {
            module.verbose("Binding hide intent event to document");
            $document.on("click" + elementNamespace, module.event.test.hide);
          }
        },
        unbind: {
          intent: function() {
            module.verbose("Removing hide intent event from document");
            $document.off("click" + elementNamespace);
          }
        },
        filter: function(query2) {
          var searchTerm = query2 !== void 0 ? query2 : module.get.query(), afterFiltered = function() {
            if (module.is.multiple()) {
              module.filterActive();
            }
            if (query2 || !query2 && module.get.activeItem().length === 0) {
              module.select.firstUnfiltered();
            }
            if (module.has.allResultsFiltered()) {
              if (settings.onNoResults.call(element2, searchTerm)) {
                if (settings.allowAdditions) {
                  if (settings.hideAdditions) {
                    module.verbose("User addition with no menu, setting empty style");
                    module.set.empty();
                    module.hideMenu();
                  }
                } else {
                  module.verbose("All items filtered, showing message", searchTerm);
                  module.add.message(message.noResults);
                }
              } else {
                module.verbose("All items filtered, hiding dropdown", searchTerm);
                module.set.empty();
                module.hideMenu();
              }
            } else {
              module.remove.empty();
              module.remove.message();
            }
            if (settings.allowAdditions) {
              module.add.userSuggestion(module.escape.htmlEntities(query2));
            }
            if (module.is.searchSelection() && module.can.show() && module.is.focusedOnSearch() && !module.is.empty()) {
              module.show();
            }
          };
          if (settings.useLabels && module.has.maxSelections()) {
            return;
          }
          if (settings.apiSettings) {
            if (module.can.useAPI()) {
              module.queryRemote(searchTerm, function() {
                if (settings.filterRemoteData) {
                  module.filterItems(searchTerm);
                }
                var preSelected = $input.val();
                if (!Array.isArray(preSelected)) {
                  preSelected = preSelected && preSelected !== "" ? preSelected.split(settings.delimiter) : [];
                }
                if (module.is.multiple()) {
                  $.each(preSelected, function(index, value) {
                    $item.filter('[data-value="' + value + '"]').addClass(className.filtered);
                  });
                }
                module.focusSearch(true);
                afterFiltered();
              });
            } else {
              module.error(error.noAPI);
            }
          } else {
            module.filterItems(searchTerm);
            afterFiltered();
          }
        },
        queryRemote: function(query2, callback, callbackParameters) {
          if (!Array.isArray(callbackParameters)) {
            callbackParameters = [callbackParameters];
          }
          var apiSettings = {
            errorDuration: false,
            cache: "local",
            throttle: settings.throttle,
            urlData: {
              query: query2
            }
          }, apiCallbacks = {
            onError: function(errorMessage, $module2, xhr) {
              module.add.message(message.serverError);
              iconClicked = false;
              focused = false;
              callback.apply(null, callbackParameters);
              if (typeof settings.apiSettings.onError === "function") {
                settings.apiSettings.onError.call(this, errorMessage, $module2, xhr);
              }
            },
            onFailure: function(response, $module2, xhr) {
              module.add.message(message.serverError);
              iconClicked = false;
              focused = false;
              callback.apply(null, callbackParameters);
              if (typeof settings.apiSettings.onFailure === "function") {
                settings.apiSettings.onFailure.call(this, response, $module2, xhr);
              }
            },
            onSuccess: function(response, $module2, xhr) {
              var values = response[fields.remoteValues];
              if (!Array.isArray(values)) {
                values = [];
              }
              module.remove.message();
              var menuConfig = {};
              menuConfig[fields.values] = values;
              module.setup.menu(menuConfig);
              if (values.length === 0 && !settings.allowAdditions) {
                module.add.message(message.noResults);
              } else {
                var value = module.is.multiple() ? module.get.values() : module.get.value();
                if (value !== "") {
                  module.verbose("Value(s) present after click icon, select value(s) in items");
                  module.set.selected(value, null, true, true);
                }
              }
              iconClicked = false;
              focused = false;
              callback.apply(null, callbackParameters);
              if (typeof settings.apiSettings.onSuccess === "function") {
                settings.apiSettings.onSuccess.call(this, response, $module2, xhr);
              }
            }
          };
          if (!$module.api("get request")) {
            module.setup.api();
          }
          apiSettings = $.extend(true, {}, apiSettings, settings.apiSettings, apiCallbacks);
          $module.api("setting", apiSettings).api("query");
        },
        filterItems: function(query2) {
          var searchTerm = module.remove.diacritics(
            query2 !== void 0 ? query2 : module.get.query()
          ), results = null, escapedTerm = module.escape.string(searchTerm), regExpFlags = (settings.ignoreSearchCase ? "i" : "") + "gm", beginsWithRegExp = new RegExp("^" + escapedTerm, regExpFlags);
          if (module.has.query()) {
            results = [];
            module.verbose("Searching for matching values", searchTerm);
            $item.each(function() {
              var $choice = $(this), text, value;
              if ($choice.hasClass(className.unfilterable)) {
                results.push(this);
                return true;
              }
              if (settings.match === "both" || settings.match === "text") {
                text = module.remove.diacritics(String(module.get.choiceText($choice, false)));
                if (text.search(beginsWithRegExp) !== -1 || settings.fullTextSearch === "exact" && module.exactSearch(searchTerm, text) || settings.fullTextSearch === true && module.fuzzySearch(searchTerm, text)) {
                  results.push(this);
                  return true;
                }
              }
              if (settings.match === "both" || settings.match === "value") {
                value = module.remove.diacritics(String(module.get.choiceValue($choice, text)));
                if (value.search(beginsWithRegExp) !== -1 || settings.fullTextSearch === "exact" && module.exactSearch(searchTerm, value) || settings.fullTextSearch === true && module.fuzzySearch(searchTerm, value)) {
                  results.push(this);
                  return true;
                }
              }
            });
          }
          module.debug("Showing only matched items", searchTerm);
          module.remove.filteredItem();
          if (results) {
            $item.not(results).addClass(className.filtered);
          }
          if (!module.has.query()) {
            $divider.removeClass(className.hidden);
          } else if (settings.hideDividers === true) {
            $divider.addClass(className.hidden);
          } else if (settings.hideDividers === "empty") {
            $divider.removeClass(className.hidden).filter(function() {
              var $lastDivider = $(this).nextUntil(selector.item);
              return ($lastDivider.length > 0 ? $lastDivider : $(this)).nextUntil(selector.divider).filter(selector.item + ":not(." + className.filtered + ")").length === 0;
            }).addClass(className.hidden);
          }
        },
        fuzzySearch: function(query2, term) {
          var termLength = term.length, queryLength = query2.length;
          query2 = settings.ignoreSearchCase ? query2.toLowerCase() : query2;
          term = settings.ignoreSearchCase ? term.toLowerCase() : term;
          if (queryLength > termLength) {
            return false;
          }
          if (queryLength === termLength) {
            return query2 === term;
          }
          for (var characterIndex = 0, nextCharacterIndex = 0; characterIndex < queryLength; characterIndex++) {
            var continueSearch = false, queryCharacter = query2.charCodeAt(characterIndex);
            while (nextCharacterIndex < termLength) {
              if (term.charCodeAt(nextCharacterIndex++) === queryCharacter) {
                continueSearch = true;
                break;
              }
            }
            if (!continueSearch) {
              return false;
            }
          }
          return true;
        },
        exactSearch: function(query2, term) {
          query2 = settings.ignoreSearchCase ? query2.toLowerCase() : query2;
          term = settings.ignoreSearchCase ? term.toLowerCase() : term;
          return term.indexOf(query2) > -1;
        },
        filterActive: function() {
          if (settings.useLabels) {
            $item.filter("." + className.active).addClass(className.filtered);
          }
        },
        focusSearch: function(skipHandler) {
          if (module.has.search() && !module.is.focusedOnSearch()) {
            if (skipHandler) {
              $module.off("focus" + eventNamespace, selector.search);
              $search.trigger("focus");
              $module.on("focus" + eventNamespace, selector.search, module.event.search.focus);
            } else {
              $search.trigger("focus");
            }
          }
        },
        blurSearch: function() {
          if (module.has.search()) {
            $search.trigger("blur");
          }
        },
        forceSelection: function() {
          var $currentlySelected = $item.not(className.filtered).filter("." + className.selected).eq(0), $activeItem = $item.not(className.filtered).filter("." + className.active).eq(0), $selectedItem = $currentlySelected.length > 0 ? $currentlySelected : $activeItem, hasSelected = $selectedItem.length > 0;
          if (settings.allowAdditions || hasSelected && !module.is.multiple()) {
            module.debug("Forcing partial selection to selected item", $selectedItem);
            module.event.item.click.call($selectedItem, {}, true);
          } else {
            module.remove.searchTerm();
          }
        },
        change: {
          values: function(values) {
            if (!settings.allowAdditions) {
              module.clear();
            }
            module.debug("Creating dropdown with specified values", values);
            var menuConfig = {};
            menuConfig[fields.values] = values;
            module.setup.menu(menuConfig);
            $.each(values, function(index, item) {
              if (item.selected === true) {
                module.debug("Setting initial selection to", item[fields.value]);
                module.set.selected(item[fields.value]);
                if (!module.is.multiple()) {
                  return false;
                }
              }
            });
            if (module.has.selectInput()) {
              module.disconnect.selectObserver();
              $input.html("");
              $input.append("<option disabled selected value></option>");
              $.each(values, function(index, item) {
                var value = settings.templates.deQuote(item[fields.value]), name = settings.templates.escape(
                  item[fields.name] || "",
                  settings.preserveHTML
                );
                $input.append('<option value="' + value + '"' + (item.selected === true ? " selected" : "") + ">" + name + "</option>");
              });
              module.observe.select();
            }
          }
        },
        event: {
          paste: function(event2) {
            var pasteValue = (event2.originalEvent.clipboardData || window2.clipboardData).getData("text"), tokens = pasteValue.split(settings.delimiter), notFoundTokens = [];
            tokens.forEach(function(value) {
              if (module.set.selected(module.escape.htmlEntities(value.trim()), null, true, true) === false) {
                notFoundTokens.push(value);
              }
            });
            event2.preventDefault();
            if (notFoundTokens.length > 0) {
              var searchEl = $search[0], startPos = searchEl.selectionStart, endPos = searchEl.selectionEnd, orgText = searchEl.value, pasteText = notFoundTokens.join(settings.delimiter), newEndPos = startPos + pasteText.length;
              $search.val(orgText.slice(0, startPos) + pasteText + orgText.slice(endPos));
              searchEl.selectionStart = newEndPos;
              searchEl.selectionEnd = newEndPos;
              module.event.input(event2);
            }
          },
          change: function() {
            if (!internalChange) {
              module.debug("Input changed, updating selection");
              module.set.selected();
            }
          },
          focus: function() {
            if (settings.showOnFocus && !activated && module.is.hidden() && !pageLostFocus) {
              focused = true;
              module.show();
            }
          },
          blur: function(event2) {
            pageLostFocus = document2.activeElement === this;
            if (!activated && !pageLostFocus) {
              module.remove.activeLabel();
              module.hide();
            }
          },
          mousedown: function() {
            if (module.is.searchSelection(true)) {
              willRefocus = true;
            } else {
              activated = true;
            }
          },
          mouseup: function() {
            if (module.is.searchSelection(true)) {
              willRefocus = false;
            } else {
              activated = false;
            }
          },
          click: function(event2) {
            var $target = $(event2.target);
            if ($target.is($module)) {
              if (!module.is.focusedOnSearch()) {
                module.focusSearch();
              } else {
                module.show();
              }
            }
          },
          search: {
            focus: function(event2) {
              activated = true;
              if (module.is.multiple()) {
                module.remove.activeLabel();
              }
              if (!focused && !module.is.active() && (settings.showOnFocus || event2.type !== "focus" && event2.type !== "focusin") && event2.type !== "touchstart") {
                focused = true;
                module.search();
              }
            },
            blur: function(event2) {
              pageLostFocus = document2.activeElement === this;
              if (module.is.searchSelection(true) && !willRefocus) {
                if (!itemActivated && !pageLostFocus) {
                  if (settings.forceSelection) {
                    module.forceSelection();
                  } else if (!settings.allowAdditions) {
                    module.remove.searchTerm();
                  }
                  module.hide();
                }
              }
              willRefocus = false;
            }
          },
          clearIcon: {
            click: function(event2) {
              module.clear();
              if (module.is.searchSelection()) {
                module.remove.searchTerm();
              }
              module.hide();
              event2.stopPropagation();
            }
          },
          icon: {
            click: function(event2) {
              iconClicked = true;
              if (module.has.search()) {
                if (!module.is.active()) {
                  if (settings.showOnFocus) {
                    module.focusSearch();
                  } else {
                    module.toggle();
                  }
                } else {
                  module.blurSearch();
                }
              } else {
                module.toggle();
              }
              event2.stopPropagation();
            }
          },
          text: {
            focus: function(event2) {
              activated = true;
              module.focusSearch();
            }
          },
          input: function(event2) {
            if (module.is.multiple() || module.is.searchSelection()) {
              module.set.filtered();
            }
            clearTimeout(module.timer);
            module.timer = setTimeout(module.search, settings.delay.search);
          },
          label: {
            click: function(event2) {
              var $label = $(this), $labels = $module.find(selector.label), $activeLabels = $labels.filter("." + className.active), $nextActive = $label.nextAll("." + className.active), $prevActive = $label.prevAll("." + className.active), $range = $nextActive.length > 0 ? $label.nextUntil($nextActive).add($activeLabels).add($label) : $label.prevUntil($prevActive).add($activeLabels).add($label);
              if (event2.shiftKey) {
                $activeLabels.removeClass(className.active);
                $range.addClass(className.active);
              } else if (event2.ctrlKey) {
                $label.toggleClass(className.active);
              } else {
                $activeLabels.removeClass(className.active);
                $label.addClass(className.active);
              }
              settings.onLabelSelect.apply(this, $labels.filter("." + className.active));
              event2.stopPropagation();
            }
          },
          remove: {
            click: function(event2) {
              var $label = $(this).parent();
              if ($label.hasClass(className.active)) {
                module.remove.activeLabels();
              } else {
                module.remove.activeLabels($label);
              }
              event2.stopPropagation();
            }
          },
          test: {
            toggle: function(event2) {
              var toggleBehavior = module.is.multiple() ? module.show : module.toggle;
              if (module.is.bubbledLabelClick(event2) || module.is.bubbledIconClick(event2)) {
                return;
              }
              if (!module.is.multiple() || module.is.multiple() && !module.is.active()) {
                focused = true;
              }
              if (module.determine.eventOnElement(event2, toggleBehavior) && event2.type !== "touchstart") {
                event2.preventDefault();
              }
            },
            hide: function(event2) {
              if (module.determine.eventInModule(event2, module.hide)) {
                if (element2.id && $(event2.target).attr("for") === element2.id) {
                  event2.preventDefault();
                }
              }
            }
          },
          class: {
            mutation: function(mutations) {
              mutations.forEach(function(mutation) {
                if (mutation.attributeName === "class") {
                  module.check.disabled();
                }
              });
            }
          },
          select: {
            mutation: function(mutations) {
              if (module.is.selectMutation(mutations)) {
                module.debug("<select> modified, recreating menu");
                module.disconnect.selectObserver();
                module.refresh();
                module.setup.select();
                module.set.selected();
                module.observe.select();
              }
            }
          },
          menu: {
            mutation: function(mutations) {
              var mutation = mutations[0], $addedNode = mutation.addedNodes ? $(mutation.addedNodes[0]) : $(false), $removedNode = mutation.removedNodes ? $(mutation.removedNodes[0]) : $(false), $changedNodes = $addedNode.add($removedNode), isUserAddition = $changedNodes.is(selector.addition) || $changedNodes.closest(selector.addition).length > 0, isMessage = $changedNodes.is(selector.message) || $changedNodes.closest(selector.message).length > 0;
              if (isUserAddition || isMessage) {
                module.debug("Updating item selector cache");
                module.refreshItems();
              } else {
                module.debug("Menu modified, updating selector cache");
                module.refresh();
              }
            },
            mousedown: function() {
              itemActivated = true;
            },
            mouseup: function() {
              itemActivated = false;
            }
          },
          item: {
            mouseenter: function(event2) {
              var $target = $(event2.target), $item2 = $(this), $subMenu = $item2.children(selector.menu), $otherMenus = $item2.siblings(selector.item).children(selector.menu), hasSubMenu = $subMenu.length > 0, isBubbledEvent = $subMenu.find($target).length > 0;
              if (!isBubbledEvent && hasSubMenu) {
                clearTimeout(module.itemTimer);
                module.itemTimer = setTimeout(function() {
                  module.verbose("Showing sub-menu", $subMenu);
                  $.each($otherMenus, function() {
                    module.animate.hide(false, $(this));
                  });
                  module.animate.show(false, $subMenu);
                }, settings.delay.show);
                event2.preventDefault();
              }
            },
            mouseleave: function(event2) {
              var $subMenu = $(this).find(selector.menu);
              if ($subMenu.length > 0) {
                clearTimeout(module.itemTimer);
                module.itemTimer = setTimeout(function() {
                  module.verbose("Hiding sub-menu", $subMenu);
                  $subMenu.each(function() {
                    module.animate.hide(false, $(this));
                  });
                }, settings.delay.hide);
              }
            },
            click: function(event2, skipRefocus) {
              var $choice = $(this), $target = event2 ? $(event2.target || "") : $(""), $subMenu = $choice.find(selector.menu), text = module.get.choiceText($choice), value = module.get.choiceValue($choice, text), hasSubMenu = $subMenu.length > 0, isBubbledEvent = $subMenu.find($target).length > 0;
              if (document2.activeElement.tagName.toLowerCase() !== "input") {
                $(document2.activeElement).trigger("blur");
              }
              if (!isBubbledEvent && (!hasSubMenu || settings.allowCategorySelection)) {
                if (module.is.searchSelection()) {
                  if (settings.allowAdditions) {
                    module.remove.userAddition();
                  }
                  module.remove.filteredItem();
                  if (!module.is.visible() && $target.length > 0) {
                    module.show();
                  }
                  module.remove.searchTerm();
                  if (!module.is.focusedOnSearch() && skipRefocus !== true) {
                    module.focusSearch(true);
                  }
                }
                if (!settings.useLabels) {
                  module.remove.filteredItem();
                  module.set.scrollPosition($choice);
                }
                module.determine.selectAction.call(this, text, value);
              }
            }
          },
          document: {
            // label selection should occur even when element has no focus
            keydown: function(event2) {
              var pressedKey = event2.which, isShortcutKey = module.is.inObject(pressedKey, keys);
              if (isShortcutKey) {
                var $label = $module.find(selector.label), $activeLabel = $label.filter("." + className.active), activeValue = $activeLabel.data(metadata.value), labelIndex = $label.index($activeLabel), labelCount = $label.length, hasActiveLabel = $activeLabel.length > 0, hasMultipleActive = $activeLabel.length > 1, isFirstLabel = labelIndex === 0, isLastLabel = labelIndex + 1 === labelCount, isSearch = module.is.searchSelection(), isFocusedOnSearch = module.is.focusedOnSearch(), isFocused = module.is.focused(), caretAtStart = isFocusedOnSearch && module.get.caretPosition(false) === 0, isSelectedSearch = caretAtStart && module.get.caretPosition(true) !== 0;
                if (isSearch && !hasActiveLabel && !isFocusedOnSearch) {
                  return;
                }
                switch (pressedKey) {
                  case keys.leftArrow: {
                    if ((isFocused || caretAtStart) && !hasActiveLabel) {
                      module.verbose("Selecting previous label");
                      $label.last().addClass(className.active);
                    } else if (hasActiveLabel) {
                      if (!event2.shiftKey) {
                        module.verbose("Selecting previous label");
                        $label.removeClass(className.active);
                      } else {
                        module.verbose("Adding previous label to selection");
                      }
                      if (isFirstLabel && !hasMultipleActive) {
                        $activeLabel.addClass(className.active);
                      } else {
                        $activeLabel.prev(selector.siblingLabel).addClass(className.active).end();
                      }
                      event2.preventDefault();
                    }
                    break;
                  }
                  case keys.rightArrow: {
                    if (isFocused && !hasActiveLabel) {
                      $label.first().addClass(className.active);
                    }
                    if (hasActiveLabel) {
                      if (!event2.shiftKey) {
                        module.verbose("Selecting next label");
                        $label.removeClass(className.active);
                      } else {
                        module.verbose("Adding next label to selection");
                      }
                      if (isLastLabel) {
                        if (isSearch) {
                          if (!isFocusedOnSearch) {
                            module.focusSearch();
                          } else {
                            $label.removeClass(className.active);
                          }
                        } else if (hasMultipleActive) {
                          $activeLabel.next(selector.siblingLabel).addClass(className.active);
                        } else {
                          $activeLabel.addClass(className.active);
                        }
                      } else {
                        $activeLabel.next(selector.siblingLabel).addClass(className.active);
                      }
                      event2.preventDefault();
                    }
                    break;
                  }
                  case keys.deleteKey:
                  case keys.backspace: {
                    if (hasActiveLabel) {
                      module.verbose("Removing active labels");
                      if (isLastLabel) {
                        if (isSearch && !isFocusedOnSearch) {
                          module.focusSearch();
                        }
                      }
                      $activeLabel.last().next(selector.siblingLabel).addClass(className.active);
                      module.remove.activeLabels($activeLabel);
                      if (!module.is.visible()) {
                        module.show();
                      }
                      event2.preventDefault();
                    } else if (caretAtStart && !isSelectedSearch && !hasActiveLabel && pressedKey === keys.backspace) {
                      module.verbose("Removing last label on input backspace");
                      $activeLabel = $label.last().addClass(className.active);
                      module.remove.activeLabels($activeLabel);
                      if (!module.is.visible()) {
                        module.show();
                      }
                    }
                    break;
                  }
                  default: {
                    $activeLabel.removeClass(className.active);
                  }
                }
              }
            }
          },
          keydown: function(event2) {
            var pressedKey = event2.which, isShortcutKey = module.is.inObject(pressedKey, keys) || event2.key === settings.delimiter;
            if (isShortcutKey) {
              var $currentlySelected = $item.not(selector.unselectable).filter("." + className.selected).eq(0), $activeItem = $menu.children("." + className.active).eq(0), $selectedItem = $currentlySelected.length > 0 ? $currentlySelected : $activeItem, $visibleItems = $selectedItem.length > 0 ? $selectedItem.siblings(":not(." + className.filtered + ")").addBack() : $menu.children(":not(." + className.filtered + ")"), $subMenu = $selectedItem.children(selector.menu), $parentMenu = $selectedItem.closest(selector.menu), inVisibleMenu = $parentMenu.hasClass(className.visible) || $parentMenu.hasClass(className.animating) || $parentMenu.parent(selector.menu).length > 0, hasSubMenu = $subMenu.length > 0, hasSelectedItem = $selectedItem.length > 0, selectedIsSelectable = $selectedItem.not(selector.unselectable).length > 0, delimiterPressed = event2.key === settings.delimiter && module.is.multiple(), isAdditionWithoutMenu = settings.allowAdditions && (pressedKey === keys.enter || delimiterPressed), $nextItem, isSubMenuItem;
              if (isAdditionWithoutMenu) {
                if (selectedIsSelectable && settings.hideAdditions) {
                  module.verbose("Selecting item from keyboard shortcut", $selectedItem);
                  module.event.item.click.call($selectedItem, event2);
                }
                if (module.is.searchSelection()) {
                  module.remove.searchTerm();
                }
                if (module.is.multiple()) {
                  event2.preventDefault();
                }
              }
              if (module.is.visible()) {
                if (pressedKey === keys.enter || delimiterPressed) {
                  if (pressedKey === keys.enter && hasSelectedItem && hasSubMenu && !settings.allowCategorySelection) {
                    module.verbose("Pressed enter on unselectable category, opening sub menu");
                    pressedKey = keys.rightArrow;
                  } else if (selectedIsSelectable) {
                    module.verbose("Selecting item from keyboard shortcut", $selectedItem);
                    module.event.item.click.call($selectedItem, event2);
                    if (module.is.searchSelection()) {
                      module.remove.searchTerm();
                      if (module.is.multiple()) {
                        $search.trigger("focus");
                      }
                    }
                  }
                  event2.preventDefault();
                }
                if (hasSelectedItem) {
                  if (pressedKey === keys.leftArrow) {
                    isSubMenuItem = $parentMenu[0] !== $menu[0];
                    if (isSubMenuItem) {
                      module.verbose("Left key pressed, closing sub-menu");
                      module.animate.hide(false, $parentMenu);
                      $selectedItem.removeClass(className.selected);
                      $parentMenu.closest(selector.item).addClass(className.selected);
                      event2.preventDefault();
                    }
                  }
                  if (pressedKey === keys.rightArrow) {
                    if (hasSubMenu) {
                      module.verbose("Right key pressed, opening sub-menu");
                      module.animate.show(false, $subMenu);
                      $selectedItem.removeClass(className.selected);
                      $subMenu.find(selector.item).eq(0).addClass(className.selected);
                      event2.preventDefault();
                    }
                  }
                }
                if (pressedKey === keys.upArrow) {
                  $nextItem = hasSelectedItem && inVisibleMenu ? $selectedItem.prevAll(selector.item + ":not(" + selector.unselectable + ")").eq(0) : $item.eq(0);
                  if ($visibleItems.index($nextItem) < 0) {
                    module.verbose("Up key pressed but reached top of current menu");
                    event2.preventDefault();
                    return;
                  }
                  module.verbose("Up key pressed, changing active item");
                  $selectedItem.removeClass(className.selected);
                  $nextItem.addClass(className.selected);
                  module.set.scrollPosition($nextItem);
                  if (settings.selectOnKeydown && module.is.single() && !$nextItem.hasClass(className.actionable)) {
                    module.set.selectedItem($nextItem);
                  }
                  event2.preventDefault();
                }
                if (pressedKey === keys.downArrow) {
                  $nextItem = hasSelectedItem && inVisibleMenu ? $selectedItem.nextAll(selector.item + ":not(" + selector.unselectable + ")").eq(0) : $item.eq(0);
                  if ($nextItem.length === 0) {
                    module.verbose("Down key pressed but reached bottom of current menu");
                    event2.preventDefault();
                    return;
                  }
                  module.verbose("Down key pressed, changing active item");
                  $item.removeClass(className.selected);
                  $nextItem.addClass(className.selected);
                  module.set.scrollPosition($nextItem);
                  if (settings.selectOnKeydown && module.is.single() && !$nextItem.hasClass(className.actionable)) {
                    module.set.selectedItem($nextItem);
                  }
                  event2.preventDefault();
                }
                if (pressedKey === keys.pageUp) {
                  module.scrollPage("up");
                  event2.preventDefault();
                }
                if (pressedKey === keys.pageDown) {
                  module.scrollPage("down");
                  event2.preventDefault();
                }
                if (pressedKey === keys.escape) {
                  module.verbose("Escape key pressed, closing dropdown");
                  module.hide();
                  event2.stopPropagation();
                }
              } else {
                if (pressedKey === keys.enter || delimiterPressed) {
                  event2.preventDefault();
                }
                if (pressedKey === keys.downArrow && !module.is.visible()) {
                  module.verbose("Down key pressed, showing dropdown");
                  module.show();
                  event2.preventDefault();
                }
              }
            } else {
              if (!module.has.search()) {
                module.set.selectedLetter(String.fromCharCode(pressedKey));
              }
            }
          }
        },
        trigger: {
          change: function() {
            var inputElement = $input[0];
            if (inputElement) {
              var events = document2.createEvent("HTMLEvents");
              module.verbose("Triggering native change event");
              events.initEvent("change", true, false);
              inputElement.dispatchEvent(events);
            }
          }
        },
        determine: {
          selectAction: function(text, value) {
            selectActionActive = true;
            module.verbose("Determining action", settings.action);
            if (isFunction(module.action[settings.action])) {
              module.verbose("Triggering preset action", settings.action, text, value);
              module.action[settings.action].call(element2, text, value, this);
            } else if (isFunction(settings.action)) {
              module.verbose("Triggering user action", settings.action, text, value);
              settings.action.call(element2, text, value, this);
            } else {
              module.error(error.action, settings.action);
            }
            selectActionActive = false;
          },
          eventInModule: function(event2, callback) {
            var $target = $(event2.target), inDocument = $target.closest(document2.documentElement).length > 0, inModule = $target.closest($module).length > 0;
            callback = isFunction(callback) ? callback : function() {
            };
            if (inDocument && !inModule) {
              module.verbose("Triggering event", callback);
              callback();
              return true;
            }
            module.verbose("Event occurred in dropdown, canceling callback");
            return false;
          },
          eventOnElement: function(event2, callback) {
            var $target = $(event2.target), $label = $target.closest(selector.siblingLabel), inVisibleDOM = document2.body.contains(event2.target), notOnLabel = $module.find($label).length === 0 || !(module.is.multiple() && settings.useLabels), notInMenu = $target.closest($menu).length === 0;
            callback = isFunction(callback) ? callback : function() {
            };
            if (inVisibleDOM && notOnLabel && notInMenu) {
              module.verbose("Triggering event", callback);
              callback();
              return true;
            }
            module.verbose("Event occurred in dropdown menu, canceling callback");
            return false;
          }
        },
        action: {
          nothing: function() {
          },
          activate: function(text, value, element3) {
            value = value !== void 0 ? value : text;
            if (module.can.activate($(element3))) {
              module.set.selected(value, $(element3));
              if (!module.is.multiple() && !(!settings.collapseOnActionable && $(element3).hasClass(className.actionable))) {
                module.hideAndClear();
              }
            }
          },
          select: function(text, value, element3) {
            value = value !== void 0 ? value : text;
            if (module.can.activate($(element3))) {
              module.set.value(value, text, $(element3));
              if (!module.is.multiple() && !(!settings.collapseOnActionable && $(element3).hasClass(className.actionable))) {
                module.hideAndClear();
              }
            }
          },
          combo: function(text, value, element3) {
            value = value !== void 0 ? value : text;
            module.set.selected(value, $(element3));
            module.hideAndClear();
          },
          hide: function(text, value, element3) {
            module.set.value(value, text, $(element3));
            module.hideAndClear();
          }
        },
        get: {
          id: function() {
            return id;
          },
          defaultText: function() {
            return $module.data(metadata.defaultText);
          },
          defaultValue: function() {
            return $module.data(metadata.defaultValue);
          },
          placeholderText: function() {
            if (settings.placeholder !== "auto" && typeof settings.placeholder === "string") {
              return settings.placeholder;
            }
            return $module.data(metadata.placeholderText) || "";
          },
          text: function() {
            return settings.preserveHTML ? $text.html() : $text.text();
          },
          query: function() {
            return String($search.val()).trim();
          },
          searchWidth: function(value) {
            value = value !== void 0 ? value : $search.val();
            $sizer.text(value);
            return Math.ceil($sizer.width() + (module.is.edge() ? 3 : 1));
          },
          selectionCount: function() {
            var values = module.get.values(), count;
            count = module.is.multiple() ? Array.isArray(values) ? values.length : 0 : module.get.value() !== "" ? 1 : 0;
            return count;
          },
          transition: function($subMenu) {
            return settings.transition === "auto" ? module.is.upward($subMenu) ? "slide up" : "slide down" : settings.transition;
          },
          userValues: function() {
            var values = module.get.values(true);
            if (!values) {
              return false;
            }
            values = Array.isArray(values) ? values : [values];
            return $.grep(values, function(value) {
              return module.get.item(value) === false;
            });
          },
          uniqueArray: function(array) {
            return $.grep(array, function(value, index) {
              return $.inArray(value, array) === index;
            });
          },
          caretPosition: function(returnEndPos) {
            var input = $search[0], range, rangeLength;
            if (returnEndPos && "selectionEnd" in input) {
              return input.selectionEnd;
            }
            if (!returnEndPos && "selectionStart" in input) {
              return input.selectionStart;
            }
            if (document2.selection) {
              input.focus();
              range = document2.selection.createRange();
              rangeLength = range.text.length;
              if (returnEndPos) {
                return rangeLength;
              }
              range.moveStart("character", -input.value.length);
              return range.text.length - rangeLength;
            }
          },
          value: function() {
            var value = $input.length > 0 ? $input.val() : $module.data(metadata.value), isEmptyMultiselect = Array.isArray(value) && value.length === 1 && value[0] === "";
            return value === void 0 || isEmptyMultiselect ? "" : value;
          },
          values: function(raw) {
            var value = module.get.value();
            if (value === "") {
              return "";
            }
            return !module.has.selectInput() && module.is.multiple() ? typeof value === "string" ? (raw ? value : module.escape.htmlEntities(value)).split(settings.delimiter) : "" : value;
          },
          remoteValues: function() {
            var values = module.get.values(), remoteValues = false;
            if (values) {
              if (typeof values === "string") {
                values = [values];
              }
              $.each(values, function(index, value) {
                var name = module.read.remoteData(value);
                module.verbose("Restoring value from session data", name, value);
                if (name) {
                  if (!remoteValues) {
                    remoteValues = {};
                  }
                  remoteValues[value] = name;
                }
              });
            }
            return remoteValues;
          },
          choiceText: function($choice, preserveHTML) {
            preserveHTML = preserveHTML !== void 0 ? preserveHTML : settings.preserveHTML;
            if ($choice) {
              if ($choice.find(selector.menu).length > 0) {
                module.verbose("Retrieving text of element with sub-menu");
                $choice = $choice.clone();
                $choice.find(selector.menu).remove();
                $choice.find(selector.menuIcon).remove();
              }
              return $choice.data(metadata.text) !== void 0 ? $choice.data(metadata.text) : preserveHTML ? $choice.html() && $choice.html().trim() : $choice.text() && $choice.text().trim();
            }
          },
          choiceValue: function($choice, choiceText) {
            choiceText = choiceText || module.get.choiceText($choice);
            if (!$choice) {
              return false;
            }
            return $choice.data(metadata.value) !== void 0 ? String($choice.data(metadata.value)) : typeof choiceText === "string" ? String(
              settings.ignoreSearchCase ? choiceText.toLowerCase() : choiceText
            ).trim() : String(choiceText);
          },
          inputEvent: function() {
            var input = $search[0];
            if (input) {
              return input.oninput !== void 0 ? "input" : input.onpropertychange !== void 0 ? "propertychange" : "keyup";
            }
            return false;
          },
          selectValues: function() {
            var select = {}, oldGroup = [], values = [];
            $module.find("option").each(function() {
              var $option = $(this), name = $option.html(), disabled = $option.attr("disabled"), value = $option.attr("value") !== void 0 ? $option.attr("value") : name, text = $option.data(metadata.text) !== void 0 ? $option.data(metadata.text) : name, group = $option.parent("optgroup");
              if (settings.placeholder === "auto" && value === "") {
                select.placeholder = name;
              } else {
                if (group.length !== oldGroup.length || group[0] !== oldGroup[0]) {
                  values.push({
                    type: "header",
                    divider: settings.headerDivider,
                    name: group.attr("label") || ""
                  });
                  oldGroup = group;
                }
                values.push({
                  name,
                  value,
                  text,
                  disabled
                });
              }
            });
            if (settings.placeholder && settings.placeholder !== "auto") {
              module.debug("Setting placeholder value to", settings.placeholder);
              select.placeholder = settings.placeholder;
            }
            if (settings.sortSelect) {
              if (settings.sortSelect === true) {
                values.sort(function(a, b) {
                  return a.name.localeCompare(b.name);
                });
              } else if (settings.sortSelect === "natural") {
                values.sort(function(a, b) {
                  return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                });
              } else if (isFunction(settings.sortSelect)) {
                values.sort(settings.sortSelect);
              }
              select[fields.values] = values;
              module.debug("Retrieved and sorted values from select", select);
            } else {
              select[fields.values] = values;
              module.debug("Retrieved values from select", select);
            }
            return select;
          },
          activeItem: function() {
            return $item.filter("." + className.active);
          },
          selectedItem: function() {
            var $selectedItem = $item.not(selector.unselectable).filter("." + className.selected);
            return $selectedItem.length > 0 ? $selectedItem : $item.eq(0);
          },
          itemWithAdditions: function(value) {
            var $items = module.get.item(value), $userItems = module.create.userChoice(value), hasUserItems = $userItems && $userItems.length > 0;
            if (hasUserItems) {
              $items = $items.length > 0 ? $items.add($userItems) : $userItems;
            }
            return $items;
          },
          item: function(value, strict) {
            var $selectedItem = false, shouldSearch, isMultiple;
            value = value !== void 0 ? value : module.get.values() !== void 0 ? module.get.values() : module.get.text();
            isMultiple = module.is.multiple() && Array.isArray(value);
            shouldSearch = isMultiple ? value.length > 0 : value !== void 0 && value !== null;
            strict = value === "" || value === false || value === true ? true : strict || false;
            if (shouldSearch) {
              $item.each(function() {
                var $choice = $(this), optionText = module.get.choiceText($choice), optionValue = module.get.choiceValue($choice, optionText);
                if (optionValue === null || optionValue === void 0) {
                  return;
                }
                if (isMultiple) {
                  if ($.inArray(module.escape.htmlEntities(String(optionValue)), value.map(String)) !== -1) {
                    $selectedItem = $selectedItem ? $selectedItem.add($choice) : $choice;
                  }
                } else if (strict) {
                  module.verbose("Ambiguous dropdown value using strict type check", $choice, value);
                  if (optionValue === value) {
                    $selectedItem = $choice;
                    return true;
                  }
                } else {
                  if (settings.ignoreCase) {
                    optionValue = optionValue.toLowerCase();
                    value = value.toLowerCase();
                  }
                  if (module.escape.htmlEntities(String(optionValue)) === module.escape.htmlEntities(String(value))) {
                    module.verbose("Found select item by value", optionValue, value);
                    $selectedItem = $choice;
                    return true;
                  }
                }
              });
            }
            return $selectedItem;
          },
          displayType: function() {
            return $module.hasClass("column") ? "flex" : settings.displayType;
          }
        },
        check: {
          maxSelections: function(selectionCount) {
            if (settings.maxSelections) {
              selectionCount = selectionCount !== void 0 ? selectionCount : module.get.selectionCount();
              if (selectionCount >= settings.maxSelections) {
                module.debug("Maximum selection count reached");
                if (settings.useLabels) {
                  $item.addClass(className.filtered);
                  module.add.message(message.maxSelections);
                }
                return true;
              }
              module.verbose("No longer at maximum selection count");
              module.remove.message();
              module.remove.filteredItem();
              if (module.is.searchSelection()) {
                module.filterItems();
              }
              return false;
            }
            return true;
          },
          disabled: function() {
            $search.attr("tabindex", module.is.disabled() ? -1 : 0);
          }
        },
        restore: {
          defaults: function(preventChangeTrigger) {
            module.clear(preventChangeTrigger);
            module.restore.defaultText();
            module.restore.defaultValue();
          },
          defaultText: function() {
            var defaultText = module.get.defaultText(), placeholderText = module.get.placeholderText;
            if (defaultText === placeholderText) {
              module.debug("Restoring default placeholder text", defaultText);
              module.set.placeholderText(defaultText);
            } else {
              module.debug("Restoring default text", defaultText);
              module.set.text(defaultText);
            }
          },
          placeholderText: function() {
            module.set.placeholderText();
          },
          defaultValue: function() {
            var defaultValue = module.get.defaultValue();
            if (defaultValue !== void 0) {
              module.debug("Restoring default value", defaultValue);
              if (defaultValue !== "") {
                module.set.value(defaultValue);
                module.set.selected();
              } else {
                module.remove.activeItem();
                module.remove.selectedItem();
              }
            }
          },
          labels: function() {
            if (settings.allowAdditions) {
              if (!settings.useLabels) {
                module.error(error.labels);
                settings.useLabels = true;
              }
              module.debug("Restoring selected values");
              module.create.userLabels();
            }
            module.check.maxSelections();
          },
          selected: function() {
            module.restore.values();
            if (module.is.multiple()) {
              module.debug("Restoring previously selected values and labels");
              module.restore.labels();
            } else {
              module.debug("Restoring previously selected values");
            }
          },
          values: function() {
            module.set.initialLoad();
            if (settings.apiSettings && settings.saveRemoteData && module.get.remoteValues()) {
              module.restore.remoteValues();
            } else {
              module.set.selected();
            }
            var value = module.get.value();
            if (value && value !== "" && !(Array.isArray(value) && value.length === 0)) {
              $input.removeClass(className.noselection);
            } else {
              $input.addClass(className.noselection);
            }
            module.remove.initialLoad();
          },
          remoteValues: function() {
            var values = module.get.remoteValues();
            module.debug("Recreating selected from session data", values);
            if (values) {
              if (module.is.single()) {
                $.each(values, function(value, name) {
                  module.set.text(name);
                });
              } else {
                $.each(values, function(value, name) {
                  module.add.label(value, name);
                });
              }
            }
          }
        },
        read: {
          remoteData: function(value) {
            var name;
            if (window2.Storage === void 0) {
              module.error(error.noStorage);
              return;
            }
            name = sessionStorage.getItem(value + elementNamespace);
            return name !== void 0 ? name : false;
          }
        },
        save: {
          defaults: function() {
            module.save.defaultText();
            module.save.placeholderText();
            module.save.defaultValue();
          },
          defaultValue: function() {
            var value = module.get.value();
            module.verbose("Saving default value as", value);
            $module.data(metadata.defaultValue, value);
          },
          defaultText: function() {
            var text = module.get.text();
            module.verbose("Saving default text as", text);
            $module.data(metadata.defaultText, text);
          },
          placeholderText: function() {
            var text;
            if (settings.placeholder !== false && $text.hasClass(className.placeholder)) {
              text = module.get.text();
              module.verbose("Saving placeholder text as", text);
              $module.data(metadata.placeholderText, text);
            }
          },
          remoteData: function(name, value) {
            if (window2.Storage === void 0) {
              module.error(error.noStorage);
              return;
            }
            module.verbose("Saving remote data to session storage", value, name);
            sessionStorage.setItem(value + elementNamespace, name);
          }
        },
        clear: function(preventChangeTrigger) {
          if (module.is.multiple() && settings.useLabels) {
            module.remove.labels($module.find(selector.label), preventChangeTrigger);
          } else {
            module.remove.activeItem();
            module.remove.selectedItem();
            module.remove.filteredItem();
          }
          module.set.placeholderText();
          module.clearValue(preventChangeTrigger);
        },
        clearValue: function(preventChangeTrigger) {
          module.set.value("", null, null, preventChangeTrigger);
        },
        scrollPage: function(direction, $selectedItem) {
          var $currentItem = $selectedItem || module.get.selectedItem(), $menu2 = $currentItem.closest(selector.menu), menuHeight = $menu2.outerHeight(), currentScroll = $menu2.scrollTop(), itemHeight = $item.eq(0).outerHeight(), itemsPerPage = Math.floor(menuHeight / itemHeight), newScroll = direction === "up" ? currentScroll - itemHeight * itemsPerPage : currentScroll + itemHeight * itemsPerPage, $selectableItem = $item.not(selector.unselectable), isWithinRange, $nextSelectedItem, elementIndex2;
          elementIndex2 = direction === "up" ? $selectableItem.index($currentItem) - itemsPerPage : $selectableItem.index($currentItem) + itemsPerPage;
          isWithinRange = direction === "up" ? elementIndex2 >= 0 : elementIndex2 < $selectableItem.length;
          $nextSelectedItem = isWithinRange ? $selectableItem.eq(elementIndex2) : direction === "up" ? $selectableItem.first() : $selectableItem.last();
          if ($nextSelectedItem.length > 0) {
            module.debug("Scrolling page", direction, $nextSelectedItem);
            $currentItem.removeClass(className.selected);
            $nextSelectedItem.addClass(className.selected);
            if (settings.selectOnKeydown && module.is.single() && !$nextSelectedItem.hasClass(className.actionable)) {
              module.set.selectedItem($nextSelectedItem);
            }
            $menu2.scrollTop(newScroll);
          }
        },
        set: {
          filtered: function() {
            var isMultiple = module.is.multiple(), isSearch = module.is.searchSelection(), isSearchMultiple = isMultiple && isSearch, searchValue = isSearch ? module.get.query() : "", hasSearchValue = typeof searchValue === "string" && searchValue.length > 0, searchWidth = module.get.searchWidth(), valueIsSet = searchValue !== "";
            if (isMultiple && hasSearchValue) {
              module.verbose("Adjusting input width", searchWidth, settings.glyphWidth);
              $search.css("width", searchWidth + "px");
            }
            if (hasSearchValue || isSearchMultiple && valueIsSet) {
              module.verbose("Hiding placeholder text");
              $text.addClass(className.filtered);
            } else if (!isMultiple || isSearchMultiple && !valueIsSet) {
              module.verbose("Showing placeholder text");
              $text.removeClass(className.filtered);
            }
          },
          empty: function() {
            $module.addClass(className.empty);
          },
          loading: function() {
            $module.addClass(className.loading);
          },
          placeholderText: function(text) {
            text = text || module.get.placeholderText();
            module.debug("Setting placeholder text", text);
            module.set.text(text);
            $text.addClass(className.placeholder);
          },
          tabbable: function() {
            if (module.is.searchSelection()) {
              module.debug("Added tabindex to searchable dropdown");
              $search.val("");
              module.check.disabled();
              $menu.attr("tabindex", -1);
            } else {
              module.debug("Added tabindex to dropdown");
              if ($module.attr("tabindex") === void 0) {
                $module.attr("tabindex", $input.attr("tabindex") || 0);
                $menu.attr("tabindex", -1);
              }
            }
            $input.removeAttr("tabindex");
          },
          initialLoad: function() {
            module.verbose("Setting initial load");
            initialLoad = true;
          },
          activeItem: function($item2) {
            if (settings.allowAdditions && $item2.filter(selector.addition).length > 0) {
              $item2.addClass(className.filtered);
            } else {
              $item2.addClass(className.active);
            }
          },
          partialSearch: function(text) {
            var length = module.get.query().length;
            $search.val(text.slice(0, length));
          },
          scrollPosition: function($item2, forceScroll) {
            var edgeTolerance = 5, $menu2, hasActive, offset, itemOffset, menuOffset, menuScroll, menuHeight, abovePage, belowPage;
            $item2 = $item2 || module.get.selectedItem();
            $menu2 = $item2.closest(selector.menu);
            hasActive = $item2 && $item2.length > 0;
            forceScroll = forceScroll !== void 0 ? forceScroll : false;
            if (module.get.activeItem().length === 0) {
              forceScroll = false;
            }
            if ($item2 && $menu2.length > 0 && hasActive) {
              itemOffset = $item2.position().top;
              $menu2.addClass(className.loading);
              menuScroll = $menu2.scrollTop();
              menuOffset = $menu2.offset().top;
              itemOffset = $item2.offset().top;
              offset = menuScroll - menuOffset + itemOffset;
              if (!forceScroll) {
                menuHeight = $menu2.height();
                belowPage = menuScroll + menuHeight < offset + edgeTolerance;
                abovePage = offset - edgeTolerance < menuScroll;
              }
              module.debug("Scrolling to active item", offset);
              if (forceScroll || abovePage || belowPage) {
                $menu2.scrollTop(offset);
              }
              $menu2.removeClass(className.loading);
            }
          },
          text: function(text, isNotPlaceholder) {
            if (settings.action === "combo") {
              module.debug("Changing combo button text", text, $combo);
              if (settings.preserveHTML) {
                $combo.html(text);
              } else {
                $combo.text(text);
              }
            } else if (settings.action === "activate") {
              if (text !== module.get.placeholderText() || isNotPlaceholder) {
                $text.removeClass(className.placeholder);
              }
              module.debug("Changing text", text, $text);
              $text.removeClass(className.filtered);
              if (settings.preserveHTML) {
                $text.html(text);
              } else {
                $text.text(text);
              }
            }
          },
          selectedItem: function($item2) {
            var value = module.get.choiceValue($item2), searchText = module.get.choiceText($item2, false), text = module.get.choiceText($item2);
            module.debug("Setting user selection to item", $item2);
            module.remove.activeItem();
            module.set.partialSearch(searchText);
            module.set.activeItem($item2);
            module.set.selected(value, $item2);
            module.set.text(text);
          },
          selectedLetter: function(letter) {
            var $selectedItem = $item.filter("." + className.selected), alreadySelectedLetter = $selectedItem.length > 0 && module.has.firstLetter($selectedItem, letter), $nextValue = false, $nextItem;
            if (alreadySelectedLetter) {
              $nextItem = $selectedItem.nextAll($item).eq(0);
              if (module.has.firstLetter($nextItem, letter)) {
                $nextValue = $nextItem;
              }
            }
            if (!$nextValue) {
              $item.each(function() {
                if (module.has.firstLetter($(this), letter)) {
                  $nextValue = $(this);
                  return false;
                }
              });
            }
            if ($nextValue) {
              module.verbose("Scrolling to next value with letter", letter);
              module.set.scrollPosition($nextValue);
              $selectedItem.removeClass(className.selected);
              $nextValue.addClass(className.selected);
              if (settings.selectOnKeydown && module.is.single() && !$nextItem.hasClass(className.actionable)) {
                module.set.selectedItem($nextValue);
              }
            }
          },
          direction: function($menu2) {
            if (settings.direction === "auto") {
              if (!$menu2) {
                module.remove.upward();
              } else if (module.is.upward($menu2)) {
                module.remove.upward($menu2);
              }
              if (module.can.openDownward($menu2)) {
                module.remove.upward($menu2);
              } else {
                module.set.upward($menu2);
              }
              if (!module.is.leftward($menu2) && !module.can.openRightward($menu2)) {
                module.set.leftward($menu2);
              }
            } else if (settings.direction === "upward") {
              module.set.upward($menu2);
            }
          },
          upward: function($currentMenu) {
            var $element = $currentMenu || $module;
            $element.addClass(className.upward);
          },
          leftward: function($currentMenu) {
            var $element = $currentMenu || $menu;
            $element.addClass(className.leftward);
          },
          value: function(value, text, $selected, preventChangeTrigger) {
            if (typeof text === "boolean") {
              preventChangeTrigger = text;
              $selected = void 0;
              text = void 0;
            }
            if (value !== void 0 && value !== "" && !(Array.isArray(value) && value.length === 0)) {
              $input.removeClass(className.noselection);
            } else {
              $input.addClass(className.noselection);
            }
            var escapedValue = module.escape.value(value), hasInput = $input.length > 0, currentValue = module.get.values(), stringValue = value !== void 0 ? String(value) : value;
            if (hasInput) {
              if (!settings.allowReselection && stringValue == currentValue) {
                module.verbose("Skipping value update already same value", value, currentValue);
                if (!module.is.initialLoad()) {
                  return;
                }
              }
              if (module.is.single() && module.has.selectInput() && module.can.extendSelect()) {
                module.debug("Adding user option", value);
                module.add.optionValue(value);
              }
              module.debug("Updating input value", escapedValue, currentValue);
              internalChange = true;
              $input.val(escapedValue);
              if (settings.fireOnInit === false && module.is.initialLoad()) {
                module.debug("Input native change event ignored on initial load");
              } else if (preventChangeTrigger !== true) {
                module.trigger.change();
              }
              internalChange = false;
            } else {
              module.verbose("Storing value in metadata", escapedValue, $input);
              if (escapedValue !== currentValue) {
                $module.data(metadata.value, stringValue);
              }
            }
            if (settings.fireOnInit === false && module.is.initialLoad()) {
              module.verbose("No callback on initial load", settings.onChange);
            } else if (preventChangeTrigger !== true) {
              settings.onChange.call(element2, value, text, $selected);
            }
          },
          active: function() {
            $module.addClass(className.active);
          },
          multiple: function() {
            $module.addClass(className.multiple);
          },
          visible: function() {
            $module.addClass(className.visible);
          },
          exactly: function(value, $selectedItem, preventChangeTrigger) {
            if (typeof $selectedItem === "boolean") {
              preventChangeTrigger = $selectedItem;
              $selectedItem = void 0;
            }
            module.debug("Setting selected to exact values");
            module.clear();
            module.set.selected(value, $selectedItem, preventChangeTrigger);
          },
          selected: function(value, $selectedItem, preventChangeTrigger, keepSearchTerm) {
            if (typeof $selectedItem === "boolean") {
              keepSearchTerm = preventChangeTrigger;
              preventChangeTrigger = $selectedItem;
              $selectedItem = void 0;
            }
            var isMultiple = module.is.multiple();
            $selectedItem = settings.allowAdditions ? $selectedItem || module.get.itemWithAdditions(value) : $selectedItem || module.get.item(value);
            if (!$selectedItem) {
              return false;
            }
            module.debug("Setting selected menu item to", $selectedItem);
            if (module.is.multiple()) {
              module.remove.searchWidth();
            }
            if (module.is.single()) {
              module.remove.activeItem();
              module.remove.selectedItem();
            } else if (settings.useLabels) {
              module.remove.selectedItem();
            }
            $selectedItem.each(function() {
              var $selected = $(this), selectedText = module.get.choiceText($selected), selectedValue = module.get.choiceValue($selected, selectedText), isFiltered = $selected.hasClass(className.filtered), isActive = $selected.hasClass(className.active), isActionable = $selected.hasClass(className.actionable), isUserValue = $selected.hasClass(className.addition), shouldAnimate = isMultiple && $selectedItem && $selectedItem.length === 1;
              if (isActionable) {
                if ((!isMultiple || (!isActive || isUserValue)) && settings.apiSettings && settings.saveRemoteData) {
                  module.save.remoteData(selectedText, selectedValue);
                }
                settings.onActionable.call(element2, selectedValue, selectedText, $selected);
              } else if (isMultiple) {
                if (!isActive || isUserValue) {
                  if (settings.apiSettings && settings.saveRemoteData) {
                    module.save.remoteData(selectedText, selectedValue);
                  }
                  if (settings.useLabels) {
                    module.add.value(selectedValue, selectedText, $selected, preventChangeTrigger);
                    module.add.label(selectedValue, selectedText, shouldAnimate);
                    module.set.activeItem($selected);
                    module.filterActive();
                    module.select.nextAvailable($selectedItem);
                  } else {
                    module.add.value(selectedValue, selectedText, $selected, preventChangeTrigger);
                    module.set.text(module.add.variables(message.count));
                    module.set.activeItem($selected);
                  }
                } else if (!isFiltered && (settings.useLabels || selectActionActive)) {
                  module.debug("Selected active value, removing label");
                  module.remove.selected(selectedValue);
                }
              } else {
                if (settings.apiSettings && settings.saveRemoteData) {
                  module.save.remoteData(selectedText, selectedValue);
                }
                if (!keepSearchTerm && !$selected.hasClass(className.actionable)) {
                  module.set.text(selectedText, true);
                }
                module.set.value(selectedValue, selectedText, $selected, preventChangeTrigger);
                $selected.addClass(className.active).addClass(className.selected);
              }
            });
            if (!keepSearchTerm) {
              module.remove.searchTerm();
            }
            if (module.is.allFiltered()) {
              module.set.empty();
              module.hideMenu();
            }
          }
        },
        add: {
          label: function(value, text, shouldAnimate) {
            var $next = module.is.searchSelection() ? $search : $text, escapedValue = module.escape.value(value), $label;
            if (settings.ignoreCase) {
              escapedValue = escapedValue.toLowerCase();
            }
            $label = $("<a />").addClass(className.label).attr("data-" + metadata.value, escapedValue).html(templates.label(escapedValue, text, settings.preserveHTML, settings.className));
            $label = settings.onLabelCreate.call($label, escapedValue, text);
            if (module.has.label(value)) {
              module.debug("User selection already exists, skipping", escapedValue);
              return;
            }
            if (settings.label.variation) {
              $label.addClass(settings.label.variation);
            }
            if (shouldAnimate === true && settings.label.transition) {
              module.debug("Animating in label", $label);
              $label.addClass(className.hidden).insertBefore($next).transition({
                animation: settings.label.transition,
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                duration: settings.label.duration
              });
            } else {
              module.debug("Adding selection label", $label);
              $label.insertBefore($next);
            }
          },
          message: function(message2) {
            var $message = $menu.children(selector.message), html = settings.templates.message(module.add.variables(message2));
            if ($message.length > 0) {
              $message.html(html);
            } else {
              $("<div/>").html(html).addClass(className.message).appendTo($menu);
            }
          },
          optionValue: function(value) {
            var escapedValue = module.escape.value(value), $option = $input.find('option[value="' + module.escape.string(escapedValue) + '"]'), hasOption = $option.length > 0;
            if (hasOption) {
              return;
            }
            module.disconnect.selectObserver();
            if (module.is.single()) {
              module.verbose("Removing previous user addition");
              $input.find("option." + className.addition).remove();
            }
            $("<option/>").prop("value", escapedValue).addClass(className.addition).text(value).appendTo($input);
            module.verbose("Adding user addition as an <option>", value);
            module.observe.select();
          },
          userSuggestion: function(value) {
            var $addition = $menu.children(selector.addition), $existingItem = module.get.item(value), alreadyHasValue = $existingItem && $existingItem.not(selector.addition).length > 0, hasUserSuggestion = $addition.length > 0, html;
            if (settings.useLabels && module.has.maxSelections()) {
              return;
            }
            if (value === "" || alreadyHasValue) {
              $addition.remove();
              return;
            }
            if (hasUserSuggestion) {
              $addition.data(metadata.value, value).data(metadata.text, value).attr("data-" + metadata.value, value).attr("data-" + metadata.text, value).removeClass(className.filtered);
              if (!settings.hideAdditions) {
                html = settings.templates.addition(module.add.variables(message.addResult, value));
                $addition.html(html);
              }
              module.verbose("Replacing user suggestion with new value", $addition);
            } else {
              $addition = module.create.userChoice(value);
              $addition.prependTo($menu);
              module.verbose("Adding item choice to menu corresponding with user choice addition", $addition);
            }
            if (!settings.hideAdditions || module.is.allFiltered()) {
              $addition.addClass(className.selected).siblings().removeClass(className.selected);
            }
            module.refreshItems();
          },
          variables: function(message2, term) {
            var hasCount = message2.search("{count}") !== -1, hasMaxCount = message2.search("{maxCount}") !== -1, hasTerm = message2.search("{term}") !== -1, query2;
            module.verbose("Adding templated variables to message", message2);
            if (hasCount) {
              message2 = message2.replace("{count}", module.get.selectionCount());
            }
            if (hasMaxCount) {
              message2 = message2.replace("{maxCount}", settings.maxSelections);
            }
            if (hasTerm) {
              query2 = term || module.get.query();
              message2 = message2.replace("{term}", query2);
            }
            return message2;
          },
          value: function(addedValue, addedText, $selectedItem, preventChangeTrigger) {
            if (typeof addedText === "boolean") {
              preventChangeTrigger = addedText;
              $selectedItem = void 0;
              addedText = void 0;
            }
            var currentValue = module.get.values(true), newValue;
            if (module.has.value(addedValue)) {
              module.debug("Value already selected");
              return;
            }
            if (addedValue === "") {
              module.debug("Cannot select blank values from multiselect");
              return;
            }
            if (Array.isArray(currentValue)) {
              newValue = $selectedItem && $selectedItem.hasClass(className.actionable) ? currentValue : currentValue.concat([addedValue]);
              newValue = module.get.uniqueArray(newValue);
            } else {
              newValue = [addedValue];
            }
            if (module.has.selectInput()) {
              if (module.can.extendSelect()) {
                module.debug("Adding value to select", addedValue, newValue, $input);
                module.add.optionValue(addedValue);
              }
            } else {
              newValue = newValue.join(settings.delimiter);
              module.debug("Setting hidden input to delimited value", newValue, $input);
            }
            if (settings.fireOnInit === false && module.is.initialLoad()) {
              module.verbose("Skipping onadd callback on initial load", settings.onAdd);
            } else {
              settings.onAdd.call(element2, addedValue, addedText, $selectedItem);
            }
            module.set.value(newValue, addedText, $selectedItem, preventChangeTrigger);
            module.check.maxSelections();
          }
        },
        remove: {
          active: function() {
            $module.removeClass(className.active);
          },
          activeLabel: function() {
            $module.find(selector.label).removeClass(className.active);
          },
          empty: function() {
            $module.removeClass(className.empty);
          },
          loading: function() {
            $module.removeClass(className.loading);
          },
          initialLoad: function() {
            initialLoad = false;
          },
          upward: function($currentMenu) {
            var $element = $currentMenu || $module;
            $element.removeClass(className.upward);
          },
          leftward: function($currentMenu) {
            var $element = $currentMenu || $menu;
            $element.removeClass(className.leftward);
          },
          visible: function() {
            $module.removeClass(className.visible);
          },
          activeItem: function() {
            $item.removeClass(className.active);
          },
          filteredItem: function() {
            if (settings.useLabels && module.has.maxSelections()) {
              return;
            }
            if (settings.useLabels && module.is.multiple()) {
              $item.not("." + className.active).removeClass(className.filtered);
            } else {
              $item.removeClass(className.filtered);
            }
            if (settings.hideDividers) {
              $divider.removeClass(className.hidden);
            }
            module.remove.empty();
          },
          optionValue: function(value) {
            var escapedValue = module.escape.value(value), $option = $input.find('option[value="' + module.escape.string(escapedValue) + '"]'), hasOption = $option.length > 0;
            if (!hasOption || !$option.hasClass(className.addition)) {
              return;
            }
            module.disconnect.selectObserver();
            $option.remove();
            module.verbose("Removing user addition as an <option>", escapedValue);
            module.observe.select();
          },
          message: function() {
            $menu.children(selector.message).remove();
          },
          searchWidth: function() {
            $search.css("width", "");
          },
          searchTerm: function() {
            module.verbose("Cleared search term");
            $search.val("");
            module.set.filtered();
          },
          userAddition: function() {
            $item.filter(selector.addition).remove();
          },
          selected: function(value, $selectedItem, preventChangeTrigger) {
            $selectedItem = settings.allowAdditions ? $selectedItem || module.get.itemWithAdditions(value) : $selectedItem || module.get.item(value);
            if (!$selectedItem) {
              return false;
            }
            $selectedItem.each(function() {
              var $selected = $(this), selectedText = module.get.choiceText($selected), selectedValue = module.get.choiceValue($selected, selectedText);
              if (module.is.multiple()) {
                if (settings.useLabels) {
                  module.remove.value(selectedValue, selectedText, $selected, preventChangeTrigger);
                  module.remove.label(selectedValue);
                } else {
                  module.remove.value(selectedValue, selectedText, $selected, preventChangeTrigger);
                  if (module.get.selectionCount() === 0) {
                    module.set.placeholderText();
                  } else {
                    module.set.text(module.add.variables(message.count));
                  }
                }
              } else {
                module.remove.value(selectedValue, selectedText, $selected, preventChangeTrigger);
              }
              $selected.removeClass(className.filtered).removeClass(className.active);
              if (settings.useLabels) {
                $selected.removeClass(className.selected);
              }
            });
          },
          selectedItem: function() {
            $item.removeClass(className.selected);
          },
          value: function(removedValue, removedText, $removedItem, preventChangeTrigger) {
            var values = module.get.values(true), newValue;
            if (module.has.selectInput()) {
              module.verbose("Input is <select> removing selected option", removedValue);
              newValue = module.remove.arrayValue(removedValue, values);
              module.remove.optionValue(removedValue);
            } else {
              module.verbose("Removing from delimited values", removedValue);
              newValue = module.remove.arrayValue(removedValue, values);
              newValue = newValue.join(settings.delimiter);
            }
            if (settings.fireOnInit === false && module.is.initialLoad()) {
              module.verbose("No callback on initial load", settings.onRemove);
            } else {
              settings.onRemove.call(element2, removedValue, removedText, $removedItem);
            }
            module.set.value(newValue, removedText, $removedItem, preventChangeTrigger);
            module.check.maxSelections();
          },
          arrayValue: function(removedValue, values) {
            if (!Array.isArray(values)) {
              values = [values];
            }
            values = $.grep(values, function(value) {
              return removedValue != value;
            });
            module.verbose("Removed value from delimited string", removedValue, values);
            return values;
          },
          label: function(value, shouldAnimate) {
            var escapedValue = module.escape.value(value), $labels = $module.find(selector.label), $removedLabel = $labels.filter("[data-" + metadata.value + '="' + module.escape.string(settings.ignoreCase ? escapedValue.toLowerCase() : escapedValue) + '"]');
            module.verbose("Removing label", $removedLabel);
            $removedLabel.remove();
          },
          activeLabels: function($activeLabels) {
            $activeLabels = $activeLabels || $module.find(selector.label).filter("." + className.active);
            module.verbose("Removing active label selections", $activeLabels);
            module.remove.labels($activeLabels);
          },
          labels: function($labels, preventChangeTrigger) {
            $labels = $labels || $module.find(selector.label);
            module.verbose("Removing labels", $labels);
            $labels.each(function() {
              var $label = $(this), value = $label.data(metadata.value), stringValue = value !== void 0 ? String(value) : value, isUserValue = module.is.userValue(stringValue);
              if (settings.onLabelRemove.call($label, value) === false) {
                module.debug("Label remove callback cancelled removal");
                return;
              }
              module.remove.message();
              if (isUserValue) {
                module.remove.value(stringValue, stringValue, module.get.item(stringValue), preventChangeTrigger);
                module.remove.label(stringValue);
              } else {
                module.remove.selected(stringValue, false, preventChangeTrigger);
              }
            });
          },
          tabbable: function() {
            if (module.is.searchSelection()) {
              module.debug("Searchable dropdown initialized");
              $search.removeAttr("tabindex");
              $menu.removeAttr("tabindex");
            } else {
              module.debug("Simple selection dropdown initialized");
              $module.removeAttr("tabindex");
              $menu.removeAttr("tabindex");
            }
          },
          diacritics: function(text) {
            return settings.ignoreDiacritics ? text.normalize("NFD").replace(/[\u0300-\u036F]/g, "") : text;
          }
        },
        has: {
          menuSearch: function() {
            return module.has.search() && $search.closest($menu).length > 0;
          },
          clearItem: function() {
            return $clear.length > 0;
          },
          search: function() {
            return $search.length > 0;
          },
          sizer: function() {
            return $sizer.length > 0;
          },
          selectInput: function() {
            return $input.is("select");
          },
          minCharacters: function(searchTerm) {
            if (settings.minCharacters && !iconClicked) {
              searchTerm = searchTerm !== void 0 ? String(searchTerm) : String(module.get.query());
              return searchTerm.length >= settings.minCharacters;
            }
            iconClicked = false;
            return true;
          },
          firstLetter: function($item2, letter) {
            var text, firstLetter;
            if (!$item2 || $item2.length === 0 || typeof letter !== "string") {
              return false;
            }
            text = module.get.choiceText($item2, false);
            letter = letter.toLowerCase();
            firstLetter = String(text).charAt(0).toLowerCase();
            return letter == firstLetter;
          },
          input: function() {
            return $input.length > 0;
          },
          items: function() {
            return $item.length > 0;
          },
          menu: function() {
            return $menu.length > 0;
          },
          subMenu: function($currentMenu) {
            return ($currentMenu || $menu).find(selector.menu).length > 0;
          },
          message: function() {
            return $menu.children(selector.message).length > 0;
          },
          label: function(value) {
            var escapedValue = module.escape.value(value), $labels = $module.find(selector.label);
            if (settings.ignoreCase) {
              escapedValue = escapedValue.toLowerCase();
            }
            return $labels.filter("[data-" + metadata.value + '="' + module.escape.string(escapedValue) + '"]').length > 0;
          },
          maxSelections: function() {
            return settings.maxSelections && module.get.selectionCount() >= settings.maxSelections;
          },
          allResultsFiltered: function() {
            var $normalResults = $item.not(selector.addition);
            return $normalResults.filter(selector.unselectable).length === $normalResults.length;
          },
          userSuggestion: function() {
            return $menu.children(selector.addition).length > 0;
          },
          query: function() {
            return module.get.query() !== "";
          },
          value: function(value) {
            return settings.ignoreCase ? module.has.valueIgnoringCase(value) : module.has.valueMatchingCase(value);
          },
          valueMatchingCase: function(value) {
            var values = module.get.values(true), hasValue = Array.isArray(values) ? values && $.inArray(value, values) !== -1 : values == value;
            return !!hasValue;
          },
          valueIgnoringCase: function(value) {
            var values = module.get.values(true), hasValue = false;
            if (!Array.isArray(values)) {
              values = [values];
            }
            $.each(values, function(index, existingValue) {
              if (String(value).toLowerCase() === String(existingValue).toLowerCase()) {
                hasValue = true;
                return false;
              }
            });
            return hasValue;
          }
        },
        is: {
          active: function() {
            return $module.hasClass(className.active);
          },
          animatingInward: function() {
            return $menu.transition("is inward");
          },
          animatingOutward: function() {
            return $menu.transition("is outward");
          },
          bubbledLabelClick: function(event2) {
            return $(event2.target).is("select, input") && $module.closest("label").length > 0;
          },
          bubbledIconClick: function(event2) {
            return $(event2.target).closest($icon).length > 0;
          },
          edge: function() {
            return !!window2.chrome && !!window2.StyleMedia;
          },
          empty: function() {
            return $module.hasClass(className.empty);
          },
          chrome: function() {
            return !!window2.chrome && !window2.StyleMedia;
          },
          alreadySetup: function() {
            return $module.is("select") && $module.parent(selector.dropdown).data(moduleNamespace) !== void 0 && $module.prev().length === 0;
          },
          animating: function($subMenu) {
            return $subMenu ? $subMenu.transition && $subMenu.transition("is animating") : $menu.transition && $menu.transition("is animating");
          },
          leftward: function($subMenu) {
            var $selectedMenu = $subMenu || $menu;
            return $selectedMenu.hasClass(className.leftward);
          },
          clearable: function() {
            return $module.hasClass(className.clearable) || settings.clearable;
          },
          disabled: function() {
            return $module.hasClass(className.disabled);
          },
          focused: function() {
            return document2.activeElement === $module[0];
          },
          focusedOnSearch: function() {
            return document2.activeElement === $search[0];
          },
          allFiltered: function() {
            return (module.is.multiple() || module.has.search()) && !(!settings.hideAdditions && module.has.userSuggestion()) && !module.has.message() && module.has.allResultsFiltered();
          },
          hidden: function($subMenu) {
            return !module.is.visible($subMenu);
          },
          initialLoad: function() {
            return initialLoad;
          },
          inObject: function(needle, object) {
            var found = false;
            $.each(object, function(index, property) {
              if (property == needle) {
                found = true;
                return true;
              }
            });
            return found;
          },
          multiple: function() {
            return $module.hasClass(className.multiple);
          },
          remote: function() {
            return settings.apiSettings && module.can.useAPI();
          },
          noApiCache: function() {
            return settings.apiSettings && !settings.apiSettings.cache;
          },
          single: function() {
            return !module.is.multiple();
          },
          selectMutation: function(mutations) {
            var selectChanged = false;
            $.each(mutations, function(index, mutation) {
              if ($(mutation.target).is("select, option, optgroup") || $(mutation.addedNodes).is("select")) {
                selectChanged = true;
                return false;
              }
            });
            return selectChanged;
          },
          search: function() {
            return $module.hasClass(className.search);
          },
          searchSelection: function(deep) {
            return module.has.search() && (deep ? $search.parents(selector.dropdown) : $search.parent(selector.dropdown)).length === 1;
          },
          selection: function() {
            return $module.hasClass(className.selection);
          },
          userValue: function(value) {
            return $.inArray(value, module.get.userValues()) !== -1;
          },
          upward: function($menu2) {
            var $element = $menu2 || $module;
            return $element.hasClass(className.upward);
          },
          visible: function($subMenu) {
            return $subMenu ? $subMenu.hasClass(className.visible) : $menu.hasClass(className.visible);
          },
          verticallyScrollableContext: function() {
            var overflowY = $context[0] !== window2 ? $context.css("overflow-y") : false;
            return overflowY === "auto" || overflowY === "scroll";
          },
          horizontallyScrollableContext: function() {
            var overflowX = $context[0] !== window2 ? $context.css("overflow-X") : false;
            return overflowX === "auto" || overflowX === "scroll";
          }
        },
        can: {
          activate: function($item2) {
            return settings.useLabels || !module.has.maxSelections() || module.has.maxSelections() && $item2.hasClass(className.active);
          },
          openDownward: function($subMenu) {
            var $currentMenu = $subMenu || $menu, canOpenDownward, onScreen, calculations;
            $currentMenu.addClass(className.loading);
            calculations = {
              context: {
                offset: $context[0] === window2 ? { top: 0, left: 0 } : $context.offset(),
                scrollTop: $context.scrollTop(),
                height: $context.outerHeight()
              },
              menu: {
                offset: $currentMenu.offset(),
                height: $currentMenu.outerHeight()
              }
            };
            if (module.is.verticallyScrollableContext()) {
              calculations.menu.offset.top += calculations.context.scrollTop;
            }
            if (module.has.subMenu($currentMenu)) {
              calculations.menu.height += $currentMenu.find(selector.menu).first().outerHeight();
            }
            onScreen = {
              above: calculations.context.scrollTop <= calculations.menu.offset.top - calculations.context.offset.top - calculations.menu.height,
              below: calculations.context.scrollTop + calculations.context.height >= calculations.menu.offset.top - calculations.context.offset.top + calculations.menu.height
            };
            if (onScreen.below) {
              module.verbose("Dropdown can fit in context downward", onScreen);
              canOpenDownward = true;
            } else if (!onScreen.below && !onScreen.above) {
              module.verbose("Dropdown cannot fit in either direction, favoring downward", onScreen);
              canOpenDownward = true;
            } else {
              module.verbose("Dropdown cannot fit below, opening upward", onScreen);
              canOpenDownward = false;
            }
            $currentMenu.removeClass(className.loading);
            return canOpenDownward;
          },
          openRightward: function($subMenu) {
            var $currentMenu = $subMenu || $menu, canOpenRightward = true, isOffscreenRight = false, calculations;
            $currentMenu.addClass(className.loading);
            calculations = {
              context: {
                offset: $context[0] === window2 ? { top: 0, left: 0 } : $context.offset(),
                scrollLeft: $context.scrollLeft(),
                width: $context.outerWidth()
              },
              menu: {
                offset: $currentMenu.offset(),
                width: $currentMenu.outerWidth()
              }
            };
            if (module.is.horizontallyScrollableContext()) {
              calculations.menu.offset.left += calculations.context.scrollLeft;
            }
            isOffscreenRight = calculations.menu.offset.left - calculations.context.offset.left + calculations.menu.width >= calculations.context.scrollLeft + calculations.context.width;
            if (isOffscreenRight) {
              module.verbose("Dropdown cannot fit in context rightward", isOffscreenRight);
              canOpenRightward = false;
            }
            $currentMenu.removeClass(className.loading);
            return canOpenRightward;
          },
          extendSelect: function() {
            return settings.allowAdditions || settings.apiSettings;
          },
          show: function() {
            return !module.is.disabled() && (module.has.items() || module.has.message());
          },
          useAPI: function() {
            return $.fn.api !== void 0;
          },
          useElement: function(element3) {
            if ($.fn[element3] !== void 0) {
              return true;
            }
            module.error(error.noElement.replace("{element}", element3));
            return false;
          }
        },
        animate: {
          show: function(callback, $subMenu) {
            var $currentMenu = $subMenu || $menu, start = $subMenu ? function() {
            } : function() {
              module.hideSubMenus();
              module.hideOthers();
              module.set.active();
            }, transition;
            callback = isFunction(callback) ? callback : function() {
            };
            module.verbose("Doing menu show animation", $currentMenu);
            module.set.direction($subMenu);
            transition = settings.transition.showMethod || module.get.transition($subMenu);
            if (module.is.selection()) {
              module.set.scrollPosition(module.get.selectedItem(), true);
            }
            if (module.is.hidden($currentMenu) || module.is.animating($currentMenu)) {
              if (transition === "none") {
                start();
                $currentMenu.transition({
                  displayType: module.get.displayType()
                }).transition("show");
                callback.call(element2);
              } else if (module.can.useElement("transition")) {
                $currentMenu.transition({
                  animation: transition + " in",
                  debug: settings.debug,
                  verbose: settings.verbose,
                  silent: settings.silent,
                  duration: settings.transition.showDuration || settings.duration,
                  queue: true,
                  onStart: start,
                  displayType: module.get.displayType(),
                  onComplete: function() {
                    callback.call(element2);
                  }
                });
              }
            }
          },
          hide: function(callback, $subMenu) {
            var $currentMenu = $subMenu || $menu, start = $subMenu ? function() {
            } : function() {
              module.unbind.intent();
              module.remove.active();
            }, transition = settings.transition.hideMethod || module.get.transition($subMenu);
            callback = isFunction(callback) ? callback : function() {
            };
            if (module.is.visible($currentMenu) || module.is.animating($currentMenu)) {
              module.verbose("Doing menu hide animation", $currentMenu);
              if (transition === "none") {
                start();
                $currentMenu.transition({
                  displayType: module.get.displayType()
                }).transition("hide");
                callback.call(element2);
              } else if ($.fn.transition !== void 0) {
                $currentMenu.transition({
                  animation: transition + " out",
                  duration: settings.transition.hideDuration || settings.duration,
                  debug: settings.debug,
                  verbose: settings.verbose,
                  silent: settings.silent,
                  queue: false,
                  onStart: start,
                  displayType: module.get.displayType(),
                  onComplete: function() {
                    callback.call(element2);
                  }
                });
              } else {
                module.error(error.transition);
              }
            }
          }
        },
        hideAndClear: function() {
          module.remove.searchTerm();
          if (module.has.maxSelections()) {
            return;
          }
          if (module.has.search()) {
            module.hide(function() {
              module.remove.filteredItem();
            });
          } else {
            module.hide();
          }
        },
        delay: {
          show: function() {
            module.verbose("Delaying show event to ensure user intent");
            clearTimeout(module.timer);
            module.timer = setTimeout(module.show, settings.delay.show);
          },
          hide: function() {
            module.verbose("Delaying hide event to ensure user intent");
            clearTimeout(module.timer);
            module.timer = setTimeout(module.hide, settings.delay.hide);
          }
        },
        escape: {
          value: function(value) {
            var multipleValues = Array.isArray(value), stringValue = typeof value === "string", isUnparsable = !stringValue && !multipleValues, hasQuotes = stringValue && value.search(regExp.quote) !== -1, values = [];
            if (isUnparsable || !hasQuotes) {
              return value;
            }
            module.debug("Encoding quote values for use in select", value);
            if (multipleValues) {
              $.each(value, function(index, value2) {
                values.push(value2.replace(regExp.quote, "&quot;"));
              });
              return values;
            }
            return value.replace(regExp.quote, "&quot;");
          },
          string: function(text) {
            text = String(text);
            return text.replace(regExp.escape, "\\$&");
          },
          htmlEntities: function(string) {
            var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#x27;",
              "`": "&#x60;"
            }, escapedChar = function(chr) {
              return escape2[chr];
            };
            if (shouldEscape.test(string)) {
              string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
              return string.replace(badChars, escapedChar);
            }
            return string;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message2) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message2[0],
                Arguments: [].slice.call(message2, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : $allModules;
  };
  $.fn.dropdown.settings = {
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    on: "click",
    // what event should show menu action on item selection
    action: "activate",
    // action on item selection (nothing, activate, select, combo, hide, function(){})
    values: false,
    // specify values to use for dropdown
    clearable: false,
    // whether the value of the dropdown can be cleared
    apiSettings: false,
    selectOnKeydown: true,
    // Whether selection should occur automatically when keyboard shortcuts used
    minCharacters: 0,
    // Minimum characters required to trigger API call
    filterRemoteData: false,
    // Whether API results should be filtered after being returned for query term
    saveRemoteData: true,
    // Whether remote name/value pairs should be stored in sessionStorage to allow remote data to be restored on page refresh
    throttle: 200,
    // How long to wait after last user input to search remotely
    context: window2,
    // Context to use when determining if on screen
    direction: "auto",
    // Whether dropdown should always open in one direction
    keepOnScreen: true,
    // Whether dropdown should check whether it is on screen before showing
    match: "both",
    // what to match against with search selection (both, text, or label)
    fullTextSearch: "exact",
    // search anywhere in value (set to 'exact' to require exact matches)
    ignoreDiacritics: false,
    // match results also if they contain diacritics of the same base character (for example searching for "a" will also match "" or "" or "", etc...)
    hideDividers: false,
    // Whether to hide any divider elements (specified in selector.divider) that are sibling to any items when searched (set to true will hide all dividers, set to 'empty' will hide them when they are not followed by a visible item)
    placeholder: "auto",
    // whether to convert blank <select> values to placeholder text
    preserveHTML: true,
    // preserve html when selecting value
    sortSelect: false,
    // sort selection on init
    forceSelection: false,
    // force a choice on blur with search selection
    allowAdditions: false,
    // whether multiple select should allow user added values
    ignoreCase: false,
    // whether to consider case sensitivity when creating labels
    ignoreSearchCase: true,
    // whether to consider case sensitivity when filtering items
    hideAdditions: true,
    // whether or not to hide special message prompting a user they can enter a value
    maxSelections: false,
    // When set to a number limits the number of selections to this count
    useLabels: true,
    // whether multiple select should filter currently active selections from choices
    delimiter: ",",
    // when multiselect uses normal <input> the values will be delimited with this character
    showOnFocus: false,
    // show menu on focus
    allowReselection: false,
    // whether current value should trigger callbacks when reselected
    allowTab: true,
    // add tabindex to element
    allowCategorySelection: false,
    // allow elements with sub-menus to be selected
    fireOnInit: false,
    // Whether callbacks should fire when initializing dropdown values
    transition: "auto",
    // auto transition will slide down or up based on direction
    duration: 200,
    // duration of transition
    displayType: false,
    // displayType of transition
    glyphWidth: 1.037,
    // widest glyph width in em (W is 1.037 em) used to calculate multiselect input width
    headerDivider: true,
    // whether option headers should have an additional divider line underneath when converted from <select> <optgroup>
    collapseOnActionable: true,
    // whether the dropdown should collapse upon selection of an actionable item
    // label settings on multi-select
    label: {
      transition: "scale",
      duration: 200,
      variation: false
    },
    // delay before event
    delay: {
      hide: 300,
      show: 200,
      search: 20
    },
    /* Callbacks */
    onChange: function(value, text, $selected) {
    },
    onAdd: function(value, text, $selected) {
    },
    onRemove: function(value, text, $selected) {
    },
    onActionable: function(value, text, $selected) {
    },
    onSearch: function(searchTerm) {
    },
    onLabelSelect: function($selectedLabels) {
    },
    onLabelCreate: function(value, text) {
      return $(this);
    },
    onLabelRemove: function(value) {
      return true;
    },
    onNoResults: function(searchTerm) {
      return true;
    },
    onShow: function() {
    },
    onHide: function() {
    },
    /* Component */
    name: "Dropdown",
    namespace: "dropdown",
    message: {
      addResult: "Add <b>{term}</b>",
      count: "{count} selected",
      maxSelections: "Max {maxCount} selections",
      noResults: "No results found.",
      serverError: "There was an error contacting the server"
    },
    error: {
      action: "You called a dropdown action that was not defined",
      alreadySetup: "Once a select has been initialized behaviors must be called on the created ui dropdown",
      labels: "Allowing user additions currently requires the use of labels.",
      missingMultiple: "<select> requires multiple property to be set to correctly preserve multiple values",
      method: "The method you called is not defined.",
      noAPI: "The API module is required to load resources remotely",
      noStorage: "Saving remote data requires session storage",
      noElement: "This module requires ui {element}",
      noNormalize: '"ignoreDiacritics" setting will be ignored. Browser does not support String().normalize(). You may consider including <https://cdn.jsdelivr.net/npm/unorm@1.4.1/lib/unorm.min.js> as a polyfill.'
    },
    regExp: {
      escape: /[\s#$()*+,.:=?@[\\\]^{|}-]/g,
      quote: /"/g
    },
    metadata: {
      defaultText: "defaultText",
      defaultValue: "defaultValue",
      placeholderText: "placeholder",
      text: "text",
      value: "value"
    },
    // property names for remote query
    fields: {
      remoteValues: "results",
      // grouping for api results
      values: "values",
      // grouping for all dropdown values
      disabled: "disabled",
      // whether value should be disabled
      name: "name",
      // displayed dropdown text
      description: "description",
      // displayed dropdown description
      descriptionVertical: "descriptionVertical",
      // whether description should be vertical
      value: "value",
      // actual dropdown value
      text: "text",
      // displayed text when selected
      type: "type",
      // type of dropdown element
      image: "image",
      // optional image path
      imageClass: "imageClass",
      // optional individual class for image
      icon: "icon",
      // optional icon name
      iconClass: "iconClass",
      // optional individual class for icon (for example to use flag instead)
      class: "class",
      // optional individual class for item/header
      divider: "divider",
      // optional divider append for group headers
      actionable: "actionable"
      // optional actionable item
    },
    keys: {
      backspace: 8,
      deleteKey: 46,
      enter: 13,
      escape: 27,
      pageUp: 33,
      pageDown: 34,
      leftArrow: 37,
      upArrow: 38,
      rightArrow: 39,
      downArrow: 40
    },
    selector: {
      addition: ".addition",
      divider: ".divider, .header",
      dropdown: ".ui.dropdown",
      hidden: ".hidden",
      icon: "> .dropdown.icon",
      input: '> input[type="hidden"], > select',
      item: ".item",
      label: "> .label",
      remove: "> .label > .delete.icon",
      siblingLabel: ".label",
      menu: ".menu",
      message: ".message",
      menuIcon: ".dropdown.icon",
      search: "input.search, .menu > .search > input, .menu input.search",
      sizer: "> span.sizer",
      text: "> .text:not(.icon)",
      unselectable: ".disabled, .filtered",
      clearIcon: "> .remove.icon"
    },
    className: {
      active: "active",
      addition: "addition",
      animating: "animating",
      description: "description",
      descriptionVertical: "vertical",
      disabled: "disabled",
      empty: "empty",
      dropdown: "ui dropdown",
      filtered: "filtered",
      hidden: "hidden transition",
      icon: "icon",
      image: "image",
      item: "item",
      label: "ui label",
      loading: "loading",
      menu: "menu",
      message: "message",
      multiple: "multiple",
      placeholder: "default",
      sizer: "sizer",
      search: "search",
      selected: "selected",
      selection: "selection",
      text: "text",
      upward: "upward",
      leftward: "left",
      visible: "visible",
      clearable: "clearable",
      noselection: "noselection",
      delete: "delete",
      header: "header",
      divider: "divider",
      groupIcon: "",
      unfilterable: "unfilterable",
      actionable: "actionable"
    }
  };
  $.fn.dropdown.settings.templates = {
    deQuote: function(string, encode) {
      return String(string).replace(/"/g, encode ? "&quot;" : "");
    },
    escape: function(string, preserveHTML) {
      if (preserveHTML) {
        return string;
      }
      var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      }, escapedChar = function(chr) {
        return escape2[chr];
      };
      if (shouldEscape.test(string)) {
        string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
        return string.replace(badChars, escapedChar);
      }
      return string;
    },
    // generates dropdown from select values
    dropdown: function(select, fields, preserveHTML, className) {
      var placeholder = select.placeholder || false, html = "", escape2 = $.fn.dropdown.settings.templates.escape, deQuote = $.fn.dropdown.settings.templates.deQuote;
      html += '<i class="dropdown icon"></i>';
      html += placeholder ? '<div class="default text">' + escape2(placeholder, preserveHTML) + "</div>" : '<div class="text"></div>';
      html += '<div class="' + deQuote(className.menu) + '">';
      html += $.fn.dropdown.settings.templates.menu(select, fields, preserveHTML, className);
      html += "</div>";
      return html;
    },
    // generates just menu from select
    menu: function(response, fields, preserveHTML, className) {
      var values = response[fields.values] || [], html = "", escape2 = $.fn.dropdown.settings.templates.escape, deQuote = $.fn.dropdown.settings.templates.deQuote;
      $.each(values, function(index, option) {
        var itemType = option[fields.type] || "item", isMenu = itemType.indexOf("menu") !== -1;
        if (itemType === "item" || isMenu) {
          var maybeText = option[fields.text] ? ' data-text="' + deQuote(option[fields.text], true) + '"' : "", maybeActionable = option[fields.actionable] ? className.actionable + " " : "", maybeDisabled = option[fields.disabled] ? className.disabled + " " : "", maybeDescriptionVertical = option[fields.descriptionVertical] ? className.descriptionVertical + " " : "", hasDescription = escape2(option[fields.description] || "", preserveHTML) !== "";
          html += '<div class="' + deQuote(maybeActionable + maybeDisabled + maybeDescriptionVertical + (option[fields.class] || className.item)) + '" data-value="' + deQuote(option[fields.value], true) + '"' + maybeText + ">";
          if (isMenu) {
            html += '<i class="' + (itemType.indexOf("left") !== -1 ? "left" : "") + ' dropdown icon"></i>';
          }
          if (option[fields.image]) {
            html += '<img class="' + deQuote(option[fields.imageClass] || className.image) + '" src="' + deQuote(option[fields.image]) + '">';
          }
          if (option[fields.icon]) {
            html += '<i class="' + deQuote(option[fields.icon] + " " + (option[fields.iconClass] || className.icon)) + '"></i>';
          }
          if (hasDescription) {
            html += '<span class="' + deQuote(className.description) + '">' + escape2(option[fields.description] || "", preserveHTML) + "</span>";
            html += !isMenu ? '<span class="' + deQuote(className.text) + '">' : "";
          }
          if (isMenu) {
            html += '<span class="' + deQuote(className.text) + '">';
          }
          html += escape2(option[fields.name] || "", preserveHTML);
          if (isMenu) {
            html += "</span>";
            html += '<div class="' + deQuote(itemType) + '">';
            html += $.fn.dropdown.settings.templates.menu(option, fields, preserveHTML, className);
            html += "</div>";
          } else if (hasDescription) {
            html += "</span>";
          }
          html += "</div>";
        } else if (itemType === "header") {
          var groupName = escape2(option[fields.name] || "", preserveHTML), groupIcon = deQuote(option[fields.icon] || className.groupIcon);
          if (groupName !== "" || groupIcon !== "") {
            html += '<div class="' + deQuote(option[fields.class] || className.header) + '">';
            if (groupIcon !== "") {
              html += '<i class="' + deQuote(groupIcon + " " + (option[fields.iconClass] || className.icon)) + '"></i>';
            }
            html += groupName;
            html += "</div>";
          }
          if (option[fields.divider]) {
            html += '<div class="' + deQuote(className.divider) + '"></div>';
          }
        }
      });
      return html;
    },
    // generates label for multiselect
    label: function(value, text, preserveHTML, className) {
      var escape2 = $.fn.dropdown.settings.templates.escape, deQuote = $.fn.dropdown.settings.templates.deQuote;
      return escape2(text, preserveHTML) + '<i class="' + deQuote(className.delete) + ' icon"></i>';
    },
    // generates messages like "No results"
    message: function(message) {
      return message;
    },
    // generates user addition to selection menu
    addition: function(choice) {
      return choice;
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.embed = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.embed.settings, parameters) : $.extend({}, $.fn.embed.settings), selector = settings.selector, className = settings.className, sources = settings.sources, error = settings.error, metadata = settings.metadata, namespace = settings.namespace, templates = settings.templates, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $placeholder = $module.find(selector.placeholder), $icon = $module.find(selector.icon), $embed = $module.find(selector.embed), element2 = this, instance68 = $module.data(moduleNamespace), module;
      module = {
        initialize: function() {
          module.debug("Initializing embed");
          module.determine.autoplay();
          module.create();
          module.bind.events();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous instance of embed");
          module.reset();
          $module.removeData(moduleNamespace).off(eventNamespace);
        },
        refresh: function() {
          module.verbose("Refreshing selector cache");
          $placeholder = $module.find(selector.placeholder);
          $icon = $module.find(selector.icon);
          $embed = $module.find(selector.embed);
        },
        bind: {
          events: function() {
            if (module.has.placeholder()) {
              module.debug("Adding placeholder events");
              $module.on("click" + eventNamespace, selector.placeholder, module.createAndShow).on("click" + eventNamespace, selector.icon, module.createAndShow);
            }
          }
        },
        create: function() {
          var placeholder = module.get.placeholder();
          if (placeholder) {
            module.createPlaceholder();
          } else {
            module.createAndShow();
          }
        },
        createPlaceholder: function(placeholder) {
          var icon = module.get.icon();
          placeholder = placeholder || module.get.placeholder();
          $module.html(templates.placeholder(placeholder, icon));
          module.debug("Creating placeholder for embed", placeholder, icon);
        },
        createEmbed: function(url) {
          module.refresh();
          url = url || module.get.url();
          $embed = $("<div/>").addClass(className.embed).html(module.generate.embed(url)).appendTo($module);
          settings.onCreate.call(element2, url);
          module.debug("Creating embed object", $embed);
        },
        changeEmbed: function(url) {
          $embed.html(module.generate.embed(url));
        },
        createAndShow: function() {
          module.createEmbed();
          module.show();
        },
        // sets new embed
        change: function(source, id, url) {
          module.debug("Changing video to ", source, id, url);
          $module.data(metadata.source, source).data(metadata.id, id);
          if (url) {
            $module.data(metadata.url, url);
          } else {
            $module.removeData(metadata.url);
          }
          if (module.has.embed()) {
            module.changeEmbed();
          } else {
            module.create();
          }
        },
        // clears embed
        reset: function() {
          module.debug("Clearing embed and showing placeholder");
          module.remove.data();
          module.remove.active();
          module.remove.embed();
          module.showPlaceholder();
          settings.onReset.call(element2);
        },
        // shows current embed
        show: function() {
          module.debug("Showing embed");
          module.set.active();
          settings.onDisplay.call(element2);
        },
        hide: function() {
          module.debug("Hiding embed");
          module.showPlaceholder();
        },
        showPlaceholder: function() {
          module.debug("Showing placeholder image");
          module.remove.active();
          settings.onPlaceholderDisplay.call(element2);
        },
        get: {
          id: function() {
            return settings.id || $module.data(metadata.id);
          },
          placeholder: function() {
            return settings.placeholder || $module.data(metadata.placeholder);
          },
          icon: function() {
            return settings.icon || ($module.data(metadata.icon) !== void 0 ? $module.data(metadata.icon) : module.determine.icon());
          },
          source: function(url) {
            return settings.source || ($module.data(metadata.source) !== void 0 ? $module.data(metadata.source) : module.determine.source());
          },
          type: function() {
            var source = module.get.source();
            return sources[source] !== void 0 ? sources[source].type : false;
          },
          url: function() {
            return settings.url || ($module.data(metadata.url) !== void 0 ? $module.data(metadata.url) : module.determine.url());
          }
        },
        determine: {
          autoplay: function() {
            if (module.should.autoplay()) {
              settings.autoplay = true;
            }
          },
          source: function(url) {
            var matchedSource = false;
            url = url || module.get.url();
            if (url) {
              $.each(sources, function(name, source) {
                if (url.search(source.domain) !== -1) {
                  matchedSource = name;
                  return false;
                }
              });
            }
            return matchedSource;
          },
          icon: function() {
            var source = module.get.source();
            return sources[source] !== void 0 ? sources[source].icon : false;
          },
          url: function() {
            var id = settings.id || $module.data(metadata.id), source = settings.source || $module.data(metadata.source), url;
            url = sources[source] !== void 0 ? sources[source].url.replace("{id}", id) : false;
            if (url) {
              $module.data(metadata.url, url);
            }
            return url;
          }
        },
        set: {
          active: function() {
            $module.addClass(className.active);
          }
        },
        remove: {
          data: function() {
            $module.removeData(metadata.id).removeData(metadata.icon).removeData(metadata.placeholder).removeData(metadata.source).removeData(metadata.url);
          },
          active: function() {
            $module.removeClass(className.active);
          },
          embed: function() {
            $embed.empty();
          }
        },
        encode: {
          parameters: function(parameters2) {
            var urlString = [], index;
            for (index in parameters2) {
              urlString.push(encodeURIComponent(index) + "=" + encodeURIComponent(parameters2[index]));
            }
            return urlString.join("&amp;");
          }
        },
        generate: {
          embed: function(url) {
            module.debug("Generating embed html");
            var source = module.get.source(), html, parameters2;
            url = module.get.url(url);
            if (url) {
              parameters2 = module.generate.parameters(source);
              html = templates.iframe(url, parameters2);
            } else {
              module.error(error.noURL, $module);
            }
            return html;
          },
          parameters: function(source, extraParameters) {
            var parameters2 = sources[source] && sources[source].parameters !== void 0 ? sources[source].parameters(settings) : {};
            extraParameters = extraParameters || settings.parameters;
            if (extraParameters) {
              parameters2 = $.extend({}, parameters2, extraParameters);
            }
            parameters2 = settings.onEmbed(parameters2);
            return module.encode.parameters(parameters2);
          }
        },
        has: {
          embed: function() {
            return $embed.length > 0;
          },
          placeholder: function() {
            return settings.placeholder || $module.data(metadata.placeholder);
          }
        },
        should: {
          autoplay: function() {
            return settings.autoplay === "auto" ? settings.placeholder || $module.data(metadata.placeholder) !== void 0 : settings.autoplay;
          }
        },
        is: {
          video: function() {
            return module.get.type() === "video";
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.embed.settings = {
    name: "Embed",
    namespace: "embed",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    icon: false,
    source: false,
    url: false,
    id: false,
    // standard video settings
    autoplay: "auto",
    color: "#444",
    hd: true,
    brandedUI: false,
    // additional parameters to include with the embed
    parameters: false,
    onDisplay: function() {
    },
    onPlaceholderDisplay: function() {
    },
    onReset: function() {
    },
    onCreate: function(url) {
    },
    onEmbed: function(parameters) {
      return parameters;
    },
    metadata: {
      id: "id",
      icon: "icon",
      placeholder: "placeholder",
      source: "source",
      url: "url"
    },
    error: {
      noURL: "No URL specified",
      method: "The method you called is not defined"
    },
    className: {
      active: "active",
      embed: "embed"
    },
    selector: {
      embed: ".embed",
      placeholder: ".placeholder",
      icon: ".icon"
    },
    sources: {
      youtube: {
        name: "youtube",
        type: "video",
        icon: "video play",
        domain: "youtube.com",
        url: "//www.youtube.com/embed/{id}",
        parameters: function(settings) {
          return {
            autohide: !settings.brandedUI,
            autoplay: settings.autoplay,
            color: settings.color || void 0,
            hq: settings.hd,
            jsapi: settings.api,
            modestbranding: !settings.brandedUI
          };
        }
      },
      vimeo: {
        name: "vimeo",
        type: "video",
        icon: "video play",
        domain: "vimeo.com",
        url: "//player.vimeo.com/video/{id}",
        parameters: function(settings) {
          return {
            api: settings.api,
            autoplay: settings.autoplay,
            byline: settings.brandedUI,
            color: settings.color || void 0,
            portrait: settings.brandedUI,
            title: settings.brandedUI
          };
        }
      }
    },
    templates: {
      deQuote: function(string, encode) {
        return String(string).replace(/"/g, encode ? "&quot;" : "");
      },
      iframe: function(url, parameters) {
        var src = url, deQuote = $.fn.embed.settings.templates.deQuote;
        if (parameters) {
          src += "?" + parameters;
        }
        return '<iframe src="' + deQuote(src) + '" width="100%" height="100%" msallowFullScreen allowFullScreen></iframe>';
      },
      placeholder: function(image, icon) {
        var html = "", deQuote = $.fn.embed.settings.templates.deQuote;
        if (icon) {
          html += '<i class="' + deQuote(icon) + ' icon"></i>';
        }
        if (image) {
          html += '<img class="placeholder" src="' + deQuote(image) + '">';
        }
        return html;
      }
    },
    // NOT YET IMPLEMENTED
    api: false,
    onPause: function() {
    },
    onPlay: function() {
    },
    onStop: function() {
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.flyout = function(parameters) {
    var $allModules = $(this), $window = $(window2), $document = $(document2), $html = $("html"), $head = $("head"), $body = $("body"), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.flyout.settings, parameters) : $.extend({}, $.fn.flyout.settings), selector = settings.selector, className = settings.className, namespace = settings.namespace, fields = settings.fields, regExp = settings.regExp, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $body, $closeIcon = $module.find(selector.close), $inputs, $focusedElement, $flyouts = $module.children(selector.flyout), $pusher = $context.children(selector.pusher), $style, isFlyoutComponent = $module.hasClass("flyout"), element2 = this, instance68 = isFlyoutComponent ? $module.data(moduleNamespace) : void 0, ignoreRepeatedEvents = false, isBody = $context[0] === $body[0], initialBodyMargin = "", tempBodyMargin = "", hadScrollbar = false, elementNamespace, id, observer, observeAttributes = false, currentScroll, module;
      module = {
        initialize: function() {
          module.debug("Initializing flyout", parameters);
          module.create.id();
          if (!isFlyoutComponent) {
            module.create.flyout();
            if (!isFunction(settings.onHidden)) {
              settings.onHidden = function() {
                module.destroy();
                $module.remove();
              };
            }
            if (!settings.autoShow) {
              settings.autoShow = true;
            }
          }
          $module.addClass(settings.class);
          if (settings.title !== "") {
            $module.find(selector.header).html(module.helpers.escape(settings.title, settings.preserveHTML)).addClass(settings.classTitle);
          }
          if (settings.content !== "") {
            $module.find(selector.content).html(module.helpers.escape(settings.content, settings.preserveHTML)).addClass(settings.classContent);
          }
          if (module.has.configActions()) {
            var $actions = $module.find(selector.actions).addClass(settings.classActions);
            if ($actions.length === 0) {
              $actions = $("<div/>", { class: className.actions + " " + (settings.classActions || "") }).appendTo($module);
            } else {
              $actions.empty();
            }
            settings.actions.forEach(function(el) {
              var icon = el[fields.icon] ? "<i " + (el[fields.text] ? 'aria-hidden="true"' : "") + ' class="' + module.helpers.deQuote(el[fields.icon]) + ' icon"></i>' : "", text = module.helpers.escape(el[fields.text] || "", settings.preserveHTML), cls = module.helpers.deQuote(el[fields.class] || ""), click = el[fields.click] && isFunction(el[fields.click]) ? el[fields.click] : function() {
              };
              $actions.append($("<button/>", {
                html: icon + text,
                "aria-label": (el[fields.text] || el[fields.icon] || "").replace(/<[^>]+(>|$)/g, ""),
                class: className.button + " " + cls,
                on: {
                  click: function() {
                    if (click.call(element2, $module) === false) {
                      return;
                    }
                    module.hide();
                  }
                }
              }));
            });
          }
          if (settings.delaySetup) {
            requestAnimationFrame(module.setup.layout);
          } else {
            module.setup.layout();
          }
          requestAnimationFrame(function() {
            module.setup.cache();
          });
          if (module.get.direction() === "left" || module.get.direction() === "right") {
            module.setup.heights();
            module.bind.resize();
          }
          module.bind.events();
          module.observeChanges();
          module.instantiate();
          if (settings.autoShow) {
            module.show();
          }
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        create: {
          flyout: function() {
            module.verbose("Programmaticaly create flyout", $context);
            $module = $("<div/>", { class: className.flyout, role: "dialog", "aria-modal": settings.dimPage });
            if (settings.closeIcon) {
              $closeIcon = $("<i/>", {
                class: className.close,
                role: "button",
                tabindex: 0,
                "aria-label": settings.text.close
              });
              $module.append($closeIcon);
            }
            if (settings.title !== "") {
              var titleId = "_" + module.get.id() + "title";
              $module.attr("aria-labelledby", titleId);
              $("<div/>", { class: className.header, id: titleId }).appendTo($module);
            }
            if (settings.content !== "") {
              var descId = "_" + module.get.id() + "desc";
              $module.attr("aria-describedby", descId);
              $("<div/>", { class: className.content, id: descId }).appendTo($module);
            }
            if (module.has.configActions()) {
              $("<div/>", { class: className.actions }).appendTo($module);
            }
            $module.prependTo($context);
            element2 = $module[0];
          },
          id: function() {
            id = (Math.random().toString(16) + "000000000").slice(2, 10);
            elementNamespace = "." + id;
            module.verbose("Creating unique id for element", id);
          }
        },
        destroy: function() {
          if (observer) {
            observer.disconnect();
          }
          module.verbose("Destroying previous module for", $module);
          $module.off(eventNamespace).removeData(moduleNamespace);
          if (module.is.ios()) {
            module.remove.ios();
          }
          $closeIcon.off(elementNamespace);
          if ($inputs) {
            $inputs.off(elementNamespace);
          }
          $context.off(elementNamespace);
          $window.off(elementNamespace);
          $document.off(elementNamespace);
        },
        event: {
          keyboard: function(event2) {
            var keyCode = event2.which;
            if (keyCode === settings.keys.escape) {
              if (settings.closable) {
                module.debug("Escape key pressed hiding flyout");
                module.hide();
              } else {
                module.debug("Escape key pressed, but closable is set to false");
              }
              event2.preventDefault();
            }
          },
          resize: function() {
            module.setup.heights();
          },
          focus: function() {
            if (module.is.visible() && settings.autofocus && settings.dimPage) {
              requestAnimationFrame(module.set.autofocus);
            }
          },
          clickaway: function(event2) {
            if (settings.closable) {
              var clickedInPusher = $pusher.find(event2.target).length > 0 || $pusher.is(event2.target), clickedContext = $context.is(event2.target);
              if (clickedInPusher) {
                module.verbose("User clicked on dimmed page");
                module.hide();
              }
              if (clickedContext) {
                module.verbose("User clicked on dimmable context (scaled out page)");
                module.hide();
              }
            }
          },
          close: function(event2) {
            module.hide();
          },
          closeKeyUp: function(event2) {
            var keyCode = event2.which;
            if (keyCode === settings.keys.enter || keyCode === settings.keys.space) {
              module.hide();
            }
          },
          inputKeyDown: {
            first: function(event2) {
              var keyCode = event2.which;
              if (keyCode === settings.keys.tab && event2.shiftKey) {
                $inputs.last().trigger("focus");
                event2.preventDefault();
              }
            },
            last: function(event2) {
              var keyCode = event2.which;
              if (keyCode === settings.keys.tab && !event2.shiftKey) {
                $inputs.first().trigger("focus");
                event2.preventDefault();
              }
            }
          },
          approve: function(event2) {
            if (ignoreRepeatedEvents || settings.onApprove.call(module.element, $(this)) === false) {
              module.verbose("Approve callback returned false cancelling close");
              return;
            }
            ignoreRepeatedEvents = true;
            module.hide(function() {
              ignoreRepeatedEvents = false;
            });
          },
          deny: function(event2) {
            if (ignoreRepeatedEvents || settings.onDeny.call(module.element, $(this)) === false) {
              module.verbose("Deny callback returned false cancelling close");
              return;
            }
            ignoreRepeatedEvents = true;
            module.hide(function() {
              ignoreRepeatedEvents = false;
            });
          },
          touch: function(event2) {
          },
          containScroll: function(event2) {
            if (element2.scrollTop <= 0) {
              element2.scrollTop = 1;
            }
            if (element2.scrollTop + element2.offsetHeight >= element2.scrollHeight) {
              element2.scrollTop = element2.scrollHeight - element2.offsetHeight - 1;
            }
          },
          scroll: function(event2) {
            if ($(event2.target).closest(selector.flyout).length === 0) {
              event2.preventDefault();
            }
          }
        },
        bind: {
          resize: function() {
            module.verbose("Adding resize event to window", $window);
            $window.on("resize" + elementNamespace, module.event.resize);
          },
          events: function() {
            module.verbose("Attaching events");
            $module.on("click" + eventNamespace, selector.close, module.event.close).on("click" + eventNamespace, selector.approve, module.event.approve).on("click" + eventNamespace, selector.deny, module.event.deny);
            $closeIcon.on("keyup" + elementNamespace, module.event.closeKeyUp);
            $window.on("focus" + elementNamespace, module.event.focus);
          },
          clickaway: function() {
            module.verbose("Adding clickaway events to context", $context);
            $context.on("click" + elementNamespace, module.event.clickaway).on("touchend" + elementNamespace, module.event.clickaway);
          },
          scrollLock: function() {
            if (settings.scrollLock) {
              module.debug("Disabling page scroll");
              hadScrollbar = module.has.scrollbar();
              if (hadScrollbar) {
                module.save.bodyMargin();
                module.set.bodyMargin();
              }
              $context.addClass(className.locked);
            }
            module.verbose("Adding events to contain flyout scroll");
            $document.on("touchmove" + elementNamespace, module.event.touch);
            $module.on("scroll" + eventNamespace, module.event.containScroll);
          }
        },
        unbind: {
          clickaway: function() {
            module.verbose("Removing clickaway events from context", $context);
            $context.off(elementNamespace);
          },
          scrollLock: function() {
            module.verbose("Removing scroll lock from page");
            if (hadScrollbar) {
              module.restore.bodyMargin();
            }
            $context.removeClass(className.locked);
            $document.off(elementNamespace);
            $module.off("scroll" + eventNamespace);
          }
        },
        add: {
          inlineCSS: function() {
            var width = module.cache.width || $module.outerWidth(), height = module.cache.height || $module.outerHeight(), isRTL = module.is.rtl(), direction = module.get.direction(), distance = {
              left: width,
              right: -width,
              top: height,
              bottom: -height
            }, style;
            if (isRTL) {
              module.verbose("RTL detected, flipping widths");
              distance.left = -width;
              distance.right = width;
            }
            style = "<style>";
            if (direction === "left" || direction === "right") {
              module.debug("Adding CSS rules for animation distance", width);
              style += " .ui.visible." + direction + ".flyout ~ .fixed, .ui.visible." + direction + ".flyout ~ .pusher {           transform: translate3d(" + distance[direction] + "px, 0, 0); }";
            } else if (direction === "top" || direction === "bottom") {
              style += " .ui.visible." + direction + ".flyout ~ .fixed, .ui.visible." + direction + ".flyout ~ .pusher {           transform: translate3d(0, " + distance[direction] + "px, 0); }";
            }
            if (module.is.ie()) {
              if (direction === "left" || direction === "right") {
                module.debug("Adding CSS rules for animation distance", width);
                style += " body.pushable > .ui.visible." + direction + ".flyout ~ .pusher::after {           transform: translate3d(" + distance[direction] + "px, 0, 0); }";
              } else if (direction === "top" || direction === "bottom") {
                style += " body.pushable > .ui.visible." + direction + ".flyout ~ .pusher::after {           transform: translate3d(0, " + distance[direction] + "px, 0); }";
              }
              style += " body.pushable > .ui.visible.left.flyout ~ .ui.visible.right.flyout ~ .pusher::after, body.pushable > .ui.visible.right.flyout ~ .ui.visible.left.flyout ~ .pusher::after {           transform: translate3d(0, 0, 0); }";
            }
            style += "</style>";
            $style = $(style).appendTo($head);
            module.debug("Adding sizing css to head", $style);
          },
          keyboardShortcuts: function() {
            module.verbose("Adding keyboard shortcuts");
            $document.on("keydown" + eventNamespace, module.event.keyboard);
          }
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            observer = new MutationObserver(function(mutations) {
              var collectNodes = function(parent) {
                var nodes = [];
                for (var c = 0, cl = parent.length; c < cl; c++) {
                  Array.prototype.push.apply(nodes, collectNodes(parent[c].childNodes));
                  nodes.push(parent[c]);
                }
                return nodes;
              }, shouldRefreshInputs = false;
              mutations.every(function(mutation) {
                if (mutation.type === "attributes") {
                  if (observeAttributes && (mutation.attributeName === "disabled" || $(mutation.target).find(":input").addBack(":input").length > 0)) {
                    shouldRefreshInputs = true;
                  }
                } else {
                  var $addedInputs = $(collectNodes(mutation.addedNodes)).filter("a[href], [tabindex], :input:enabled").filter(":visible"), $removedInputs = $(collectNodes(mutation.removedNodes)).filter("a[href], [tabindex], :input");
                  if ($addedInputs.length > 0 || $removedInputs.length > 0) {
                    shouldRefreshInputs = true;
                  }
                }
                return !shouldRefreshInputs;
              });
              if (shouldRefreshInputs) {
                module.refreshInputs();
              }
            });
            observer.observe(element2, {
              attributeFilter: ["class", "disabled"],
              attributes: true,
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", observer);
          }
        },
        refresh: function() {
          module.verbose("Refreshing selector cache");
          $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $body;
          module.refreshFlyouts();
          $pusher = $context.children(selector.pusher);
          module.clear.cache();
        },
        refreshFlyouts: function() {
          module.verbose("Refreshing other flyouts");
          $flyouts = $context.children(selector.flyout);
        },
        refreshInputs: function() {
          if ($inputs) {
            $inputs.off("keydown" + elementNamespace);
          }
          if (!settings.dimPage) {
            return;
          }
          $inputs = $module.find("a[href], [tabindex], :input:enabled").filter(":visible").filter(function() {
            return $(this).closest(".disabled").length === 0;
          });
          if ($inputs.length === 0) {
            $inputs = $module;
            $module.attr("tabindex", -1);
          } else {
            $module.removeAttr("tabindex");
          }
          $inputs.first().on("keydown" + elementNamespace, module.event.inputKeyDown.first);
          $inputs.last().on("keydown" + elementNamespace, module.event.inputKeyDown.last);
          if (settings.autofocus && $inputs.filter(":focus").length === 0) {
            module.set.autofocus();
          }
        },
        setup: {
          cache: function() {
            module.cache = {
              width: $module.outerWidth(),
              height: $module.outerHeight()
            };
          },
          layout: function() {
            if ($context.children(selector.pusher).length === 0) {
              module.debug("Adding wrapper element for flyout");
              module.error(error.pusher);
              $pusher = $('<div class="pusher" />');
              $context.children().not(selector.omitted).not($flyouts).wrapAll($pusher);
              module.refresh();
            }
            if ($module.nextAll(selector.pusher).length === 0 || $module.nextAll(selector.pusher)[0] !== $pusher[0]) {
              module.debug("Moved flyout to correct parent element");
              module.error(error.movedFlyout, element2);
              $module.detach().prependTo($context);
              module.refresh();
            }
            if (module.is.mobile()) {
              $module.addClass(className.fullscreen);
            }
            module.clear.cache();
            module.set.pushable();
            module.set.direction();
          },
          heights: function() {
            module.debug("Setting up heights", $module);
            var $header = $module.children(selector.header), $content = $module.children(selector.content), $actions = $module.children(selector.actions), newContentHeight = ($context.height() || 0) - ($header.outerHeight() || 0) - ($actions.outerHeight() || 0);
            if (newContentHeight > 0) {
              $content.css("min-height", String(newContentHeight) + "px");
            }
          }
        },
        attachEvents: function(selector2, event2) {
          var $toggle = $(selector2);
          event2 = isFunction(module[event2]) ? module[event2] : module.toggle;
          if ($toggle.length > 0) {
            module.debug("Attaching flyout events to element", selector2, event2);
            $toggle.on("click" + eventNamespace, event2);
          } else {
            module.error(error.notFound, selector2);
          }
        },
        show: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (module.is.hidden()) {
            if (settings.onShow.call(element2) === false) {
              module.verbose("Show callback returned false cancelling show");
              return;
            }
            module.refresh();
            if (module.othersActive()) {
              module.debug("Other flyouts currently visible");
              if (settings.exclusive) {
                module.hideOthers();
              } else {
                ignoreRepeatedEvents = false;
              }
            }
            module.set.dimmerStyles();
            module.set.observeAttributes(false);
            module.pushPage(function() {
              callback.call(element2);
              settings.onVisible.call(element2);
              if (settings.keyboardShortcuts) {
                module.add.keyboardShortcuts();
              }
              module.save.focus();
              module.refreshInputs();
              requestAnimationFrame(module.set.observeAttributes);
            });
            settings.onChange.call(element2);
          } else {
            module.debug("Flyout is already visible");
          }
        },
        hide: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (settings.onHide.call(element2, $(this)) === false) {
            module.verbose("Hide callback returned false cancelling hide");
            ignoreRepeatedEvents = false;
            return false;
          }
          if (module.is.visible() || module.is.animating()) {
            module.debug("Hiding flyout", callback);
            module.refreshFlyouts();
            module.set.observeAttributes(false);
            module.pullPage(function() {
              callback.call(element2);
              if (isFunction(settings.onHidden)) {
                settings.onHidden.call(element2);
              }
              module.restore.focus();
            });
            settings.onChange.call(element2);
          }
        },
        othersAnimating: function() {
          return $flyouts.not($module).filter("." + className.animating).length > 0;
        },
        othersVisible: function() {
          return $flyouts.not($module).filter("." + className.visible).length > 0;
        },
        othersActive: function() {
          return module.othersVisible() || module.othersAnimating();
        },
        hideOthers: function(callback) {
          var $otherFlyouts = $flyouts.not($module).filter("." + className.visible), flyoutCount = $otherFlyouts.length, callbackCount = 0;
          callback = callback || function() {
          };
          $otherFlyouts.flyout("hide", function() {
            callbackCount++;
            if (callbackCount === flyoutCount) {
              callback();
            }
          });
        },
        toggle: function() {
          module.verbose("Determining toggled direction");
          if (module.is.hidden()) {
            module.show();
          } else {
            module.hide();
          }
        },
        pushPage: function(callback) {
          var animate, dim, transitionEnd;
          callback = isFunction(callback) ? callback : function() {
          };
          module.set.overlay();
          if (settings.returnScroll) {
            currentScroll = (isBody ? $window : $context).scrollTop();
          }
          module.bind.scrollLock();
          animate = function() {
            module.bind.clickaway();
            module.add.inlineCSS();
            module.set.animating();
            module.set.visible();
          };
          dim = function() {
            module.set.dimmed();
          };
          transitionEnd = function(event2) {
            if (event2.target === $module[0]) {
              $module.off("transitionend" + elementNamespace, transitionEnd);
              module.remove.animating();
              callback.call(element2);
            }
          };
          $module.off("transitionend" + elementNamespace);
          $module.on("transitionend" + elementNamespace, transitionEnd);
          requestAnimationFrame(animate);
          if (settings.dimPage && !module.othersVisible()) {
            requestAnimationFrame(dim);
          }
        },
        pullPage: function(callback) {
          var animate, transitionEnd;
          callback = isFunction(callback) ? callback : function() {
          };
          module.verbose("Removing context push state", module.get.direction());
          module.unbind.clickaway();
          if (!module.othersActive()) {
            module.unbind.scrollLock();
            if (settings.keyboardShortcuts) {
              module.remove.keyboardShortcuts();
            }
          }
          animate = function() {
            module.set.overlay();
            module.set.animating();
            if (settings.dimPage && !module.othersVisible()) {
              module.set.closing();
            }
            module.remove.visible();
          };
          transitionEnd = function(event2) {
            if (event2.target === $module[0]) {
              $module.off("transitionend" + elementNamespace, transitionEnd);
              module.remove.animating();
              module.remove.closing();
              module.remove.overlay();
              module.remove.inlineCSS();
              if (settings.returnScroll) {
                module.scrollBack();
              }
              if (settings.dimPage && !module.othersVisible()) {
                $pusher.removeClass(className.dimmed);
              }
              callback.call(element2);
            }
          };
          $module.off("transitionend" + elementNamespace);
          $module.on("transitionend" + elementNamespace, transitionEnd);
          requestAnimationFrame(animate);
        },
        scrollToTop: function() {
          module.verbose("Scrolling to top of page to avoid animation issues");
          $module.scrollTop(0);
          (isBody ? $window : $context)[0].scrollTo(0, 0);
        },
        scrollBack: function() {
          module.verbose("Scrolling back to original page position");
          (isBody ? $window : $context)[0].scrollTo(0, currentScroll);
        },
        clear: {
          cache: function() {
            module.verbose("Clearing cached dimensions");
            module.cache = {};
          }
        },
        set: {
          observeAttributes: function(state) {
            observeAttributes = state !== false;
          },
          autofocus: function() {
            var $autofocus = $inputs.filter("[autofocus]"), $rawInputs = $inputs.filter(":input"), $input = $autofocus.length > 0 ? $autofocus.first() : ($rawInputs.length > 0 ? $rawInputs : $inputs.filter(":not(i.close)")).first();
            if ($input.length === 0 && $inputs.length > 0) {
              $input = $inputs.first();
            }
            if ($input.length > 0) {
              $input.trigger("focus");
            }
          },
          dimmerStyles: function() {
            if (settings.blurring) {
              $pusher.addClass(className.blurring);
            } else {
              $pusher.removeClass(className.blurring);
            }
          },
          bodyMargin: function() {
            var position = module.can.leftBodyScrollbar() ? "left" : "right";
            $context.css((isBody ? "margin-" : "padding-") + position, tempBodyMargin + "px");
            $context.find(selector.bodyFixed.replace("right", position)).each(function() {
              var el = $(this), attribute = el.css("position") === "fixed" ? "padding-" + position : position;
              el.css(attribute, "calc(" + el.css(attribute) + " + " + tempBodyMargin + "px)");
            });
          },
          // ios only (scroll on html not document). This prevent auto-resize canvas/scroll in ios
          // (This is no longer necessary in latest iOS)
          ios: function() {
            $html.addClass(className.ios);
          },
          // container
          pushed: function() {
            $context.addClass(className.pushed);
          },
          pushable: function() {
            $context.addClass(className.pushable);
          },
          // pusher
          dimmed: function() {
            $pusher.addClass(className.dimmed);
          },
          // flyout
          active: function() {
            $module.addClass(className.active);
          },
          animating: function() {
            $module.addClass(className.animating);
          },
          closing: function() {
            $pusher.addClass(className.closing);
          },
          direction: function(direction) {
            direction = direction || module.get.direction();
            $module.addClass(className[direction]);
          },
          visible: function() {
            $module.addClass(className.visible);
          },
          overlay: function() {
            $module.addClass(className.overlay);
          }
        },
        remove: {
          inlineCSS: function() {
            module.debug("Removing inline css styles", $style);
            if ($style && $style.length > 0) {
              $style.remove();
            }
          },
          keyboardShortcuts: function() {
            module.verbose("Removing keyboard shortcuts");
            $document.off("keydown" + eventNamespace);
          },
          // ios scroll on html not document
          ios: function() {
            $html.removeClass(className.ios);
          },
          // context
          pushed: function() {
            $context.removeClass(className.pushed);
          },
          pushable: function() {
            $context.removeClass(className.pushable);
          },
          // flyout
          active: function() {
            $module.removeClass(className.active);
          },
          animating: function() {
            $module.removeClass(className.animating);
          },
          closing: function() {
            $pusher.removeClass(className.closing);
          },
          direction: function(direction) {
            direction = direction || module.get.direction();
            $module.removeClass(className[direction]);
          },
          visible: function() {
            $module.removeClass(className.visible);
          },
          overlay: function() {
            $module.removeClass(className.overlay);
          }
        },
        get: {
          direction: function() {
            if ($module.hasClass(className.top)) {
              return className.top;
            }
            if ($module.hasClass(className.right)) {
              return className.right;
            }
            if ($module.hasClass(className.bottom)) {
              return className.bottom;
            }
            return className.left;
          },
          id: function() {
            return id;
          },
          element: function() {
            return $module;
          },
          settings: function() {
            return settings;
          }
        },
        can: {
          leftBodyScrollbar: function() {
            if (module.cache.leftBodyScrollbar === void 0) {
              module.cache.leftBodyScrollbar = module.is.rtl() && (module.is.iframe && !module.is.firefox() || module.is.safari() || module.is.edge() || module.is.ie());
            }
            return module.cache.leftBodyScrollbar;
          }
        },
        save: {
          focus: function() {
            var $activeElement = $(document2.activeElement), inCurrentFlyout = $activeElement.closest($module).length > 0;
            if (!inCurrentFlyout) {
              $focusedElement = $(document2.activeElement).trigger("blur");
            }
          },
          bodyMargin: function() {
            initialBodyMargin = $context.css((isBody ? "margin-" : "padding-") + (module.can.leftBodyScrollbar() ? "left" : "right"));
            var bodyMarginRightPixel = parseInt(initialBodyMargin.replace(/[^\d.]/g, ""), 10), bodyScrollbarWidth = isBody ? window2.innerWidth - document2.documentElement.clientWidth : $context[0].offsetWidth - $context[0].clientWidth;
            tempBodyMargin = bodyMarginRightPixel + bodyScrollbarWidth;
          }
        },
        is: {
          safari: function() {
            if (module.cache.isSafari === void 0) {
              module.cache.isSafari = /constructor/i.test(window2.HTMLElement) || !!window2.ApplePaySession;
            }
            return module.cache.isSafari;
          },
          edge: function() {
            if (module.cache.isEdge === void 0) {
              module.cache.isEdge = !!window2.setImmediate && !module.is.ie();
            }
            return module.cache.isEdge;
          },
          firefox: function() {
            if (module.cache.isFirefox === void 0) {
              module.cache.isFirefox = !!window2.InstallTrigger;
            }
            return module.cache.isFirefox;
          },
          iframe: function() {
            return !(self === top);
          },
          ie: function() {
            if (module.cache.isIE === void 0) {
              var isIE11 = !window2.ActiveXObject && "ActiveXObject" in window2, isIE = "ActiveXObject" in window2;
              module.cache.isIE = isIE11 || isIE;
            }
            return module.cache.isIE;
          },
          ios: function() {
            var userAgent = navigator.userAgent, isIOS = userAgent.match(regExp.ios), isMobileChrome = userAgent.match(regExp.mobileChrome);
            if (isIOS && !isMobileChrome) {
              module.verbose("Browser was found to be iOS", userAgent);
              return true;
            }
            return false;
          },
          mobile: function() {
            var userAgent = navigator.userAgent, isMobile = userAgent.match(regExp.mobile);
            if (isMobile) {
              module.verbose("Browser was found to be mobile", userAgent);
              return true;
            }
            module.verbose("Browser is not mobile, using regular transition", userAgent);
            return false;
          },
          hidden: function() {
            return !module.is.visible();
          },
          visible: function() {
            return $module.hasClass(className.visible);
          },
          animating: function() {
            return $context.hasClass(className.animating);
          },
          rtl: function() {
            if (module.cache.isRTL === void 0) {
              module.cache.isRTL = $module.attr("dir") === "rtl" || $module.css("direction") === "rtl" || $body.attr("dir") === "rtl" || $body.css("direction") === "rtl" || $context.attr("dir") === "rtl" || $context.css("direction") === "rtl";
            }
            return module.cache.isRTL;
          }
        },
        has: {
          configActions: function() {
            return Array.isArray(settings.actions) && settings.actions.length > 0;
          },
          scrollbar: function() {
            return isBody || $context.css("overflow-y") !== "hidden";
          }
        },
        restore: {
          focus: function() {
            if ($focusedElement && $focusedElement.length > 0 && settings.restoreFocus) {
              $focusedElement.trigger("focus");
            }
          },
          bodyMargin: function() {
            var position = module.can.leftBodyScrollbar() ? "left" : "right";
            $context.css((isBody ? "margin-" : "padding-") + position, initialBodyMargin);
            $context.find(selector.bodyFixed.replace("right", position)).each(function() {
              var el = $(this), attribute = el.css("position") === "fixed" ? "padding-" + position : position;
              el.css(attribute, "");
            });
          }
        },
        helpers: {
          deQuote: function(string) {
            return String(string).replace(/"/g, "");
          },
          escape: function(string, preserveHTML) {
            if (preserveHTML) {
              return string;
            }
            var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#x27;",
              "`": "&#x60;"
            }, escapedChar = function(chr) {
              return escape2[chr];
            };
            if (shouldEscape.test(string)) {
              string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
              return string.replace(badChars, escapedChar);
            }
            return string;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = element2 || context;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          if (isFunction(settings.templates[query])) {
            settings.autoShow = true;
            settings.className.flyout = settings.className.template;
            settings = $.extend(true, {}, settings, settings.templates[query].apply(module, queryArguments));
            className = settings.className;
            namespace = settings.namespace;
            fields = settings.fields;
            error = settings.error;
          }
          module.initialize();
        }
        if (!isFunction(settings.templates[query])) {
          module.invoke(query);
        }
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
        returnedValue = $module;
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.flyout = $.fn.flyout;
  $.fn.flyout.settings = {
    name: "Flyout",
    namespace: "flyout",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    context: "body",
    exclusive: false,
    closable: true,
    autofocus: true,
    restoreFocus: true,
    dimPage: true,
    scrollLock: false,
    returnScroll: false,
    delaySetup: false,
    autoShow: false,
    keyboardShortcuts: true,
    // dynamic content
    title: "",
    content: "",
    class: "",
    classTitle: "",
    classContent: "",
    classActions: "",
    closeIcon: false,
    actions: false,
    preserveHTML: true,
    fields: {
      class: "class",
      text: "text",
      icon: "icon",
      click: "click"
    },
    onChange: function() {
    },
    onShow: function() {
    },
    onHide: function() {
      return true;
    },
    onHidden: false,
    onVisible: function() {
    },
    onApprove: function() {
    },
    onDeny: function() {
    },
    keys: {
      space: 32,
      enter: 13,
      escape: 27,
      tab: 9
    },
    className: {
      flyout: "ui flyout",
      close: "close icon",
      header: "ui header",
      content: "content",
      actions: "actions",
      active: "active",
      animating: "animating",
      blurring: "blurring",
      closing: "closing",
      dimmed: "dimmed",
      ios: "ios",
      locked: "locked",
      pushable: "pushable",
      pushed: "pushed",
      right: "right",
      top: "top",
      left: "left",
      bottom: "bottom",
      visible: "visible",
      overlay: "overlay",
      fullscreen: "fullscreen",
      template: "ui flyout",
      button: "ui button",
      ok: "positive",
      cancel: "negative",
      prompt: "ui fluid input"
    },
    selector: {
      bodyFixed: "> .ui.fixed.menu, > .ui.right.toast-container, > .ui.right.sidebar, > .ui.right.flyout, > .ui.fixed.nag, > .ui.fixed.nag > .close",
      fixed: ".fixed",
      omitted: "script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed",
      pusher: ".pusher",
      flyout: ".ui.flyout",
      header: ".ui.header",
      content: ".content",
      actions: ".actions",
      close: ".close",
      approve: ".actions .positive, .actions .approve, .actions .ok",
      deny: ".actions .negative, .actions .deny, .actions .cancel"
    },
    regExp: {
      ios: /(iPad|iPhone|iPod)/g,
      mobileChrome: /(CriOS)/g,
      mobile: /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g
    },
    error: {
      method: "The method you called is not defined.",
      pusher: "Had to add pusher element. For optimal performance make sure body content is inside a pusher element",
      movedFlyout: "Had to move flyout. For optimal performance make sure flyout and pusher are direct children of your body tag",
      notFound: "There were no elements that matched the specified selector"
    },
    text: {
      ok: "Ok",
      cancel: "Cancel",
      close: "Close"
    }
  };
  $.fn.flyout.settings.templates = {
    getArguments: function(args) {
      var queryArguments = [].slice.call(args);
      if ($.isPlainObject(queryArguments[0])) {
        return $.extend({
          handler: function() {
          },
          content: "",
          title: ""
        }, queryArguments[0]);
      }
      if (!isFunction(queryArguments[queryArguments.length - 1])) {
        queryArguments.push(function() {
        });
      }
      return {
        handler: queryArguments.pop(),
        content: queryArguments.pop() || "",
        title: queryArguments.pop() || ""
      };
    },
    alert: function() {
      var settings = this.get.settings(), args = settings.templates.getArguments(arguments);
      return {
        title: args.title,
        content: args.content,
        actions: [{
          text: settings.text.ok,
          class: settings.className.ok,
          click: args.handler
        }]
      };
    },
    confirm: function() {
      var settings = this.get.settings(), args = settings.templates.getArguments(arguments);
      return {
        title: args.title,
        content: args.content,
        actions: [{
          text: settings.text.ok,
          class: settings.className.ok,
          click: function() {
            args.handler(true);
          }
        }, {
          text: settings.text.cancel,
          class: settings.className.cancel,
          click: function() {
            args.handler(false);
          }
        }]
      };
    },
    prompt: function() {
      var $this = this, settings = this.get.settings(), args = settings.templates.getArguments(arguments), input = $($.parseHTML(args.content)).filter(".ui.input");
      if (input.length === 0) {
        args.content += '<p><div class="' + settings.className.prompt + '"><input placeholder="' + this.helpers.deQuote(args.placeholder || "") + '" type="text" value="' + this.helpers.deQuote(args.defaultValue || "") + '"></div></p>';
      }
      return {
        title: args.title,
        content: args.content,
        actions: [{
          text: settings.text.ok,
          class: settings.className.ok,
          click: function() {
            var settings2 = $this.get.settings(), inputField = $this.get.element().find(settings2.selector.prompt)[0];
            args.handler($(inputField).val());
          }
        }, {
          text: settings.text.cancel,
          class: settings.className.cancel,
          click: function() {
            args.handler(null);
          }
        }]
      };
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.modal = function(parameters) {
    var $allModules = $(this), $window = $(window2), $document = $(document2), $body = $("body"), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.modal.settings, parameters) : $.extend({}, $.fn.modal.settings), selector = settings.selector, className = settings.className, namespace = settings.namespace, fields = settings.fields, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $body, isBody = $context[0] === $body[0], $closeIcon = $module.find(selector.closeIcon), $inputs, $allModals, $otherModals, $focusedElement, $dimmable, $dimmer, isModalComponent = $module.hasClass("modal"), element2 = this, instance68 = isModalComponent ? $module.data(moduleNamespace) : void 0, ignoreRepeatedEvents = false, initialMouseDownInModal, initialMouseDownInScrollbar, initialBodyMargin = "", tempBodyMargin = "", keepScrollingClass = false, hadScrollbar = false, elementEventNamespace, id, observer, observeAttributes = false, module;
      module = {
        initialize: function() {
          module.create.id();
          if (!isModalComponent) {
            module.create.modal();
            if (!isFunction(settings.onHidden)) {
              settings.onHidden = function() {
                module.destroy();
                $module.remove();
              };
            }
          }
          $module.addClass(settings.class);
          if (settings.title !== "") {
            $module.find(selector.title).html(module.helpers.escape(settings.title, settings.preserveHTML)).addClass(settings.classTitle);
          }
          if (settings.content !== "") {
            $module.find(selector.content).html(module.helpers.escape(settings.content, settings.preserveHTML)).addClass(settings.classContent);
          }
          if (module.has.configActions()) {
            var $actions = $module.find(selector.actions).addClass(settings.classActions);
            if ($actions.length === 0) {
              $actions = $("<div/>", { class: className.actions + " " + (settings.classActions || "") }).appendTo($module);
            } else {
              $actions.empty();
            }
            settings.actions.forEach(function(el) {
              var icon = el[fields.icon] ? "<i " + (el[fields.text] ? 'aria-hidden="true"' : "") + ' class="' + module.helpers.deQuote(el[fields.icon]) + ' icon"></i>' : "", text = module.helpers.escape(el[fields.text] || "", settings.preserveHTML), cls = module.helpers.deQuote(el[fields.class] || ""), click = el[fields.click] && isFunction(el[fields.click]) ? el[fields.click] : function() {
              };
              $actions.append($("<button/>", {
                html: icon + text,
                "aria-label": (el[fields.text] || el[fields.icon] || "").replace(/<[^>]+(>|$)/g, ""),
                class: className.button + " " + cls,
                on: {
                  click: function() {
                    var button = $(this);
                    if (button.is(selector.approve) || button.is(selector.deny) || click.call(element2, $module) === false) {
                      return;
                    }
                    module.hide();
                  }
                }
              }));
            });
          }
          module.cache = {};
          module.verbose("Initializing dimmer", $context);
          module.create.dimmer();
          if (settings.allowMultiple) {
            module.create.innerDimmer();
          }
          if (!settings.centered) {
            $module.addClass("top aligned");
          }
          module.refreshModals();
          module.bind.events();
          module.observeChanges();
          module.instantiate();
          if (settings.autoShow) {
            module.show();
          }
        },
        instantiate: function() {
          module.verbose("Storing instance of modal");
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        create: {
          modal: function() {
            $module = $("<div/>", { class: className.modal, role: "dialog", "aria-modal": true });
            if (settings.closeIcon) {
              $closeIcon = $("<i/>", {
                class: className.close,
                role: "button",
                tabindex: 0,
                "aria-label": settings.text.close
              });
              $module.append($closeIcon);
            }
            if (settings.title !== "") {
              var titleId = "_" + module.get.id() + "title";
              $module.attr("aria-labelledby", titleId);
              $("<div/>", { class: className.title, id: titleId }).appendTo($module);
            }
            if (settings.content !== "") {
              var descId = "_" + module.get.id() + "desc";
              $module.attr("aria-describedby", descId);
              $("<div/>", { class: className.content, id: descId }).appendTo($module);
            }
            if (module.has.configActions()) {
              $("<div/>", { class: className.actions }).appendTo($module);
            }
            $context.append($module);
            element2 = $module[0];
          },
          dimmer: function() {
            var defaultSettings = {
              debug: settings.debug,
              dimmerName: "modals"
            }, dimmerSettings = $.extend(true, defaultSettings, settings.dimmerSettings);
            if ($.fn.dimmer === void 0) {
              module.error(error.dimmer);
              return;
            }
            module.debug("Creating dimmer");
            $dimmable = $context.dimmer(dimmerSettings);
            keepScrollingClass = module.is.scrolling();
            if (settings.detachable) {
              module.verbose("Modal is detachable, moving content into dimmer");
              $dimmable.dimmer("add content", $module);
            } else {
              module.set.undetached();
            }
            $dimmer = $dimmable.dimmer("get dimmer");
          },
          id: function() {
            id = (Math.random().toString(16) + "000000000").slice(2, 10);
            elementEventNamespace = "." + id;
            module.verbose("Creating unique id for element", id);
          },
          innerDimmer: function() {
            if ($module.find(selector.dimmer).length === 0) {
              $("<div/>", { class: className.innerDimmer }).prependTo($module);
            }
          }
        },
        destroy: function() {
          if (observer) {
            observer.disconnect();
          }
          module.verbose("Destroying previous modal");
          $module.removeData(moduleNamespace).off(eventNamespace);
          $window.off(elementEventNamespace);
          $dimmer.off(elementEventNamespace);
          $closeIcon.off(elementEventNamespace);
          if ($inputs) {
            $inputs.off(elementEventNamespace);
          }
          $context.dimmer("destroy");
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            observer = new MutationObserver(function(mutations) {
              var collectNodes = function(parent) {
                var nodes = [];
                for (var c = 0, cl = parent.length; c < cl; c++) {
                  Array.prototype.push.apply(nodes, collectNodes(parent[c].childNodes));
                  nodes.push(parent[c]);
                }
                return nodes;
              }, shouldRefresh = false, shouldRefreshInputs = false;
              mutations.every(function(mutation) {
                if (mutation.type === "attributes") {
                  if (observeAttributes && (mutation.attributeName === "disabled" || $(mutation.target).find(":input").addBack(":input").length > 0)) {
                    shouldRefreshInputs = true;
                  }
                } else {
                  shouldRefresh = true;
                  var $addedInputs = $(collectNodes(mutation.addedNodes)).filter("a[href], [tabindex], :input:enabled").filter(":visible"), $removedInputs = $(collectNodes(mutation.removedNodes)).filter("a[href], [tabindex], :input");
                  if ($addedInputs.length > 0 || $removedInputs.length > 0) {
                    shouldRefreshInputs = true;
                  }
                }
                return !shouldRefreshInputs;
              });
              if (shouldRefresh && settings.observeChanges) {
                module.debug("DOM tree modified, refreshing");
                module.refresh();
              }
              if (shouldRefreshInputs) {
                module.refreshInputs();
              }
            });
            observer.observe(element2, {
              attributeFilter: ["class", "disabled"],
              attributes: true,
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", observer);
          }
        },
        refresh: function() {
          module.remove.scrolling();
          module.cacheSizes();
          if (!module.can.useFlex()) {
            module.set.modalOffset();
          }
          module.set.screenHeight();
          module.set.type();
        },
        refreshModals: function() {
          $otherModals = $module.siblings(selector.modal);
          $allModals = $otherModals.add($module);
        },
        refreshInputs: function() {
          if ($inputs) {
            $inputs.off("keydown" + elementEventNamespace);
          }
          $inputs = $module.find("a[href], [tabindex], :input:enabled").filter(":visible").filter(function() {
            return $(this).closest(".disabled").length === 0;
          });
          if ($inputs.length === 0) {
            $inputs = $module;
            $module.attr("tabindex", -1);
          } else {
            $module.removeAttr("tabindex");
          }
          $inputs.first().on("keydown" + elementEventNamespace, module.event.inputKeyDown.first);
          $inputs.last().on("keydown" + elementEventNamespace, module.event.inputKeyDown.last);
          if (settings.autofocus && $inputs.filter(":focus").length === 0) {
            module.set.autofocus();
          }
        },
        attachEvents: function(selector2, event2) {
          var $toggle = $(selector2);
          event2 = isFunction(module[event2]) ? module[event2] : module.toggle;
          if ($toggle.length > 0) {
            module.debug("Attaching modal events to element", selector2, event2);
            $toggle.off(eventNamespace).on("click" + eventNamespace, event2);
          } else {
            module.error(error.notFound, selector2);
          }
        },
        bind: {
          events: function() {
            module.verbose("Attaching events");
            $module.on("click" + eventNamespace, selector.close, module.event.close).on("click" + eventNamespace, selector.approve, module.event.approve).on("click" + eventNamespace, selector.deny, module.event.deny);
            $closeIcon.on("keyup" + elementEventNamespace, module.event.closeKeyUp);
            $window.on("resize" + elementEventNamespace, module.event.resize).on("focus" + elementEventNamespace, module.event.focus);
          },
          scrollLock: function() {
            $dimmable[0].addEventListener("touchmove", module.event.preventScroll, { passive: false });
          }
        },
        unbind: {
          scrollLock: function() {
            $dimmable[0].removeEventListener("touchmove", module.event.preventScroll, { passive: false });
          }
        },
        get: {
          id: function() {
            return id;
          },
          element: function() {
            return $module;
          },
          settings: function() {
            return settings;
          }
        },
        event: {
          approve: function() {
            if (ignoreRepeatedEvents || settings.onApprove.call(element2, $(this)) === false) {
              module.verbose("Approve callback returned false cancelling hide");
              return;
            }
            ignoreRepeatedEvents = true;
            module.hide(function() {
              ignoreRepeatedEvents = false;
            });
          },
          preventScroll: function(event2) {
            if (event2.target.className.indexOf("dimmer") !== -1) {
              event2.preventDefault();
            }
          },
          deny: function() {
            if (ignoreRepeatedEvents || settings.onDeny.call(element2, $(this)) === false) {
              module.verbose("Deny callback returned false cancelling hide");
              return;
            }
            ignoreRepeatedEvents = true;
            module.hide(function() {
              ignoreRepeatedEvents = false;
            });
          },
          close: function() {
            module.hide();
          },
          closeKeyUp: function(event2) {
            var keyCode = event2.which;
            if ((keyCode === settings.keys.enter || keyCode === settings.keys.space) && $module.hasClass(className.front)) {
              module.hide();
            }
          },
          inputKeyDown: {
            first: function(event2) {
              var keyCode = event2.which;
              if (keyCode === settings.keys.tab && event2.shiftKey) {
                $inputs.last().trigger("focus");
                event2.preventDefault();
              }
            },
            last: function(event2) {
              var keyCode = event2.which;
              if (keyCode === settings.keys.tab && !event2.shiftKey) {
                $inputs.first().trigger("focus");
                event2.preventDefault();
              }
            }
          },
          mousedown: function(event2) {
            var $target = $(event2.target), isRtl = module.is.rtl();
            initialMouseDownInModal = $target.closest(selector.modal).length > 0;
            if (initialMouseDownInModal) {
              module.verbose("Mouse down event registered inside the modal");
            }
            initialMouseDownInScrollbar = module.is.scrolling() && (!isRtl && $window.outerWidth() - settings.scrollbarWidth <= event2.clientX || isRtl && settings.scrollbarWidth >= event2.clientX);
            if (initialMouseDownInScrollbar) {
              module.verbose("Mouse down event registered inside the scrollbar");
            }
          },
          mouseup: function(event2) {
            if (!settings.closable) {
              module.verbose("Dimmer clicked but closable setting is disabled");
              return;
            }
            if (initialMouseDownInModal) {
              module.debug("Dimmer clicked but mouse down was initially registered inside the modal");
              return;
            }
            if (initialMouseDownInScrollbar) {
              module.debug("Dimmer clicked but mouse down was initially registered inside the scrollbar");
              return;
            }
            var $target = $(event2.target), isInModal = $target.closest(selector.modal).length > 0, isInDOM = $.contains(document2.documentElement, event2.target);
            if (!isInModal && isInDOM && module.is.active() && $module.hasClass(className.front)) {
              module.debug("Dimmer clicked, hiding all modals");
              if (settings.allowMultiple) {
                if (!module.hideAll()) {
                  return;
                }
              } else if (!module.hide()) {
                return;
              }
              module.remove.clickaway();
            }
          },
          debounce: function(method, delay) {
            clearTimeout(module.timer);
            module.timer = setTimeout(method, delay);
          },
          keyboard: function(event2) {
            var keyCode = event2.which;
            if (keyCode === settings.keys.escape) {
              if (settings.closable) {
                module.debug("Escape key pressed hiding modal");
                if ($module.hasClass(className.front)) {
                  module.hide();
                }
              } else {
                module.debug("Escape key pressed, but closable is set to false");
              }
              event2.preventDefault();
            }
          },
          resize: function() {
            if ($dimmable.dimmer("is active") && (module.is.animating() || module.is.active())) {
              requestAnimationFrame(module.refresh);
            }
          },
          focus: function() {
            if ($dimmable.dimmer("is active") && module.is.active() && settings.autofocus) {
              requestAnimationFrame(module.set.autofocus);
            }
          }
        },
        toggle: function() {
          if (module.is.active() || module.is.animating()) {
            module.hide();
          } else {
            module.show();
          }
        },
        show: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          module.refreshModals();
          module.set.dimmerSettings();
          module.set.dimmerStyles();
          module.showModal(callback);
        },
        hide: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          module.refreshModals();
          return module.hideModal(callback);
        },
        showModal: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (module.is.animating() || !module.is.active()) {
            if (settings.onShow.call(element2) === false) {
              module.verbose("Show callback returned false cancelling show");
              return;
            }
            hadScrollbar = module.has.scrollbar();
            module.showDimmer();
            module.cacheSizes();
            if (hadScrollbar) {
              module.set.bodyMargin();
            }
            if (module.can.useFlex()) {
              module.remove.legacy();
            } else {
              module.set.legacy();
              module.set.modalOffset();
              module.debug("Using non-flex legacy modal positioning.");
            }
            module.set.screenHeight();
            module.set.type();
            module.set.clickaway();
            if (!settings.allowMultiple && module.others.active()) {
              module.hideOthers(module.showModal);
            } else {
              ignoreRepeatedEvents = false;
              if (settings.allowMultiple) {
                if (module.others.active()) {
                  $otherModals.filter("." + className.active).find(selector.dimmer).addClass("active");
                }
                if (settings.detachable) {
                  $module.detach().appendTo($dimmer);
                }
              }
              if (settings.transition && $.fn.transition !== void 0) {
                module.debug("Showing modal with css animations");
                module.set.observeAttributes(false);
                $module.transition({
                  debug: settings.debug,
                  verbose: settings.verbose,
                  silent: settings.silent,
                  animation: (settings.transition.showMethod || settings.transition) + " in",
                  queue: settings.queue,
                  duration: settings.transition.showDuration || settings.duration,
                  useFailSafe: true,
                  onComplete: function() {
                    settings.onVisible.apply(element2);
                    if (settings.keyboardShortcuts) {
                      module.add.keyboardShortcuts();
                    }
                    module.save.focus();
                    module.set.active();
                    module.refreshInputs();
                    requestAnimationFrame(module.set.observeAttributes);
                    callback();
                  }
                });
              } else {
                module.error(error.noTransition);
              }
            }
          } else {
            module.debug("Modal is already visible");
          }
        },
        hideModal: function(callback, keepDimmed, hideOthersToo) {
          var $previousModal = $otherModals.filter("." + className.active).last();
          callback = isFunction(callback) ? callback : function() {
          };
          if (settings.onHide.call(element2, $(this)) === false) {
            module.verbose("Hide callback returned false cancelling hide");
            ignoreRepeatedEvents = false;
            return false;
          }
          if (module.is.animating() || module.is.active()) {
            module.debug("Hiding modal");
            if (settings.transition && $.fn.transition !== void 0) {
              module.remove.active();
              module.set.observeAttributes(false);
              $module.transition({
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                animation: (settings.transition.hideMethod || settings.transition) + " out",
                queue: settings.queue,
                duration: settings.transition.hideDuration || settings.duration,
                useFailSafe: true,
                onStart: function() {
                  if (!module.others.active() && !module.others.animating() && !keepDimmed) {
                    module.hideDimmer();
                  }
                  if (settings.keyboardShortcuts && !module.others.active()) {
                    module.remove.keyboardShortcuts();
                  }
                },
                onComplete: function() {
                  module.unbind.scrollLock();
                  module.remove.active();
                  if (settings.allowMultiple) {
                    $previousModal.addClass(className.front);
                    $module.removeClass(className.front);
                    if (hideOthersToo) {
                      $allModals.find(selector.dimmer).removeClass("active");
                    } else {
                      $previousModal.find(selector.dimmer).removeClass("active");
                    }
                  }
                  if (isFunction(settings.onHidden)) {
                    settings.onHidden.call(element2);
                  }
                  module.remove.dimmerStyles();
                  module.restore.focus();
                  callback();
                }
              });
            } else {
              module.error(error.noTransition);
            }
          }
        },
        showDimmer: function() {
          if ($dimmable.dimmer("is animating") || !$dimmable.dimmer("is active")) {
            if (hadScrollbar) {
              if (!isBody) {
                $dimmer.css("top", $dimmable.scrollTop());
              }
              module.save.bodyMargin();
            }
            module.debug("Showing dimmer");
            $dimmable.dimmer("show");
          } else {
            module.debug("Dimmer already visible");
          }
        },
        hideDimmer: function() {
          if ($dimmable.dimmer("is animating") || $dimmable.dimmer("is active")) {
            module.unbind.scrollLock();
            $dimmable.dimmer("hide", function() {
              if (hadScrollbar) {
                module.restore.bodyMargin();
              }
              module.remove.clickaway();
              module.remove.screenHeight();
            });
          } else {
            module.debug("Dimmer is not visible cannot hide");
          }
        },
        hideAll: function(callback) {
          var $visibleModals = $allModals.filter("." + className.active + ", ." + className.animating);
          callback = isFunction(callback) ? callback : function() {
          };
          if ($visibleModals.length > 0) {
            module.debug("Hiding all visible modals");
            var hideOk = true;
            $($visibleModals.get().reverse()).each(function(index, element3) {
              if (hideOk) {
                hideOk = $(element3).modal("hide modal", callback, false, true);
              }
            });
            if (hideOk) {
              module.hideDimmer();
            }
            return hideOk;
          }
        },
        hideOthers: function(callback) {
          var $visibleModals = $otherModals.filter("." + className.active + ", ." + className.animating);
          callback = isFunction(callback) ? callback : function() {
          };
          if ($visibleModals.length > 0) {
            module.debug("Hiding other modals", $otherModals);
            $visibleModals.modal("hide modal", callback, true);
          }
        },
        others: {
          active: function() {
            return $otherModals.filter("." + className.active).length > 0;
          },
          animating: function() {
            return $otherModals.filter("." + className.animating).length > 0;
          }
        },
        add: {
          keyboardShortcuts: function() {
            module.verbose("Adding keyboard shortcuts");
            $document.on("keydown" + eventNamespace, module.event.keyboard);
          }
        },
        save: {
          focus: function() {
            var $activeElement = $(document2.activeElement), inCurrentModal = $activeElement.closest($module).length > 0;
            if (!inCurrentModal) {
              $focusedElement = $(document2.activeElement).trigger("blur");
            }
          },
          bodyMargin: function() {
            initialBodyMargin = $context.css((isBody ? "margin-" : "padding-") + (module.can.leftBodyScrollbar() ? "left" : "right"));
            var bodyMarginRightPixel = parseInt(initialBodyMargin.replace(/[^\d.]/g, ""), 10), bodyScrollbarWidth = isBody ? window2.innerWidth - document2.documentElement.clientWidth : $context[0].offsetWidth - $context[0].clientWidth;
            tempBodyMargin = bodyMarginRightPixel + bodyScrollbarWidth;
          }
        },
        restore: {
          focus: function() {
            if ($focusedElement && $focusedElement.length > 0 && settings.restoreFocus) {
              $focusedElement.trigger("focus");
            }
          },
          bodyMargin: function() {
            var position = module.can.leftBodyScrollbar() ? "left" : "right";
            $context.css((isBody ? "margin-" : "padding-") + position, initialBodyMargin);
            $context.find(selector.bodyFixed.replace("right", position)).each(function() {
              var el = $(this), attribute = el.css("position") === "fixed" ? "padding-" + position : position;
              el.css(attribute, "");
            });
          }
        },
        remove: {
          active: function() {
            $module.removeClass(className.active);
          },
          legacy: function() {
            $module.removeClass(className.legacy);
          },
          clickaway: function() {
            if (!settings.detachable) {
              $module.off("mousedown" + elementEventNamespace);
            }
            $dimmer.off("mousedown" + elementEventNamespace);
            $dimmer.off("mouseup" + elementEventNamespace);
          },
          dimmerStyles: function() {
            $dimmer.removeClass(className.inverted);
            $dimmable.removeClass(className.blurring);
          },
          bodyStyle: function() {
            if ($context.attr("style") === "") {
              module.verbose("Removing style attribute");
              $context.removeAttr("style");
            }
          },
          screenHeight: function() {
            module.debug("Removing page height");
            $context.css("height", "");
            module.remove.bodyStyle();
          },
          keyboardShortcuts: function() {
            module.verbose("Removing keyboard shortcuts");
            $document.off("keydown" + eventNamespace);
          },
          scrolling: function() {
            if (!keepScrollingClass) {
              $dimmable.removeClass(className.scrolling);
            }
            $module.removeClass(className.scrolling);
          }
        },
        cacheSizes: function() {
          $module.addClass(className.loading);
          var scrollHeight = $module.prop("scrollHeight"), modalWidth = $module.outerWidth(), modalHeight = $module.outerHeight();
          if (module.cache.pageHeight === void 0 || modalHeight !== 0) {
            $.extend(module.cache, {
              pageHeight: $document.outerHeight(),
              width: modalWidth,
              height: modalHeight + settings.offset,
              scrollHeight: scrollHeight + settings.offset,
              contextHeight: isBody ? $window.height() : $dimmable.height()
            });
            module.cache.topOffset = -(module.cache.height / 2);
          }
          $module.removeClass(className.loading);
          module.debug("Caching modal and container sizes", module.cache);
        },
        helpers: {
          deQuote: function(string) {
            return String(string).replace(/"/g, "");
          },
          escape: function(string, preserveHTML) {
            if (preserveHTML) {
              return string;
            }
            var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#x27;",
              "`": "&#x60;"
            }, escapedChar = function(chr) {
              return escape2[chr];
            };
            if (shouldEscape.test(string)) {
              string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
              return string.replace(badChars, escapedChar);
            }
            return string;
          }
        },
        can: {
          leftBodyScrollbar: function() {
            if (module.cache.leftBodyScrollbar === void 0) {
              module.cache.leftBodyScrollbar = module.is.rtl() && (module.is.iframe && !module.is.firefox() || module.is.safari() || module.is.edge() || module.is.ie());
            }
            return module.cache.leftBodyScrollbar;
          },
          useFlex: function() {
            if (settings.useFlex === "auto") {
              return settings.detachable && !module.is.ie();
            }
            if (settings.useFlex && module.is.ie()) {
              module.debug("useFlex true is not supported in IE");
            } else if (settings.useFlex && !settings.detachable) {
              module.debug("useFlex true in combination with detachable false is not supported");
            }
            return settings.useFlex;
          },
          fit: function() {
            var contextHeight = module.cache.contextHeight, verticalCenter = module.cache.contextHeight / 2, topOffset = module.cache.topOffset, scrollHeight = module.cache.scrollHeight, height = module.cache.height, paddingHeight = settings.padding, startPosition = verticalCenter + topOffset;
            return scrollHeight > height ? startPosition + scrollHeight + paddingHeight < contextHeight : height + paddingHeight * 2 < contextHeight;
          }
        },
        has: {
          configActions: function() {
            return Array.isArray(settings.actions) && settings.actions.length > 0;
          },
          scrollbar: function() {
            return isBody || $context.css("overflow-y") !== "hidden";
          }
        },
        is: {
          active: function() {
            return $module.hasClass(className.active);
          },
          ie: function() {
            if (module.cache.isIE === void 0) {
              var isIE11 = !window2.ActiveXObject && "ActiveXObject" in window2, isIE = "ActiveXObject" in window2;
              module.cache.isIE = isIE11 || isIE;
            }
            return module.cache.isIE;
          },
          animating: function() {
            return $module.transition("is animating");
          },
          scrolling: function() {
            return $dimmable.hasClass(className.scrolling);
          },
          modernBrowser: function() {
            return !(window2.ActiveXObject || "ActiveXObject" in window2);
          },
          rtl: function() {
            if (module.cache.isRTL === void 0) {
              module.cache.isRTL = $module.attr("dir") === "rtl" || $module.css("direction") === "rtl" || $body.attr("dir") === "rtl" || $body.css("direction") === "rtl" || $context.attr("dir") === "rtl" || $context.css("direction") === "rtl";
            }
            return module.cache.isRTL;
          },
          safari: function() {
            if (module.cache.isSafari === void 0) {
              module.cache.isSafari = /constructor/i.test(window2.HTMLElement) || !!window2.ApplePaySession;
            }
            return module.cache.isSafari;
          },
          edge: function() {
            if (module.cache.isEdge === void 0) {
              module.cache.isEdge = !!window2.setImmediate && !module.is.ie();
            }
            return module.cache.isEdge;
          },
          firefox: function() {
            if (module.cache.isFirefox === void 0) {
              module.cache.isFirefox = !!window2.InstallTrigger;
            }
            return module.cache.isFirefox;
          },
          iframe: function() {
            return !(self === top);
          }
        },
        set: {
          observeAttributes: function(state) {
            observeAttributes = state !== false;
          },
          autofocus: function() {
            var $autofocus = $inputs.filter("[autofocus]"), $rawInputs = $inputs.filter(":input"), $input = $autofocus.length > 0 ? $autofocus.first() : ($rawInputs.length > 0 ? $rawInputs : $inputs.filter(":not(i.close)")).first();
            if ($input.length === 0 && $inputs.length > 0) {
              $input = $inputs.first();
            }
            if ($input.length > 0) {
              $input.trigger("focus");
            }
          },
          bodyMargin: function() {
            var position = module.can.leftBodyScrollbar() ? "left" : "right";
            if (settings.detachable || module.can.fit()) {
              $context.css((isBody ? "margin-" : "padding-") + position, tempBodyMargin + "px");
            }
            $context.find(selector.bodyFixed.replace("right", position)).each(function() {
              var el = $(this), attribute = el.css("position") === "fixed" ? "padding-" + position : position;
              el.css(attribute, "calc(" + el.css(attribute) + " + " + tempBodyMargin + "px)");
            });
          },
          clickaway: function() {
            if (!settings.detachable) {
              $module.on("mousedown" + elementEventNamespace, module.event.mousedown);
            }
            $dimmer.on("mousedown" + elementEventNamespace, module.event.mousedown);
            $dimmer.on("mouseup" + elementEventNamespace, module.event.mouseup);
          },
          dimmerSettings: function() {
            if ($.fn.dimmer === void 0) {
              module.error(error.dimmer);
              return;
            }
            var defaultSettings = {
              debug: settings.debug,
              dimmerName: "modals",
              closable: "auto",
              useFlex: module.can.useFlex(),
              duration: {
                show: settings.transition.showDuration || settings.duration,
                hide: settings.transition.hideDuration || settings.duration
              }
            }, dimmerSettings = $.extend(true, defaultSettings, settings.dimmerSettings);
            if (settings.inverted) {
              dimmerSettings.variation = dimmerSettings.variation !== void 0 ? dimmerSettings.variation + " inverted" : "inverted";
            }
            $context.dimmer("setting", dimmerSettings);
          },
          dimmerStyles: function() {
            if (settings.inverted) {
              $dimmer.addClass(className.inverted);
            } else {
              $dimmer.removeClass(className.inverted);
            }
            if (settings.blurring) {
              $dimmable.addClass(className.blurring);
            } else {
              $dimmable.removeClass(className.blurring);
            }
          },
          modalOffset: function() {
            if (!settings.detachable) {
              var canFit = module.can.fit();
              $module.css({
                top: !$module.hasClass("aligned") && canFit ? $document.scrollTop() + (module.cache.contextHeight - module.cache.height) / 2 : !canFit || $module.hasClass("top") ? $document.scrollTop() + settings.padding : $document.scrollTop() + (module.cache.contextHeight - module.cache.height - settings.padding),
                marginLeft: -(module.cache.width / 2)
              });
            } else {
              $module.css({
                marginTop: !$module.hasClass("aligned") && module.can.fit() ? -(module.cache.height / 2) : settings.padding / 2,
                marginLeft: -(module.cache.width / 2)
              });
            }
            module.verbose("Setting modal offset for legacy mode");
          },
          screenHeight: function() {
            if (module.can.fit()) {
              $context.css("height", "");
            } else if (!$module.hasClass("bottom")) {
              module.debug("Modal is taller than page content, resizing page height");
              $context.css("height", module.cache.height + settings.padding * 2 + "px");
            }
          },
          active: function() {
            $module.addClass(className.active + " " + className.front);
            $otherModals.filter("." + className.active).removeClass(className.front);
          },
          scrolling: function() {
            $dimmable.addClass(className.scrolling);
            $module.addClass(className.scrolling);
            module.unbind.scrollLock();
          },
          legacy: function() {
            $module.addClass(className.legacy);
          },
          type: function() {
            if (module.can.fit()) {
              module.verbose("Modal fits on screen");
              if (!module.others.active() && !module.others.animating()) {
                module.remove.scrolling();
                module.bind.scrollLock();
              }
            } else if (!$module.hasClass("bottom")) {
              module.verbose("Modal cannot fit on screen setting to scrolling");
              module.set.scrolling();
            } else {
              module.verbose("Bottom aligned modal not fitting on screen is unsupported for scrolling");
            }
          },
          undetached: function() {
            $dimmable.addClass(className.undetached);
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          if (isFunction(settings.templates[query])) {
            settings.autoShow = true;
            settings.className.modal = settings.className.template;
            settings = $.extend(true, {}, settings, settings.templates[query].apply(module, queryArguments));
            className = settings.className;
            namespace = settings.namespace;
            fields = settings.fields;
            error = settings.error;
          }
          module.initialize();
        }
        if (!isFunction(settings.templates[query])) {
          module.invoke(query);
        }
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
        returnedValue = $module;
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.modal = $.fn.modal;
  $.fn.modal.settings = {
    name: "Modal",
    namespace: "modal",
    useFlex: "auto",
    offset: 0,
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    observeChanges: false,
    allowMultiple: false,
    detachable: true,
    closable: true,
    autofocus: true,
    restoreFocus: true,
    autoShow: false,
    inverted: false,
    blurring: false,
    centered: true,
    dimmerSettings: {
      closable: false,
      useCSS: true
    },
    // whether to use keyboard shortcuts
    keyboardShortcuts: true,
    context: "body",
    queue: false,
    duration: 500,
    transition: "scale",
    // padding with edge of page
    padding: 50,
    scrollbarWidth: 10,
    // dynamic content
    title: "",
    content: "",
    class: "",
    classTitle: "",
    classContent: "",
    classActions: "",
    closeIcon: false,
    actions: false,
    preserveHTML: true,
    fields: {
      class: "class",
      text: "text",
      icon: "icon",
      click: "click"
    },
    // called before show animation
    onShow: function() {
    },
    // called after show animation
    onVisible: function() {
    },
    // called before hide animation
    onHide: function() {
      return true;
    },
    // called after hide animation
    onHidden: false,
    // called after approve selector match
    onApprove: function() {
      return true;
    },
    // called after deny selector match
    onDeny: function() {
      return true;
    },
    keys: {
      space: 32,
      enter: 13,
      escape: 27,
      tab: 9
    },
    selector: {
      title: "> .header",
      content: "> .content",
      actions: "> .actions",
      close: "> .close",
      closeIcon: "> .close",
      approve: ".actions .positive, .actions .approve, .actions .ok",
      deny: ".actions .negative, .actions .deny, .actions .cancel",
      modal: ".ui.modal",
      dimmer: "> .ui.dimmer",
      bodyFixed: "> .ui.fixed.menu, > .ui.right.toast-container, > .ui.right.sidebar, > .ui.fixed.nag, > .ui.fixed.nag > .close",
      prompt: ".ui.input > input"
    },
    error: {
      dimmer: "UI Dimmer, a required component is not included in this page",
      method: "The method you called is not defined.",
      notFound: "The element you specified could not be found"
    },
    className: {
      active: "active",
      animating: "animating",
      blurring: "blurring",
      inverted: "inverted",
      legacy: "legacy",
      loading: "loading",
      scrolling: "scrolling",
      undetached: "undetached",
      front: "front",
      close: "close icon",
      button: "ui button",
      modal: "ui modal",
      title: "header",
      content: "content",
      actions: "actions",
      template: "ui tiny modal",
      ok: "positive",
      cancel: "negative",
      prompt: "ui fluid input",
      innerDimmer: "ui inverted dimmer"
    },
    text: {
      ok: "Ok",
      cancel: "Cancel",
      close: "Close"
    }
  };
  $.fn.modal.settings.templates = {
    getArguments: function(args) {
      var queryArguments = [].slice.call(args);
      if ($.isPlainObject(queryArguments[0])) {
        return $.extend({
          handler: function() {
          },
          content: "",
          title: ""
        }, queryArguments[0]);
      }
      if (!isFunction(queryArguments[queryArguments.length - 1])) {
        queryArguments.push(function() {
        });
      }
      return {
        handler: queryArguments.pop(),
        content: queryArguments.pop() || "",
        title: queryArguments.pop() || ""
      };
    },
    alert: function() {
      var settings = this.get.settings(), args = settings.templates.getArguments(arguments), approveFn = args.handler;
      return {
        title: args.title,
        content: args.content,
        onApprove: approveFn,
        actions: [{
          text: settings.text.ok,
          class: settings.className.ok,
          click: approveFn
        }]
      };
    },
    confirm: function() {
      var settings = this.get.settings(), args = settings.templates.getArguments(arguments), approveFn = function() {
        args.handler(true);
      }, denyFn = function() {
        args.handler(false);
      };
      return {
        title: args.title,
        content: args.content,
        onApprove: approveFn,
        onDeny: denyFn,
        actions: [{
          text: settings.text.ok,
          class: settings.className.ok,
          click: approveFn
        }, {
          text: settings.text.cancel,
          class: settings.className.cancel,
          click: denyFn
        }]
      };
    },
    prompt: function() {
      var $this = this, settings = this.get.settings(), args = settings.templates.getArguments(arguments), input = $($.parseHTML(args.content)).filter(".ui.input"), approveFn = function() {
        var settings2 = $this.get.settings(), inputField = $this.get.element().find(settings2.selector.prompt)[0];
        args.handler($(inputField).val());
      }, denyFn = function() {
        args.handler(null);
      };
      if (input.length === 0) {
        args.content += '<p><div class="' + this.helpers.deQuote(settings.className.prompt) + '"><input placeholder="' + this.helpers.deQuote(args.placeholder || "") + '" type="text" value="' + this.helpers.deQuote(args.defaultValue || "") + '"></div></p>';
      }
      return {
        title: args.title,
        content: args.content,
        onApprove: approveFn,
        onDeny: denyFn,
        actions: [{
          text: settings.text.ok,
          class: settings.className.ok,
          click: approveFn
        }, {
          text: settings.text.cancel,
          class: settings.className.cancel,
          click: denyFn
        }]
      };
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.nag = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.nag.settings, parameters) : $.extend({}, $.fn.nag.settings), selector = settings.selector, error = settings.error, namespace = settings.namespace, eventNamespace = "." + namespace, moduleNamespace = namespace + "-module", $module = $(this), $context = settings.context ? [window2, document2].indexOf(settings.context) < 0 ? $(document2).find(settings.context) : $(settings.context) : $("body"), element2 = this, instance68 = $module.data(moduleNamespace), storage, module;
      module = {
        initialize: function() {
          module.verbose("Initializing element");
          if (typeof settings.value !== "string") {
            settings.value = JSON.stringify(settings.value);
          }
          storage = module.get.storage();
          $module.on("click" + eventNamespace, selector.close, module.dismiss).data(moduleNamespace, module);
          if (settings.detachable && $module.parent()[0] !== $context[0]) {
            $module.detach().prependTo($context);
          }
          if (settings.displayTime > 0) {
            setTimeout(module.hide, settings.displayTime);
          }
          module.show();
        },
        destroy: function() {
          module.verbose("Destroying instance");
          $module.removeData(moduleNamespace).off(eventNamespace);
        },
        show: function() {
          if (module.should.show() && !$module.is(":visible")) {
            if (settings.onShow.call(element2) === false) {
              module.debug("onShow callback returned false, cancelling nag animation");
              return false;
            }
            module.debug("Showing nag", settings.animation.show);
            if (settings.animation.show === "fade") {
              $module.fadeIn(settings.duration, settings.easing, settings.onVisible);
            } else {
              $module.slideDown(settings.duration, settings.easing, settings.onVisible);
            }
          }
        },
        hide: function() {
          if (settings.onHide.call(element2) === false) {
            module.debug("onHide callback returned false, cancelling nag animation");
            return false;
          }
          module.debug("Hiding nag", settings.animation.hide);
          if (settings.animation.hide === "fade") {
            $module.fadeOut(settings.duration, settings.easing, settings.onHidden);
          } else {
            $module.slideUp(settings.duration, settings.easing, settings.onHidden);
          }
        },
        dismiss: function(event2) {
          if (module.hide() !== false && settings.storageMethod) {
            module.debug("Dismissing nag", settings.storageMethod, settings.key, settings.value, settings.expires);
            module.storage.set(settings.key, settings.value);
          }
          event2.stopImmediatePropagation();
          event2.preventDefault();
        },
        should: {
          show: function() {
            if (settings.persist) {
              module.debug("Persistent nag is set, can show nag");
              return true;
            }
            if (module.storage.get(settings.key) != settings.value.toString()) {
              module.debug("Stored value is not set, can show nag", module.storage.get(settings.key));
              return true;
            }
            module.debug("Stored value is set, cannot show nag", module.storage.get(settings.key));
            return false;
          }
        },
        get: {
          expirationDate: function(expires) {
            if (typeof expires === "number") {
              expires = new Date(Date.now() + expires * 864e5);
            }
            if (expires instanceof Date && expires.getTime()) {
              return expires.toUTCString();
            }
            module.error(error.expiresFormat);
          },
          storage: function() {
            if (settings.storageMethod === "localstorage" && window2.localStorage !== void 0) {
              module.debug("Using local storage");
              return window2.localStorage;
            }
            if (settings.storageMethod === "sessionstorage" && window2.sessionStorage !== void 0) {
              module.debug("Using session storage");
              return window2.sessionStorage;
            }
            if ("cookie" in document2) {
              module.debug("Using cookie");
              return {
                setItem: function(key, value, options) {
                  key = encodeURIComponent(key).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
                  value = encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[B-D])/g, decodeURIComponent);
                  var cookieOptions = "";
                  for (var option in options) {
                    if (Object.prototype.hasOwnProperty.call(options, option)) {
                      cookieOptions += "; " + option;
                      if (typeof options[option] === "string") {
                        cookieOptions += "=" + options[option].split(";")[0];
                      }
                    }
                  }
                  document2.cookie = key + "=" + value + cookieOptions;
                },
                getItem: function(key) {
                  var cookies = document2.cookie.split("; ");
                  for (var i = 0, il = cookies.length; i < il; i++) {
                    var parts = cookies[i].split("="), foundKey = parts[0].replace(/(%[\da-f]{2})+/gi, decodeURIComponent);
                    if (key === foundKey) {
                      return parts[1] || "";
                    }
                  }
                },
                removeItem: function(key, options) {
                  storage.setItem(key, "", options);
                }
              };
            }
            module.error(error.noStorage);
          },
          storageOptions: function() {
            var options = {};
            if (settings.expires) {
              options.expires = module.get.expirationDate(settings.expires);
            }
            if (settings.domain) {
              options.domain = settings.domain;
            }
            if (settings.path) {
              options.path = settings.path;
            }
            if (settings.secure) {
              options.secure = settings.secure;
            }
            if (settings.samesite) {
              options.samesite = settings.samesite;
            }
            return options;
          }
        },
        clear: function() {
          module.storage.remove(settings.key);
        },
        storage: {
          set: function(key, value) {
            var options = module.get.storageOptions();
            if (storage === window2.localStorage && options.expires) {
              module.debug("Storing expiration value in localStorage", key, options.expires);
              storage.setItem(key + settings.expirationKey, options.expires);
            }
            module.debug("Value stored", key, value);
            try {
              storage.setItem(key, value, options);
            } catch (e) {
              module.error(error.setItem, e);
            }
          },
          get: function(key) {
            var storedValue;
            storedValue = storage.getItem(key);
            if (storage === window2.localStorage) {
              var expiration = storage.getItem(key + settings.expirationKey);
              if (expiration !== null && expiration !== void 0 && new Date(expiration) < new Date()) {
                module.debug("Value in localStorage has expired. Deleting key", key);
                module.storage.remove(key);
                storedValue = null;
              }
            }
            if (storedValue === "undefined" || storedValue === "null" || storedValue === void 0 || storedValue === null) {
              storedValue = void 0;
            }
            return storedValue;
          },
          remove: function(key) {
            var options = module.get.storageOptions();
            options.expires = module.get.expirationDate(-1);
            if (storage === window2.localStorage) {
              storage.removeItem(key + settings.expirationKey);
            }
            storage.removeItem(key, options);
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.nag.settings = {
    name: "Nag",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    namespace: "Nag",
    // allows cookie to be overridden
    persist: false,
    // set to zero to require manually dismissal, otherwise hides on its own
    displayTime: 0,
    animation: {
      show: "slide",
      hide: "slide"
    },
    context: false,
    detachable: false,
    expires: 30,
    // cookie storage only options
    domain: false,
    path: "/",
    secure: false,
    samesite: false,
    // type of storage to use
    storageMethod: "cookie",
    // value to store in dismissed localstorage/cookie
    key: "nag",
    value: "dismiss",
    // Key suffix to support expiration in localstorage
    expirationKey: "ExpirationDate",
    error: {
      noStorage: "Unsupported storage method",
      method: "The method you called is not defined.",
      setItem: "Unexpected error while setting value",
      expiresFormat: '"expires" must be a number of days or a Date Object'
    },
    className: {
      bottom: "bottom",
      fixed: "fixed"
    },
    selector: {
      close: "> .close.icon"
    },
    duration: 500,
    easing: "easeOutQuad",
    // callback before show animation, return false to prevent show
    onShow: function() {
    },
    // called after show animation
    onVisible: function() {
    },
    // callback before hide animation, return false to prevent hide
    onHide: function() {
    },
    // callback after hide animation
    onHidden: function() {
    }
  };
  $.extend($.easing, {
    easeOutQuad: function(x) {
      return 1 - (1 - x) * (1 - x);
    }
  });
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.popup = function(parameters) {
    var $allModules = $(this), $document = $(document2), $window = $(window2), $body = $("body"), moduleSelector = $allModules.selector || "", clickEvent = "ontouchstart" in document2.documentElement ? "touchstart" : "click", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.popup.settings, parameters) : $.extend({}, $.fn.popup.settings), selector = settings.selector, className = settings.className, error = settings.error, metadata = settings.metadata, namespace = settings.namespace, eventNamespace = "." + settings.namespace, moduleNamespace = "module-" + namespace, $module = $(this), $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $(settings.context), $scrollContext = [window2, document2].indexOf(settings.scrollContext) < 0 ? $document.find(settings.scrollContext) : $(settings.scrollContext), $boundary = [window2, document2].indexOf(settings.boundary) < 0 ? $document.find(settings.boundary) : $(settings.boundary), $target = settings.target ? [window2, document2].indexOf(settings.target) < 0 ? $document.find(settings.target) : $(settings.target) : $module, $popup, $offsetParent, searchDepth = 0, triedPositions = false, openedWithTouch = false, element2 = this, instance68 = $module.data(moduleNamespace), documentObserver, elementNamespace, id, module;
      module = {
        // binds events
        initialize: function() {
          module.debug("Initializing", $module);
          module.createID();
          module.bind.events();
          if (!module.exists() && settings.preserve) {
            module.create();
          }
          if (settings.observeChanges) {
            module.observeChanges();
          }
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance", module);
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            documentObserver = new MutationObserver(module.event.documentChanged);
            documentObserver.observe(document2, {
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", documentObserver);
          }
        },
        refresh: function() {
          if (settings.popup) {
            $popup = $document.find(settings.popup).eq(0);
          } else {
            if (settings.inline) {
              $popup = $target.nextAll(selector.popup).eq(0);
              settings.popup = $popup;
            }
          }
          if (settings.popup) {
            module.set.invisible();
            $offsetParent = module.get.offsetParent();
            module.remove.invisible();
            if (settings.movePopup && module.has.popup() && module.get.offsetParent($popup)[0] !== $offsetParent[0]) {
              module.debug("Moving popup to the same offset parent as target");
              $popup.detach().appendTo($offsetParent);
            }
          } else {
            $offsetParent = settings.inline ? module.get.offsetParent($target) : module.has.popup() ? module.get.offsetParent($popup) : $body;
          }
          if ($offsetParent.is("html") && $offsetParent[0] !== $body[0]) {
            module.debug("Setting page as offset parent");
            $offsetParent = $body;
          }
          if (module.get.variation()) {
            module.set.variation();
          }
        },
        reposition: function() {
          module.refresh();
          module.set.position();
        },
        destroy: function() {
          module.debug("Destroying previous module");
          if (documentObserver) {
            documentObserver.disconnect();
          }
          if ($popup && !settings.preserve) {
            module.removePopup();
          }
          clearTimeout(module.hideTimer);
          clearTimeout(module.showTimer);
          module.unbind.close();
          module.unbind.events();
          $module.removeData(moduleNamespace);
        },
        event: {
          start: function(event2) {
            var delay = $.isPlainObject(settings.delay) ? settings.delay.show : settings.delay;
            clearTimeout(module.hideTimer);
            if (!openedWithTouch || openedWithTouch && settings.addTouchEvents) {
              module.showTimer = setTimeout(module.show, delay);
            }
          },
          end: function() {
            var delay = $.isPlainObject(settings.delay) ? settings.delay.hide : settings.delay;
            clearTimeout(module.showTimer);
            module.hideTimer = setTimeout(module.hide, delay);
          },
          touchstart: function(event2) {
            openedWithTouch = true;
            if (settings.addTouchEvents) {
              module.show();
            }
          },
          resize: function() {
            if (module.is.visible()) {
              module.set.position();
            }
          },
          documentChanged: function(mutations) {
            [].forEach.call(mutations, function(mutation) {
              if (mutation.removedNodes) {
                [].forEach.call(mutation.removedNodes, function(node) {
                  if (node === element2 || $(node).find(element2).length > 0) {
                    module.debug("Element removed from DOM, tearing down events");
                    module.destroy();
                  }
                });
              }
            });
          },
          hideGracefully: function(event2) {
            var $target2 = $(event2.target), isInDOM = $.contains(document2.documentElement, event2.target), inPopup = $target2.closest(selector.popup).length > 0;
            if (event2 && !inPopup && isInDOM) {
              module.debug("Click occurred outside popup hiding popup");
              module.hide();
            } else {
              module.debug("Click was inside popup, keeping popup open");
            }
          }
        },
        // generates popup html from metadata
        create: function() {
          var html = module.get.html(), title = module.get.title(), content = module.get.content();
          if (html || content || title) {
            module.debug("Creating pop-up html");
            if (!html) {
              html = settings.templates.popup({
                title,
                content
              });
            }
            $popup = $("<div/>").addClass(className.popup).data(metadata.activator, $module).html(html);
            if (settings.inline) {
              module.verbose("Inserting popup element inline", $popup);
              $popup.insertAfter($module);
            } else {
              module.verbose("Appending popup element to body", $popup);
              $popup.appendTo($context);
            }
            module.refresh();
            module.set.variation();
            if (settings.hoverable) {
              module.bind.popup();
            }
            settings.onCreate.call($popup, element2);
          } else if (settings.popup) {
            $document.find(settings.popup).data(metadata.activator, $module);
            module.verbose("Used popup specified in settings");
            module.refresh();
            if (settings.hoverable) {
              module.bind.popup();
            }
          } else if ($target.next(selector.popup).length > 0) {
            module.verbose("Pre-existing popup found");
            settings.inline = true;
            settings.popup = $target.next(selector.popup).data(metadata.activator, $module);
            module.refresh();
            if (settings.hoverable) {
              module.bind.popup();
            }
          } else {
            module.debug("No content specified skipping display", element2);
          }
        },
        createID: function() {
          id = (Math.random().toString(16) + "000000000").slice(2, 10);
          elementNamespace = "." + id;
          module.verbose("Creating unique id for element", id);
        },
        // determines popup state
        toggle: function() {
          module.debug("Toggling pop-up");
          if (module.is.hidden()) {
            module.debug("Popup is hidden, showing pop-up");
            module.unbind.close();
            module.show();
          } else {
            module.debug("Popup is visible, hiding pop-up");
            module.hide();
          }
        },
        show: function(callback) {
          callback = callback || function() {
          };
          module.debug("Showing pop-up", settings.transition);
          if (module.is.hidden() && !(module.is.active() && module.is.dropdown())) {
            if (!module.exists()) {
              module.create();
            }
            if (settings.onShow.call($popup, element2) === false) {
              module.debug("onShow callback returned false, cancelling popup animation");
              return;
            }
            if (!settings.preserve && !settings.popup) {
              module.refresh();
            }
            if ($popup && module.set.position()) {
              module.save.conditions();
              if (settings.exclusive) {
                module.hideAll();
              }
              module.animate.show(callback);
            }
          }
        },
        hide: function(callback) {
          callback = callback || function() {
          };
          if (module.is.visible() || module.is.animating()) {
            if (settings.onHide.call($popup, element2) === false) {
              module.debug("onHide callback returned false, cancelling popup animation");
              return;
            }
            module.remove.visible();
            module.unbind.close();
            module.restore.conditions();
            module.animate.hide(callback);
          }
        },
        hideAll: function() {
          $document.find(selector.popup).filter("." + className.popupVisible).each(function() {
            $(this).data(metadata.activator).popup("hide");
          });
        },
        exists: function() {
          if (!$popup) {
            return false;
          }
          if (settings.inline || settings.popup) {
            return module.has.popup();
          }
          return $popup.closest($context).length > 0;
        },
        removePopup: function() {
          if (module.has.popup() && !settings.popup) {
            module.debug("Removing popup", $popup);
            $popup.remove();
            $popup = void 0;
            settings.onRemove.call($popup, element2);
          }
        },
        save: {
          conditions: function() {
            module.cache = {
              title: $module.attr("title")
            };
            if (module.cache.title) {
              $module.removeAttr("title");
            }
            module.verbose("Saving original attributes", module.cache.title);
          }
        },
        restore: {
          conditions: function() {
            if (module.cache && module.cache.title) {
              $module.attr("title", module.cache.title);
              module.verbose("Restoring original attributes", module.cache.title);
            }
            return true;
          }
        },
        supports: {
          svg: function() {
            return typeof SVGGraphicsElement !== "undefined";
          }
        },
        animate: {
          show: function(callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            if (settings.transition && module.can.useElement("transition")) {
              module.set.visible();
              $popup.transition({
                animation: (settings.transition.showMethod || settings.transition) + " in",
                queue: false,
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                duration: settings.transition.showDuration || settings.duration,
                onComplete: function() {
                  module.bind.close();
                  callback.call($popup, element2);
                  settings.onVisible.call($popup, element2);
                }
              });
            }
          },
          hide: function(callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            module.debug("Hiding pop-up");
            if (settings.transition && $.fn.transition !== void 0) {
              $popup.transition({
                animation: (settings.transition.hideMethod || settings.transition) + " out",
                queue: false,
                duration: settings.transition.hideDuration || settings.duration,
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                onComplete: function() {
                  module.reset();
                  callback.call($popup, element2);
                  settings.onHidden.call($popup, element2);
                }
              });
            } else {
              module.error(error.noTransition);
            }
          }
        },
        change: {
          content: function(html) {
            $popup.html(html);
          }
        },
        get: {
          html: function() {
            $module.removeData(metadata.html);
            return $module.data(metadata.html) || settings.html;
          },
          title: function() {
            $module.removeData(metadata.title);
            return $module.data(metadata.title) || settings.title;
          },
          content: function() {
            $module.removeData(metadata.content);
            return $module.data(metadata.content) || settings.content || $module.attr("title");
          },
          variation: function() {
            $module.removeData(metadata.variation);
            return $module.data(metadata.variation) || settings.variation;
          },
          popup: function() {
            return $popup;
          },
          popupOffset: function() {
            return $popup.offset();
          },
          calculations: function() {
            var $popupOffsetParent = module.get.offsetParent($popup), targetElement = $target[0], isWindowEl = $boundary[0] === window2, targetOffset = $target.offset(), parentOffset = settings.inline || settings.popup && settings.movePopup ? $target.offsetParent().offset() : { top: 0, left: 0 }, screenPosition = isWindowEl ? { top: 0, left: 0 } : $boundary.offset(), calculations = {}, scroll = isWindowEl ? { top: $window.scrollTop(), left: $window.scrollLeft() } : { top: 0, left: 0 }, screen;
            calculations = {
              // element which is launching popup
              target: {
                element: $target[0],
                width: $target.outerWidth(),
                height: $target.outerHeight(),
                top: targetOffset.top - parentOffset.top,
                left: targetOffset.left - parentOffset.left,
                margin: {}
              },
              // popup itself
              popup: {
                width: $popup.outerWidth(),
                height: $popup.outerHeight()
              },
              // offset container (or 3d context)
              parent: {
                width: $offsetParent.outerWidth(),
                height: $offsetParent.outerHeight()
              },
              // screen boundaries
              screen: {
                top: screenPosition.top,
                left: screenPosition.left,
                scroll: {
                  top: scroll.top,
                  left: scroll.left
                },
                width: $boundary.width(),
                height: $boundary.height()
              }
            };
            if ($popupOffsetParent[0] !== $offsetParent[0]) {
              var popupOffset = $popupOffsetParent.offset();
              calculations.target.top -= popupOffset.top;
              calculations.target.left -= popupOffset.left;
              calculations.parent.width = $popupOffsetParent.outerWidth();
              calculations.parent.height = $popupOffsetParent.outerHeight();
            }
            if (settings.setFluidWidth && module.is.fluid()) {
              calculations.container = {
                width: $popup.parent().outerWidth()
              };
              calculations.popup.width = calculations.container.width;
            }
            calculations.target.margin.top = settings.inline ? parseInt(window2.getComputedStyle(targetElement).getPropertyValue("margin-top"), 10) : 0;
            calculations.target.margin.left = settings.inline ? module.is.rtl() ? parseInt(window2.getComputedStyle(targetElement).getPropertyValue("margin-right"), 10) : parseInt(window2.getComputedStyle(targetElement).getPropertyValue("margin-left"), 10) : 0;
            screen = calculations.screen;
            calculations.boundary = {
              top: screen.top + screen.scroll.top,
              bottom: screen.top + screen.scroll.top + screen.height,
              left: screen.left + screen.scroll.left,
              right: screen.left + screen.scroll.left + screen.width
            };
            return calculations;
          },
          id: function() {
            return id;
          },
          startEvent: function() {
            if (settings.on === "hover") {
              return "mouseenter";
            }
            if (settings.on === "focus") {
              return "focus";
            }
            return false;
          },
          scrollEvent: function() {
            return "scroll";
          },
          endEvent: function() {
            if (settings.on === "hover") {
              return "mouseleave";
            }
            if (settings.on === "focus") {
              return "blur";
            }
            return false;
          },
          distanceFromBoundary: function(offset, calculations) {
            var distanceFromBoundary = {}, popup, boundary;
            calculations = calculations || module.get.calculations();
            popup = calculations.popup;
            boundary = calculations.boundary;
            if (offset) {
              distanceFromBoundary = {
                top: offset.top - boundary.top,
                left: offset.left - boundary.left,
                right: boundary.right - (offset.left + popup.width),
                bottom: boundary.bottom - (offset.top + popup.height)
              };
              module.verbose("Distance from boundaries determined", offset, distanceFromBoundary);
            }
            return distanceFromBoundary;
          },
          offsetParent: function($element) {
            var element3 = $element !== void 0 ? $element[0] : $target[0], parentNode = element3.parentNode, $node = $(parentNode);
            if (parentNode) {
              var is2D = $node.css("transform") === "none", isStatic = $node.css("position") === "static", isBody = $node.is("body");
              while (parentNode && !isBody && isStatic && is2D) {
                parentNode = parentNode.parentNode;
                $node = $(parentNode);
                is2D = $node.css("transform") === "none";
                isStatic = $node.css("position") === "static";
                isBody = $node.is("body");
              }
            }
            return $node && $node.length > 0 ? $node : $();
          },
          positions: function() {
            return {
              "top left": false,
              "top center": false,
              "top right": false,
              "bottom left": false,
              "bottom center": false,
              "bottom right": false,
              "left center": false,
              "right center": false
            };
          },
          nextPosition: function(position) {
            var positions = position.split(" "), verticalPosition = positions[0], horizontalPosition = positions[1], opposite = {
              top: "bottom",
              bottom: "top",
              left: "right",
              right: "left"
            }, adjacent = {
              left: "center",
              center: "right",
              right: "left"
            }, backup = {
              "top left": "top center",
              "top center": "top right",
              "top right": "right center",
              "right center": "bottom right",
              "bottom right": "bottom center",
              "bottom center": "bottom left",
              "bottom left": "left center",
              "left center": "top left"
            }, adjacentsAvailable = verticalPosition === "top" || verticalPosition === "bottom", oppositeTried = false, adjacentTried = false, nextPosition = false;
            if (!triedPositions) {
              module.verbose("All available positions available");
              triedPositions = module.get.positions();
            }
            module.debug("Recording last position tried", position);
            triedPositions[position] = true;
            if (settings.prefer === "opposite") {
              nextPosition = [opposite[verticalPosition], horizontalPosition];
              nextPosition = nextPosition.join(" ");
              oppositeTried = triedPositions[nextPosition] === true;
              module.debug("Trying opposite strategy", nextPosition);
            }
            if (settings.prefer === "adjacent" && adjacentsAvailable) {
              nextPosition = [verticalPosition, adjacent[horizontalPosition]];
              nextPosition = nextPosition.join(" ");
              adjacentTried = triedPositions[nextPosition] === true;
              module.debug("Trying adjacent strategy", nextPosition);
            }
            if (adjacentTried || oppositeTried) {
              module.debug("Using backup position", nextPosition);
              nextPosition = backup[position];
            }
            return nextPosition;
          }
        },
        set: {
          position: function(position, calculations) {
            if ($target.length === 0 || $popup.length === 0) {
              module.error(error.notFound);
              return;
            }
            var offset, distanceAway, target, popup, parent, positioning, popupOffset, distanceFromBoundary;
            calculations = calculations || module.get.calculations();
            position = position || $module.data(metadata.position) || settings.position;
            offset = $module.data(metadata.offset) || settings.offset;
            distanceAway = settings.distanceAway;
            target = calculations.target;
            popup = calculations.popup;
            parent = calculations.parent;
            if (module.should.centerArrow(calculations)) {
              module.verbose("Adjusting offset to center arrow on small target element");
              if (position === "top left" || position === "bottom left") {
                offset += target.width / 2;
                offset -= settings.arrowPixelsFromEdge;
              }
              if (position === "top right" || position === "bottom right") {
                offset -= target.width / 2;
                offset += settings.arrowPixelsFromEdge;
              }
            }
            if (target.width === 0 && target.height === 0 && !module.is.svg(target.element)) {
              module.debug("Popup target is hidden, no action taken");
              return false;
            }
            if (settings.inline) {
              module.debug("Adding margin to calculation", target.margin);
              if (position === "left center" || position === "right center") {
                offset += target.margin.top;
                distanceAway += -target.margin.left;
              } else if (position === "top left" || position === "top center" || position === "top right") {
                offset += target.margin.left;
                distanceAway -= target.margin.top;
              } else {
                offset += target.margin.left;
                distanceAway += target.margin.top;
              }
            }
            module.debug("Determining popup position from calculations", position, calculations);
            if (module.is.rtl()) {
              position = position.replace(/left|right/g, function(match) {
                return match === "left" ? "right" : "left";
              });
              module.debug("RTL: Popup position updated", position);
            }
            if (searchDepth === settings.maxSearchDepth && typeof settings.lastResort === "string") {
              position = settings.lastResort;
            }
            switch (position) {
              case "top left": {
                positioning = {
                  top: "auto",
                  bottom: parent.height - target.top + distanceAway,
                  left: target.left + offset,
                  right: "auto"
                };
                break;
              }
              case "top center": {
                positioning = {
                  bottom: parent.height - target.top + distanceAway,
                  left: target.left + target.width / 2 - popup.width / 2 + offset,
                  top: "auto",
                  right: "auto"
                };
                break;
              }
              case "top right": {
                positioning = {
                  bottom: parent.height - target.top + distanceAway,
                  right: parent.width - target.left - target.width - offset,
                  top: "auto",
                  left: "auto"
                };
                break;
              }
              case "left center": {
                positioning = {
                  top: target.top + target.height / 2 - popup.height / 2 + offset,
                  right: parent.width - target.left + distanceAway,
                  left: "auto",
                  bottom: "auto"
                };
                break;
              }
              case "right center": {
                positioning = {
                  top: target.top + target.height / 2 - popup.height / 2 + offset,
                  left: target.left + target.width + distanceAway,
                  bottom: "auto",
                  right: "auto"
                };
                break;
              }
              case "bottom left": {
                positioning = {
                  top: target.top + target.height + distanceAway,
                  left: target.left + offset,
                  bottom: "auto",
                  right: "auto"
                };
                break;
              }
              case "bottom center": {
                positioning = {
                  top: target.top + target.height + distanceAway,
                  left: target.left + target.width / 2 - popup.width / 2 + offset,
                  bottom: "auto",
                  right: "auto"
                };
                break;
              }
              case "bottom right": {
                positioning = {
                  top: target.top + target.height + distanceAway,
                  right: parent.width - target.left - target.width - offset,
                  left: "auto",
                  bottom: "auto"
                };
                break;
              }
            }
            if (positioning === void 0) {
              module.error(error.invalidPosition, position);
            }
            module.debug("Calculated popup positioning values", positioning);
            $popup.css(positioning).removeClass(className.position).addClass(position);
            module.set.invisible();
            popupOffset = module.get.popupOffset();
            distanceFromBoundary = module.get.distanceFromBoundary(popupOffset, calculations);
            if (!settings.forcePosition && module.is.offstage(distanceFromBoundary, position)) {
              module.debug("Position is outside viewport", position);
              if (searchDepth < settings.maxSearchDepth) {
                searchDepth++;
                position = module.get.nextPosition(position);
                module.debug("Trying new position", position);
                return $popup ? module.set.position(position, calculations) : false;
              }
              if (settings.lastResort) {
                module.debug("No position found, showing with last position");
              } else {
                module.debug("Popup could not find a position to display", $popup);
                module.error(error.cannotPlace, element2);
                module.remove.attempts();
                module.remove.invisible();
                module.reset();
                settings.onUnplaceable.call($popup, element2);
                return false;
              }
            }
            module.debug("Position is on stage", position);
            module.remove.attempts();
            module.remove.invisible();
            if (settings.setFluidWidth && module.is.fluid()) {
              module.set.fluidWidth(calculations);
            }
            return true;
          },
          fluidWidth: function(calculations) {
            calculations = calculations || module.get.calculations();
            module.debug("Automatically setting element width to parent width", calculations.parent.width);
            $popup.css("width", calculations.container.width);
          },
          loading: function() {
            $popup.addClass(className.loading);
          },
          invisible: function() {
            $popup.addClass(className.invisible);
          },
          variation: function(variation) {
            variation = variation || module.get.variation();
            if (variation && module.has.popup()) {
              module.verbose("Adding variation to popup", variation);
              $popup.addClass(variation);
            }
          },
          visible: function() {
            $module.addClass(className.visible);
          }
        },
        remove: {
          loading: function() {
            $popup.removeClass(className.loading);
          },
          invisible: function() {
            $popup.removeClass(className.invisible);
          },
          variation: function(variation) {
            variation = variation || module.get.variation();
            if (variation) {
              module.verbose("Removing variation", variation);
              $popup.removeClass(variation);
            }
          },
          visible: function() {
            $module.removeClass(className.visible);
          },
          attempts: function() {
            module.verbose("Resetting all searched positions");
            searchDepth = 0;
            triedPositions = false;
          }
        },
        bind: {
          events: function() {
            module.debug("Binding popup events to module");
            if (settings.on === "click") {
              $module.on(clickEvent + eventNamespace, module.toggle);
            }
            if (settings.on === "hover") {
              $module.on("touchstart" + eventNamespace, module.event.touchstart);
            }
            if (module.get.startEvent()) {
              $module.on(module.get.startEvent() + eventNamespace, module.event.start).on(module.get.endEvent() + eventNamespace, module.event.end);
            }
            if (settings.target) {
              module.debug("Target set to element", $target);
            }
            $window.on("resize" + elementNamespace, module.event.resize);
          },
          popup: function() {
            module.verbose("Allowing hover events on popup to prevent closing");
            if ($popup && module.has.popup()) {
              $popup.on("mouseenter" + eventNamespace, module.event.start).on("mouseleave" + eventNamespace, module.event.end);
            }
          },
          close: function() {
            if (settings.hideOnScroll === true || settings.hideOnScroll === "auto" && settings.on !== "click") {
              module.bind.closeOnScroll();
            }
            if (module.is.closable()) {
              module.bind.clickaway();
            } else if (settings.on === "hover" && openedWithTouch) {
              module.bind.touchClose();
            }
          },
          closeOnScroll: function() {
            module.verbose("Binding scroll close event to document");
            $scrollContext.one(module.get.scrollEvent() + elementNamespace, module.event.hideGracefully);
          },
          touchClose: function() {
            module.verbose("Binding popup touchclose event to document");
            $document.on("touchstart" + elementNamespace, function(event2) {
              module.verbose("Touched away from popup");
              module.event.hideGracefully.call(element2, event2);
            });
          },
          clickaway: function() {
            module.verbose("Binding popup close event to document");
            $document.on(clickEvent + elementNamespace, function(event2) {
              module.verbose("Clicked away from popup");
              module.event.hideGracefully.call(element2, event2);
            });
          }
        },
        unbind: {
          events: function() {
            $window.off(elementNamespace);
            $module.off(eventNamespace);
          },
          close: function() {
            $document.off(elementNamespace);
            $scrollContext.off(elementNamespace);
          }
        },
        can: {
          useElement: function(element3) {
            if ($.fn[element3] !== void 0) {
              return true;
            }
            module.error(error.noElement.replace("{element}", element3));
            return false;
          }
        },
        has: {
          popup: function() {
            return $popup && $popup.length > 0;
          }
        },
        should: {
          centerArrow: function(calculations) {
            return !module.is.basic() && calculations.target.width <= settings.arrowPixelsFromEdge * 2;
          }
        },
        is: {
          closable: function() {
            if (settings.closable === "auto") {
              return settings.on !== "hover";
            }
            return settings.closable;
          },
          offstage: function(distanceFromBoundary, position) {
            var offstage = [];
            $.each(distanceFromBoundary, function(direction, distance) {
              if (distance < -settings.jitter) {
                module.debug("Position exceeds allowable distance from edge", direction, distance, position);
                offstage.push(direction);
              }
            });
            return offstage.length > 0;
          },
          svg: function(element3) {
            return module.supports.svg() && element3 instanceof SVGGraphicsElement;
          },
          basic: function() {
            return $module.hasClass(className.basic);
          },
          active: function() {
            return $module.hasClass(className.active);
          },
          animating: function() {
            return $popup !== void 0 && $popup.hasClass(className.animating);
          },
          fluid: function() {
            return $popup !== void 0 && $popup.hasClass(className.fluid);
          },
          visible: function() {
            return $popup !== void 0 && $popup.hasClass(className.popupVisible);
          },
          dropdown: function() {
            return $module.hasClass(className.dropdown);
          },
          hidden: function() {
            return !module.is.visible();
          },
          rtl: function() {
            return $module.attr("dir") === "rtl" || $module.css("direction") === "rtl" || $body.attr("dir") === "rtl" || $body.css("direction") === "rtl" || $context.attr("dir") === "rtl" || $context.css("direction") === "rtl";
          }
        },
        reset: function() {
          module.remove.visible();
          if (settings.preserve) {
            if ($.fn.transition !== void 0) {
              $popup.transition("remove transition");
            }
          } else {
            module.removePopup();
          }
        },
        setting: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            settings[name] = value;
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.popup.settings = {
    name: "Popup",
    // module settings
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    namespace: "popup",
    // whether it should use dom mutation observers
    observeChanges: true,
    // callback only when element added to dom
    onCreate: function() {
    },
    // callback before element removed from dom
    onRemove: function() {
    },
    // callback before show animation
    onShow: function() {
    },
    // callback after show animation
    onVisible: function() {
    },
    // callback before hide animation
    onHide: function() {
    },
    // callback when popup cannot be positioned in visible screen
    onUnplaceable: function() {
    },
    // callback after hide animation
    onHidden: function() {
    },
    // when to show popup
    on: "hover",
    // element to use to determine if popup is out of boundary
    boundary: window2,
    // whether to add touchstart events when using hover
    addTouchEvents: true,
    // default position relative to element
    position: "top left",
    // if given position should be used regardless if popup fits
    forcePosition: false,
    // name of variation to use
    variation: "",
    // whether popup should be moved to context
    movePopup: true,
    // element which popup should be relative to
    target: false,
    // jq selector or element that should be used as popup
    popup: false,
    // popup should remain inline next to activator
    inline: false,
    // popup should be removed from page on hide
    preserve: false,
    // popup should not close when being hovered on
    hoverable: false,
    // explicitly set content
    content: false,
    // explicitly set html
    html: false,
    // explicitly set title
    title: false,
    // whether automatically close on clickaway when on click
    closable: true,
    // automatically hide on scroll
    hideOnScroll: "auto",
    // hide other popups on show
    exclusive: false,
    // context to attach popups
    context: "body",
    // context for binding scroll events
    scrollContext: window2,
    // position to prefer when calculating new position
    prefer: "opposite",
    // specify position to appear even if it doesn't fit
    lastResort: false,
    // number of pixels from edge of popup to pointing arrow center (used from centering)
    arrowPixelsFromEdge: 20,
    // delay used to prevent accidental refiring of animations due to user error
    delay: {
      show: 50,
      hide: 70
    },
    // whether fluid variation should assign width explicitly
    setFluidWidth: true,
    // transition settings
    duration: 200,
    transition: "scale",
    // distance away from activating element in px
    distanceAway: 0,
    // number of pixels an element is allowed to be "offstage" for a position to be chosen (allows for rounding)
    jitter: 2,
    // offset on aligning axis from calculated position
    offset: 0,
    // maximum times to look for a position before failing (9 positions total)
    maxSearchDepth: 15,
    error: {
      invalidPosition: "The position you specified is not a valid position",
      cannotPlace: "Popup does not fit within the boundaries of the viewport",
      method: "The method you called is not defined.",
      noElement: "This module requires ui {element}",
      notFound: "The target or popup you specified does not exist on the page"
    },
    metadata: {
      activator: "activator",
      content: "content",
      html: "html",
      offset: "offset",
      position: "position",
      title: "title",
      variation: "variation"
    },
    className: {
      active: "active",
      basic: "basic",
      animating: "animating",
      dropdown: "dropdown",
      invisible: "invisible",
      fluid: "fluid",
      loading: "loading",
      popup: "ui popup",
      position: "top left center bottom right",
      visible: "visible",
      popupVisible: "visible"
    },
    selector: {
      popup: ".ui.popup"
    },
    templates: {
      escape: function(string) {
        var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;",
          "`": "&#x60;"
        }, escapedChar = function(chr) {
          return escape2[chr];
        };
        if (shouldEscape.test(string)) {
          string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
          return string.replace(badChars, escapedChar);
        }
        return string;
      },
      popup: function(text) {
        var html = "", escape2 = $.fn.popup.settings.templates.escape;
        if (text !== void 0) {
          if (text.title) {
            text.title = escape2(text.title);
            html += '<div class="header">' + text.title + "</div>";
          }
          if (text.content) {
            text.content = escape2(text.content);
            html += '<div class="content">' + text.content + "</div>";
          }
        }
        return html;
      }
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.progress = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.progress.settings, parameters) : $.extend({}, $.fn.progress.settings), className = settings.className, metadata = settings.metadata, namespace = settings.namespace, selector = settings.selector, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $bars = $(this).find(selector.bar), $progresses = $(this).find(selector.progress), $label = $(this).find(selector.label), element2 = this, instance68 = $module.data(moduleNamespace), animating = false, module;
      module = {
        helper: {
          sum: function(nums) {
            return Array.isArray(nums) ? nums.reduce(function(left, right) {
              return left + Number(right);
            }, 0) : 0;
          },
          /**
          * Derive precision for multiple progress with total and values.
          *
          * This helper dervices a precision that is sufficiently large to show minimum value of multiple progress.
          *
          * Example1
          * - total: 1122
          * - values: [325, 111, 74, 612]
          * - min ratio: 74/1122 = 0.0659...
          * - required precision:  100
          *
          * Example2
          * - total: 10541
          * - values: [3235, 1111, 74, 6121]
          * - min ratio: 74/10541 = 0.0070...
          * - required precision:   1000
          *
          * @param min A minimum value within multiple values
          * @param total A total amount of multiple values
          * @returns {number} A precision. Could be 1, 10, 100, ... 1e+10.
          */
          derivePrecision: function(min, total) {
            var precisionPower = 0;
            var precision = 1;
            var ratio = min / total;
            while (precisionPower < 10) {
              ratio *= precision;
              if (ratio > 1) {
                break;
              }
              precision = Math.pow(10, precisionPower++);
            }
            return precision;
          },
          forceArray: function(element3) {
            return Array.isArray(element3) ? element3 : !isNaN(element3) ? [element3] : typeof element3 === "string" ? element3.split(",") : [];
          }
        },
        initialize: function() {
          module.set.duration();
          module.debug(element2);
          module.read.metadata();
          module.read.settings();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of progress", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous progress for", $module);
          clearInterval(instance68.interval);
          module.remove.state();
          $module.removeData(moduleNamespace);
          instance68 = void 0;
        },
        reset: function() {
          module.remove.nextValue();
          module.update.progress(0);
        },
        complete: function(keepState) {
          if (module.percent === void 0 || module.percent < 100) {
            module.remove.progressPoll();
            if (keepState !== true) {
              module.set.percent(100);
            }
          }
        },
        read: {
          metadata: function() {
            var data = {
              percent: module.helper.forceArray($module.data(metadata.percent)),
              total: $module.data(metadata.total),
              value: module.helper.forceArray($module.data(metadata.value))
            };
            if (data.total !== void 0) {
              module.debug("Total value set from metadata", data.total);
              module.set.total(data.total);
            }
            if (data.value.length > 0) {
              module.debug("Current value set from metadata", data.value);
              module.set.value(data.value);
              module.set.progress(data.value);
            }
            if (data.percent.length > 0) {
              module.debug("Current percent value set from metadata", data.percent);
              module.set.percent(data.percent);
            }
          },
          settings: function() {
            if (settings.total !== false) {
              module.debug("Current total set in settings", settings.total);
              module.set.total(settings.total);
            }
            if (settings.value !== false) {
              module.debug("Current value set in settings", settings.value);
              module.set.value(settings.value);
              module.set.progress(module.value);
            }
            if (settings.percent !== false) {
              module.debug("Current percent set in settings", settings.percent);
              module.set.percent(settings.percent);
            }
          }
        },
        bind: {
          transitionEnd: function(callback) {
            $bars.one("transitionend" + eventNamespace, function(event2) {
              clearTimeout(module.failSafeTimer);
              callback.call(this, event2);
            });
            module.failSafeTimer = setTimeout(function() {
              $bars.triggerHandler("transitionend");
            }, settings.duration + settings.failSafeDelay);
            module.verbose("Adding fail safe timer", module.timer);
          }
        },
        increment: function(incrementValue) {
          var startValue, newValue;
          if (module.has.total()) {
            startValue = module.get.value();
            incrementValue = incrementValue || 1;
          } else {
            startValue = module.get.percent();
            incrementValue = incrementValue || module.get.randomValue();
          }
          newValue = startValue + incrementValue;
          module.debug("Incrementing percentage by", startValue, newValue, incrementValue);
          newValue = module.get.normalizedValue(newValue);
          module.set.progress(newValue);
        },
        decrement: function(decrementValue) {
          var total = module.get.total(), startValue, newValue;
          if (total) {
            startValue = module.get.value();
            decrementValue = decrementValue || 1;
            newValue = startValue - decrementValue;
            module.debug("Decrementing value by", decrementValue, startValue);
          } else {
            startValue = module.get.percent();
            decrementValue = decrementValue || module.get.randomValue();
            newValue = startValue - decrementValue;
            module.debug("Decrementing percentage by", decrementValue, startValue);
          }
          newValue = module.get.normalizedValue(newValue);
          module.set.progress(newValue);
        },
        has: {
          progressPoll: function() {
            return module.progressPoll;
          },
          total: function() {
            return module.get.total() !== false;
          }
        },
        get: {
          text: function(templateText, index) {
            if (!index) {
              index = 0;
            }
            var value = module.get.value(index), total = module.get.total(), percent = animating ? module.get.displayPercent(index) : module.get.percent(index), left = total !== false ? Math.max(0, total - value) : 100 - percent;
            templateText = templateText || "";
            templateText = templateText.replace("{value}", value).replace("{total}", total || 0).replace("{left}", left).replace("{percent}", percent).replace("{bar}", settings.text.bars[index] || "");
            module.verbose("Adding variables to progress bar text", templateText);
            return templateText;
          },
          normalizedValue: function(value) {
            if (value < 0) {
              module.debug("Value cannot decrement below 0");
              return 0;
            }
            if (module.has.total()) {
              if (value > module.total) {
                module.debug("Value cannot increment above total", module.total);
                return module.total;
              }
            } else if (value > 100) {
              module.debug("Value cannot increment above 100 percent");
              return 100;
            }
            return value;
          },
          updateInterval: function() {
            if (settings.updateInterval === "auto") {
              return settings.duration;
            }
            return settings.updateInterval;
          },
          randomValue: function() {
            module.debug("Generating random increment percentage");
            return Math.floor(Math.random() * settings.random.max + settings.random.min);
          },
          numericValue: function(value) {
            return typeof value === "string" ? value.replace(/[^\d.]/g, "") !== "" ? +value.replace(/[^\d.]/g, "") : false : value;
          },
          // gets current displayed percentage (if animating values this is the intermediary value)
          displayPercent: function(index) {
            var $bar = $($bars[index]), barWidth = $bar.width(), totalWidth = $module.width(), minDisplay = parseInt($bar.css("min-width"), 10), displayPercent = barWidth > minDisplay ? barWidth / totalWidth * 100 : module.percent;
            return settings.precision > 0 ? Math.round(displayPercent * (10 * settings.precision)) / (10 * settings.precision) : Math.round(displayPercent);
          },
          percent: function(index) {
            return module.percent && module.percent[index || 0] || 0;
          },
          value: function(index) {
            return module.nextValue || module.value && module.value[index || 0] || 0;
          },
          total: function() {
            return module.total !== void 0 ? module.total : false;
          }
        },
        create: {
          progressPoll: function() {
            module.progressPoll = setTimeout(function() {
              module.update.toNextValue();
              module.remove.progressPoll();
            }, module.get.updateInterval());
          }
        },
        is: {
          complete: function() {
            return module.is.success() || module.is.warning() || module.is.error();
          },
          success: function() {
            return $module.hasClass(className.success);
          },
          warning: function() {
            return $module.hasClass(className.warning);
          },
          error: function() {
            return $module.hasClass(className.error);
          },
          active: function() {
            return $module.hasClass(className.active);
          },
          visible: function() {
            return $module.is(":visible");
          }
        },
        remove: {
          progressPoll: function() {
            module.verbose("Removing progress poll timer");
            if (module.progressPoll) {
              clearTimeout(module.progressPoll);
              delete module.progressPoll;
            }
          },
          nextValue: function() {
            module.verbose("Removing progress value stored for next update");
            delete module.nextValue;
          },
          state: function() {
            module.verbose("Removing stored state");
            delete module.total;
            delete module.percent;
            delete module.value;
          },
          active: function() {
            module.verbose("Removing active state");
            $module.removeClass(className.active);
          },
          success: function() {
            module.verbose("Removing success state");
            $module.removeClass(className.success);
          },
          warning: function() {
            module.verbose("Removing warning state");
            $module.removeClass(className.warning);
          },
          error: function() {
            module.verbose("Removing error state");
            $module.removeClass(className.error);
          }
        },
        set: {
          barWidth: function(values) {
            module.debug("set bar width with ", values);
            values = module.helper.forceArray(values);
            var firstNonZeroIndex = -1;
            var lastNonZeroIndex = -1;
            var valuesSum = module.helper.sum(values);
            var barCounts = $bars.length;
            var isMultiple = barCounts > 1;
            var percents = values.map(function(value, index) {
              var allZero = index === barCounts - 1 && valuesSum === 0;
              var $bar = $($bars[index]);
              if (value === 0 && isMultiple && !allZero) {
                $bar.css("display", "none");
              } else {
                if (isMultiple && allZero) {
                  $bar.css("background", "transparent");
                }
                if (firstNonZeroIndex === -1) {
                  firstNonZeroIndex = index;
                }
                lastNonZeroIndex = index;
                $bar.css({
                  display: "block",
                  width: value + "%"
                });
              }
              return parseFloat(value);
            });
            values.forEach(function(_, index) {
              var $bar = $($bars[index]);
              $bar.css({
                borderTopLeftRadius: index === firstNonZeroIndex ? "" : "0",
                borderBottomLeftRadius: index === firstNonZeroIndex ? "" : "0",
                borderTopRightRadius: index === lastNonZeroIndex ? "" : "0",
                borderBottomRightRadius: index === lastNonZeroIndex ? "" : "0"
              });
            });
            $module.attr("data-percent", percents);
          },
          duration: function(duration) {
            duration = duration || settings.duration;
            duration = typeof duration === "number" ? duration + "ms" : duration;
            module.verbose("Setting progress bar transition duration", duration);
            $bars.css({
              "transition-duration": duration
            });
          },
          percent: function(percents) {
            percents = module.helper.forceArray(percents).map(function(percent) {
              percent = typeof percent === "string" ? +percent.replace("%", "") : percent;
              return settings.limitValues ? Math.max(0, Math.min(100, percent)) : percent;
            });
            var hasTotal = module.has.total();
            var totalPercent = module.helper.sum(percents);
            var isMultipleValues = percents.length > 1 && hasTotal;
            var sumTotal = module.helper.sum(module.helper.forceArray(module.value));
            if (isMultipleValues && sumTotal > module.total) {
              module.error(error.sumExceedsTotal, sumTotal, module.total);
            } else if (!isMultipleValues && totalPercent > 100) {
              module.error(error.tooHigh, totalPercent);
            } else if (totalPercent < 0) {
              module.error(error.tooLow, totalPercent);
            } else {
              var autoPrecision = settings.precision > 0 ? settings.precision : isMultipleValues ? module.helper.derivePrecision(Math.min.apply(null, module.value), module.total) : 0;
              var roundedPercents = percents.map(function(percent) {
                return autoPrecision > 0 ? Math.round(percent * (10 * autoPrecision)) / (10 * autoPrecision) : Math.round(percent);
              });
              module.percent = roundedPercents;
              if (hasTotal) {
                module.value = percents.map(function(percent) {
                  return autoPrecision > 0 ? Math.round(percent / 100 * module.total * (10 * autoPrecision)) / (10 * autoPrecision) : Math.round(percent / 100 * module.total * 10) / 10;
                });
              }
              module.set.barWidth(percents);
              module.set.labelInterval();
            }
            settings.onChange.call(element2, percents, module.value, module.total);
          },
          labelInterval: function() {
            var animationCallback = function() {
              module.verbose("Bar finished animating, removing continuous label updates");
              clearInterval(module.interval);
              animating = false;
              module.set.labels();
            };
            clearInterval(module.interval);
            module.bind.transitionEnd(animationCallback);
            animating = true;
            module.interval = setInterval(function() {
              var isInDOM = $.contains(document2.documentElement, element2);
              if (!isInDOM) {
                clearInterval(module.interval);
                animating = false;
              }
              module.set.labels();
            }, settings.framerate);
          },
          labels: function() {
            module.verbose("Setting both bar progress and outer label text");
            module.set.barLabel();
            module.set.state();
          },
          label: function(text) {
            if (text) {
              text = module.get.text(text);
              module.verbose("Setting label to text", text);
              $label.text(text);
            }
          },
          state: function(percent) {
            percent = percent !== void 0 ? percent : module.helper.sum(module.percent);
            if (percent === 100) {
              if (settings.autoSuccess && $bars.length === 1 && !(module.is.warning() || module.is.error() || module.is.success())) {
                module.set.success();
                module.debug("Automatically triggering success at 100%");
              } else {
                module.verbose("Reached 100% removing active state");
                module.remove.active();
                module.remove.progressPoll();
              }
            } else if (percent > 0) {
              module.verbose("Adjusting active progress bar label", percent);
              module.set.active();
            } else {
              module.remove.active();
              module.remove.warning();
              module.remove.error();
              module.remove.success();
              module.set.label(settings.text.active);
            }
          },
          barLabel: function(text) {
            $progresses.each(function(index, element3) {
              var $progress = $(element3);
              if (text !== void 0) {
                $progress.text(module.get.text(text, index));
              } else if (settings.label === "ratio" && module.has.total()) {
                module.verbose("Adding ratio to bar label");
                $progress.text(module.get.text(settings.text.ratio, index));
              } else if (settings.label === "percent") {
                module.verbose("Adding percentage to bar label");
                $progress.text(module.get.text(settings.text.percent, index));
              }
            });
          },
          active: function(text) {
            text = text || settings.text.active;
            module.debug("Setting active state");
            if (settings.showActivity && !module.is.active()) {
              $module.addClass(className.active);
            }
            module.remove.warning();
            module.remove.error();
            module.remove.success();
            text = settings.onLabelUpdate("active", text, module.value, module.total);
            if (text) {
              module.set.label(text);
            }
            module.bind.transitionEnd(function() {
              settings.onActive.call(element2, module.value, module.total);
            });
          },
          success: function(text, keepState) {
            text = text || settings.text.success || settings.text.active;
            module.debug("Setting success state");
            $module.addClass(className.success);
            module.remove.active();
            module.remove.warning();
            module.remove.error();
            module.complete(keepState);
            if (settings.text.success) {
              text = settings.onLabelUpdate("success", text, module.value, module.total);
              module.set.label(text);
            } else {
              text = settings.onLabelUpdate("active", text, module.value, module.total);
              module.set.label(text);
            }
            module.bind.transitionEnd(function() {
              settings.onSuccess.call(element2, module.total);
            });
          },
          warning: function(text, keepState) {
            text = text || settings.text.warning;
            module.debug("Setting warning state");
            $module.addClass(className.warning);
            module.remove.active();
            module.remove.success();
            module.remove.error();
            module.complete(keepState);
            text = settings.onLabelUpdate("warning", text, module.value, module.total);
            if (text) {
              module.set.label(text);
            }
            module.bind.transitionEnd(function() {
              settings.onWarning.call(element2, module.value, module.total);
            });
          },
          error: function(text, keepState) {
            text = text || settings.text.error;
            module.debug("Setting error state");
            $module.addClass(className.error);
            module.remove.active();
            module.remove.success();
            module.remove.warning();
            module.complete(keepState);
            text = settings.onLabelUpdate("error", text, module.value, module.total);
            if (text) {
              module.set.label(text);
            }
            module.bind.transitionEnd(function() {
              settings.onError.call(element2, module.value, module.total);
            });
          },
          total: function(totalValue) {
            module.total = totalValue;
          },
          value: function(value) {
            module.value = module.helper.forceArray(value);
          },
          progress: function(value) {
            if (!module.has.progressPoll()) {
              module.debug("First update in progress update interval, immediately updating", value);
              module.update.progress(value);
              module.create.progressPoll();
            } else {
              module.debug("Updated within interval, setting next update to use new value", value);
              module.set.nextValue(value);
            }
          },
          nextValue: function(value) {
            module.nextValue = value;
          }
        },
        update: {
          toNextValue: function() {
            var nextValue = module.nextValue;
            if (nextValue) {
              module.debug("Update interval complete using last updated value", nextValue);
              module.update.progress(nextValue);
              module.remove.nextValue();
            }
          },
          progress: function(values) {
            var hasTotal = module.has.total();
            if (hasTotal) {
              module.set.value(values);
            }
            var percentCompletes = module.helper.forceArray(values).map(function(value) {
              var percentComplete;
              value = module.get.numericValue(value);
              if (value === false) {
                module.error(error.nonNumeric, value);
              }
              value = module.get.normalizedValue(value);
              if (hasTotal) {
                percentComplete = module.total > 0 ? value / module.total * 100 : 100;
                module.debug("Calculating percent complete from total", percentComplete);
              } else {
                percentComplete = value;
                module.debug("Setting value to exact percentage value", percentComplete);
              }
              return percentComplete;
            });
            module.set.percent(percentCompletes);
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.progress.settings = {
    name: "Progress",
    namespace: "progress",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    random: {
      min: 2,
      max: 5
    },
    duration: 300,
    updateInterval: "auto",
    autoSuccess: true,
    showActivity: true,
    limitValues: true,
    label: "percent",
    precision: 0,
    framerate: 1e3 / 30,
    /// 30 fps
    percent: false,
    total: false,
    value: false,
    // delay in ms for fail safe animation callback
    failSafeDelay: 100,
    onLabelUpdate: function(state, text, value, total) {
      return text;
    },
    onChange: function(percent, value, total) {
    },
    onSuccess: function(total) {
    },
    onActive: function(value, total) {
    },
    onError: function(value, total) {
    },
    onWarning: function(value, total) {
    },
    error: {
      method: "The method you called is not defined.",
      nonNumeric: "Progress value is non numeric",
      tooHigh: "Value specified is above 100%",
      tooLow: "Value specified is below 0%",
      sumExceedsTotal: "Sum of multiple values exceed total"
    },
    regExp: {
      variable: /{\$*[\da-z]+}/gi
    },
    metadata: {
      percent: "percent",
      total: "total",
      value: "value"
    },
    selector: {
      bar: "> .bar",
      label: "> .label",
      progress: ".bar > .progress"
    },
    text: {
      active: false,
      error: false,
      success: false,
      warning: false,
      percent: "{percent}%",
      ratio: "{value} of {total}",
      bars: [""]
    },
    className: {
      active: "active",
      error: "error",
      success: "success",
      warning: "warning"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.slider = function(parameters) {
    var $allModules = $(this), $document = $(document2), $window = $(window2), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], SINGLE_STEP = 1, BIG_STEP = 2, NO_STEP = 0, SINGLE_BACKSTEP = -1, BIG_BACKSTEP = -2, currentRange = 0, returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.slider.settings, parameters) : $.extend({}, $.fn.slider.settings), className = settings.className, metadata = settings.metadata, namespace = settings.namespace, error = settings.error, keys = settings.keys, interpretLabel = settings.interpretLabel, isHover = false, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $currThumb, touchIdentifier, $thumb, $secondThumb, $track, $trackFill, $labels, element2 = this, instance68 = $module.data(moduleNamespace), documentEventID, value, position, secondPos, offset, precision, gapRatio = 1, previousValue, initialPosition, initialLoad, module;
      module = {
        initialize: function() {
          module.debug("Initializing slider", settings);
          initialLoad = true;
          currentRange += 1;
          documentEventID = currentRange;
          module.setup.layout();
          module.setup.labels();
          if (!module.is.disabled()) {
            module.bind.events();
          }
          module.read.metadata();
          module.read.settings();
          initialLoad = false;
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of slider", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous slider for", $module);
          clearInterval(instance68.interval);
          module.unbind.events();
          module.unbind.slidingEvents();
          $module.removeData(moduleNamespace);
          instance68 = void 0;
        },
        setup: {
          layout: function() {
            if ($module.attr("tabindex") === void 0) {
              $module.attr("tabindex", 0);
            }
            if ($module.find(".inner").length === 0) {
              $module.append("<div class='inner'><div class='track'></div><div class='track-fill'></div><div class='thumb'></div></div>");
            }
            precision = module.get.precision();
            $thumb = $module.find(".thumb:not(.second)");
            $currThumb = $thumb;
            if (module.is.range()) {
              if ($module.find(".thumb.second").length === 0) {
                $module.find(".inner").append("<div class='thumb second'></div>");
              }
              $secondThumb = $module.find(".thumb.second");
            }
            $track = $module.find(".track");
            $trackFill = $module.find(".track-fill");
            offset = $thumb.width() / 2;
          },
          labels: function() {
            if (module.is.labeled()) {
              $labels = $module.find(".labels:not(.auto)");
              if ($labels.length > 0) {
                module.setup.customLabel();
              } else {
                module.setup.autoLabel();
              }
              if (settings.showLabelTicks) {
                $module.addClass(className.ticked);
              }
            }
          },
          customLabel: function() {
            var $children = $labels.find(".label"), numChildren = $children.length, min = module.get.min(), max = module.get.max(), ratio;
            $children.each(function(index) {
              var $child = $(this), attrValue = $child.attr("data-value");
              if (attrValue) {
                attrValue = attrValue > max ? max : attrValue < min ? min : attrValue;
                ratio = (attrValue - min) / (max - min);
              } else {
                ratio = (index + 1) / (numChildren + 1);
              }
              module.update.labelPosition(ratio, $(this));
            });
          },
          autoLabel: function() {
            $labels = $module.find(".labels");
            if ($labels.length > 0) {
              $labels.empty();
            } else {
              $labels = $module.append('<ul class="auto labels"></ul>').find(".labels");
            }
            for (var i = 0, len = module.get.numLabels(); i <= len; i++) {
              var labelText = module.get.label(i), $label = labelText !== "" ? !(i % module.get.gapRatio()) ? $('<li class="label">' + labelText + "</li>") : $('<li class="halftick label"></li>') : null, ratio = i / len;
              if ($label) {
                module.update.labelPosition(ratio, $label);
                $labels.append($label);
              }
            }
          }
        },
        bind: {
          events: function() {
            module.bind.globalKeyboardEvents();
            module.bind.keyboardEvents();
            module.bind.mouseEvents();
            if (settings.autoAdjustLabels) {
              module.bind.windowEvents();
            }
          },
          keyboardEvents: function() {
            module.verbose("Binding keyboard events");
            $module.on("keydown" + eventNamespace, module.event.keydown);
          },
          globalKeyboardEvents: function() {
            $document.on("keydown" + eventNamespace + documentEventID, module.event.activateFocus);
          },
          mouseEvents: function() {
            module.verbose("Binding mouse and touch events");
            $module.find(".track, .thumb, .inner").on("mousedown" + eventNamespace, function(event2) {
              event2.stopImmediatePropagation();
              event2.preventDefault();
              module.event.down(event2);
            });
            $module.on("mousedown" + eventNamespace, module.event.down);
            $module.on("mouseenter" + eventNamespace, function(event2) {
              isHover = true;
            });
            $module.on("mouseleave" + eventNamespace, function(event2) {
              isHover = false;
            });
            $module.find(".thumb").on("touchstart" + eventNamespace, module.event.touchDown).on("touchmove" + eventNamespace, module.event.move).on("touchend" + eventNamespace, module.event.up).on("touchcancel" + eventNamespace, module.event.touchCancel);
          },
          slidingEvents: function() {
            module.verbose("Binding page wide events while handle is being draged");
            $document.on("mousemove" + eventNamespace, module.event.move);
            $document.on("mouseup" + eventNamespace, module.event.up);
          },
          windowEvents: function() {
            $window.on("resize" + eventNamespace, module.event.resize);
          }
        },
        unbind: {
          events: function() {
            $module.find(".track, .thumb, .inner").off("mousedown" + eventNamespace);
            $module.off("mousedown" + eventNamespace);
            $module.off("mouseenter" + eventNamespace);
            $module.off("mouseleave" + eventNamespace);
            $module.find(".thumb").off("touchstart" + eventNamespace).off("touchmove" + eventNamespace).off("touchend" + eventNamespace).off("touchcancel" + eventNamespace);
            $module.off("keydown" + eventNamespace);
            $module.off("focusout" + eventNamespace);
            $document.off("keydown" + eventNamespace + documentEventID, module.event.activateFocus);
            $window.off("resize" + eventNamespace);
          },
          slidingEvents: function() {
            $document.off("mousemove" + eventNamespace);
            $document.off("mouseup" + eventNamespace);
          }
        },
        event: {
          down: function(event2) {
            event2.preventDefault();
            if (module.is.range()) {
              var eventPos = module.determine.eventPos(event2), newPos = module.determine.pos(eventPos);
              if (settings.preventCrossover && module.is.range() && module.thumbVal === module.secondThumbVal) {
                initialPosition = newPos;
                $currThumb = void 0;
              } else {
                $currThumb = module.determine.closestThumb(newPos);
              }
              if (previousValue === void 0) {
                previousValue = module.get.currentThumbValue();
              }
            } else if (previousValue === void 0) {
              previousValue = module.get.value();
            }
            if (!module.is.disabled()) {
              module.bind.slidingEvents();
            }
          },
          touchDown: function(event2) {
            event2.preventDefault();
            event2.stopImmediatePropagation();
            if (touchIdentifier !== void 0) {
              return;
            }
            $currThumb = $(event2.target);
            var touchEvent = event2.touches ? event2 : event2.originalEvent;
            touchIdentifier = touchEvent.targetTouches[0].identifier;
            if (previousValue === void 0) {
              previousValue = module.get.currentThumbValue();
            }
          },
          move: function(event2) {
            if (event2.type === "mousemove") {
              event2.preventDefault();
            }
            if (module.is.disabled()) {
              return;
            }
            var value2 = module.determine.valueFromEvent(event2);
            if (event2.type === "mousemove" && $currThumb === void 0) {
              var eventPos = module.determine.eventPos(event2), newPos = module.determine.pos(eventPos);
              $currThumb = initialPosition > newPos ? $thumb : $secondThumb;
            }
            if (module.get.step() === 0 || module.is.smooth()) {
              var thumbVal = module.thumbVal, secondThumbVal = module.secondThumbVal, thumbSmoothVal = module.determine.smoothValueFromEvent(event2);
              if (!$currThumb.hasClass("second")) {
                if (settings.preventCrossover && module.is.range()) {
                  value2 = Math.min(secondThumbVal, value2);
                  thumbSmoothVal = Math.min(secondThumbVal, thumbSmoothVal);
                }
                thumbVal = value2;
              } else {
                if (settings.preventCrossover && module.is.range()) {
                  value2 = Math.max(thumbVal, value2);
                  thumbSmoothVal = Math.max(thumbVal, thumbSmoothVal);
                }
                secondThumbVal = value2;
              }
              value2 = Math.abs(thumbVal - (secondThumbVal || 0));
              module.update.position(thumbSmoothVal);
              settings.onMove.call(element2, value2, thumbVal, secondThumbVal);
            } else {
              module.update.value(value2, function(value3, thumbVal2, secondThumbVal2) {
                settings.onMove.call(element2, value3, thumbVal2, secondThumbVal2);
              });
            }
          },
          up: function(event2) {
            event2.preventDefault();
            if (module.is.disabled()) {
              return;
            }
            var value2 = module.determine.valueFromEvent(event2);
            module.set.value(value2);
            module.unbind.slidingEvents();
            touchIdentifier = void 0;
            if (previousValue !== void 0) {
              previousValue = void 0;
            }
          },
          touchCancel: function(event2) {
            event2.preventDefault();
            touchIdentifier = void 0;
            if (previousValue !== void 0) {
              module.update.value(previousValue);
              previousValue = void 0;
            }
          },
          keydown: function(event2, first) {
            if (settings.preventCrossover && module.is.range() && module.thumbVal === module.secondThumbVal) {
              $currThumb = void 0;
            }
            if (module.is.focused()) {
              $document.trigger(event2);
            }
            if (first || module.is.focused()) {
              var step = module.determine.keyMovement(event2);
              if (step !== NO_STEP) {
                event2.preventDefault();
                switch (step) {
                  case SINGLE_STEP: {
                    module.takeStep();
                    break;
                  }
                  case BIG_STEP: {
                    module.takeStep(module.get.multiplier());
                    break;
                  }
                  case SINGLE_BACKSTEP: {
                    module.backStep();
                    break;
                  }
                  case BIG_BACKSTEP: {
                    module.backStep(module.get.multiplier());
                    break;
                  }
                }
              }
            }
          },
          activateFocus: function(event2) {
            if (!module.is.focused() && module.is.hover() && module.determine.keyMovement(event2) !== NO_STEP) {
              event2.preventDefault();
              module.event.keydown(event2, true);
              $module.trigger("focus");
            }
          },
          resize: function(_event) {
            if (gapRatio !== module.get.gapRatio()) {
              module.setup.labels();
              gapRatio = module.get.gapRatio();
            }
          }
        },
        resync: function() {
          module.verbose("Resyncing thumb position based on value");
          if (module.is.range()) {
            module.update.position(module.secondThumbVal, $secondThumb);
          }
          module.update.position(module.thumbVal, $thumb);
          module.setup.labels();
        },
        takeStep: function(multiplier) {
          if (!multiplier) {
            multiplier = 1;
          }
          var step = module.get.step(), currValue = module.get.currentThumbValue();
          module.verbose("Taking a step");
          if (step > 0) {
            module.set.value(currValue + step * multiplier);
          } else if (step === 0) {
            var precision2 = module.get.precision(), newValue = currValue + multiplier / precision2;
            module.set.value(Math.round(newValue * precision2) / precision2);
          }
        },
        backStep: function(multiplier) {
          if (!multiplier) {
            multiplier = 1;
          }
          var step = module.get.step(), currValue = module.get.currentThumbValue();
          module.verbose("Going back a step");
          if (step > 0) {
            module.set.value(currValue - step * multiplier);
          } else if (step === 0) {
            var precision2 = module.get.precision(), newValue = currValue - multiplier / precision2;
            module.set.value(Math.round(newValue * precision2) / precision2);
          }
        },
        is: {
          range: function() {
            return $module.hasClass(settings.className.range);
          },
          hover: function() {
            return isHover;
          },
          focused: function() {
            return $module.is(":focus");
          },
          disabled: function() {
            return $module.hasClass(settings.className.disabled);
          },
          labeled: function() {
            return $module.hasClass(settings.className.labeled);
          },
          reversed: function() {
            return $module.hasClass(settings.className.reversed);
          },
          vertical: function() {
            return $module.hasClass(settings.className.vertical);
          },
          smooth: function() {
            return settings.smooth || $module.hasClass(settings.className.smooth);
          }
        },
        get: {
          trackOffset: function() {
            if (module.is.vertical()) {
              return $track.offset().top;
            }
            return $track.offset().left;
          },
          trackLength: function() {
            if (module.is.vertical()) {
              return $track.height();
            }
            return $track.width();
          },
          trackLeft: function() {
            if (module.is.vertical()) {
              return $track.position().top;
            }
            return $track.position().left;
          },
          trackStartPos: function() {
            return module.is.reversed() ? module.get.trackLeft() + module.get.trackLength() : module.get.trackLeft();
          },
          trackEndPos: function() {
            return module.is.reversed() ? module.get.trackLeft() : module.get.trackLeft() + module.get.trackLength();
          },
          trackStartMargin: function() {
            var margin;
            if (module.is.vertical()) {
              margin = module.is.reversed() ? $module.css("padding-bottom") : $module.css("padding-top");
            } else {
              margin = module.is.reversed() ? $module.css("padding-right") : $module.css("padding-left");
            }
            return margin || "0px";
          },
          trackEndMargin: function() {
            var margin;
            if (module.is.vertical()) {
              margin = module.is.reversed() ? $module.css("padding-top") : $module.css("padding-bottom");
            } else {
              margin = module.is.reversed() ? $module.css("padding-left") : $module.css("padding-right");
            }
            return margin || "0px";
          },
          precision: function() {
            var decimalPlaces, step = module.get.step();
            if (step !== 0) {
              var split = String(step).split(".");
              decimalPlaces = split.length === 2 ? split[1].length : 0;
            } else {
              decimalPlaces = settings.decimalPlaces;
            }
            var precision2 = Math.pow(10, decimalPlaces);
            module.debug("Precision determined", precision2);
            return precision2;
          },
          min: function() {
            return settings.min;
          },
          max: function() {
            var step = module.get.step(), min = module.get.min(), quotient = step === 0 ? 0 : Math.floor((settings.max - min) / step), remainder = step === 0 ? 0 : (settings.max - min) % step;
            return remainder === 0 ? settings.max : min + quotient * step;
          },
          step: function() {
            return settings.step;
          },
          numLabels: function() {
            var value2 = Math.round((module.get.max() - module.get.min()) / (module.get.step() === 0 ? 1 : module.get.step()));
            module.debug("Determined that there should be " + value2 + " labels");
            return value2;
          },
          labelType: function() {
            return settings.labelType;
          },
          label: function(value2) {
            if (interpretLabel) {
              return interpretLabel(value2);
            }
            switch (settings.labelType) {
              case settings.labelTypes.number: {
                return Math.round((value2 * (module.get.step() === 0 ? 1 : module.get.step()) + module.get.min()) * precision) / precision;
              }
              case settings.labelTypes.letter: {
                return alphabet[value2 % 26];
              }
              default: {
                return value2;
              }
            }
          },
          value: function() {
            return value;
          },
          currentThumbValue: function() {
            return $currThumb !== void 0 && $currThumb.hasClass("second") ? module.secondThumbVal : module.thumbVal;
          },
          thumbValue: function(which) {
            switch (which) {
              case "second": {
                if (module.is.range()) {
                  return module.secondThumbVal;
                }
                module.error(error.notrange);
                break;
              }
              default: {
                return module.thumbVal;
              }
            }
          },
          multiplier: function() {
            return settings.pageMultiplier;
          },
          thumbPosition: function(which) {
            switch (which) {
              case "second": {
                if (module.is.range()) {
                  return secondPos;
                }
                module.error(error.notrange);
                break;
              }
              default: {
                return position;
              }
            }
          },
          gapRatio: function() {
            var gapRatio2 = 1;
            if (settings.autoAdjustLabels) {
              var numLabels = module.get.numLabels(), trackLength = module.get.trackLength(), gapCounter = 1;
              if (trackLength > 0) {
                while (trackLength / numLabels * gapCounter < settings.labelDistance) {
                  if (!(numLabels % gapCounter)) {
                    gapRatio2 = gapCounter;
                  }
                  gapCounter += 1;
                }
              }
            }
            return gapRatio2;
          }
        },
        determine: {
          pos: function(pagePos) {
            return module.is.reversed() ? module.get.trackStartPos() - pagePos + module.get.trackOffset() : pagePos - module.get.trackOffset() - module.get.trackStartPos();
          },
          closestThumb: function(eventPos) {
            var thumbPos = parseFloat(module.determine.thumbPos($thumb)), thumbDelta = Math.abs(eventPos - thumbPos), secondThumbPos = parseFloat(module.determine.thumbPos($secondThumb)), secondThumbDelta = Math.abs(eventPos - secondThumbPos);
            if (thumbDelta === secondThumbDelta && module.get.thumbValue() === module.get.min()) {
              return $secondThumb;
            }
            return thumbDelta <= secondThumbDelta ? $thumb : $secondThumb;
          },
          closestThumbPos: function(eventPos) {
            var thumbPos = parseFloat(module.determine.thumbPos($thumb)), thumbDelta = Math.abs(eventPos - thumbPos), secondThumbPos = parseFloat(module.determine.thumbPos($secondThumb)), secondThumbDelta = Math.abs(eventPos - secondThumbPos);
            return thumbDelta <= secondThumbDelta ? thumbPos : secondThumbPos;
          },
          thumbPos: function($element) {
            var pos = module.is.vertical() ? module.is.reversed() ? $element.css("bottom") : $element.css("top") : module.is.reversed() ? $element.css("right") : $element.css("left");
            return pos;
          },
          positionFromValue: function(val) {
            var min = module.get.min(), max = module.get.max(), value2 = val > max ? max : val < min ? min : val, trackLength = module.get.trackLength(), ratio = (value2 - min) / (max - min), position2 = Math.round(ratio * trackLength);
            module.verbose("Determined position: " + position2 + " from value: " + value2);
            return position2;
          },
          positionFromRatio: function(ratio) {
            var trackLength = module.get.trackLength(), step = module.get.step(), position2 = Math.round(ratio * trackLength), adjustedPos = step === 0 ? position2 : Math.round(position2 / step) * step;
            return adjustedPos;
          },
          valueFromEvent: function(event2) {
            var eventPos = module.determine.eventPos(event2), newPos = module.determine.pos(eventPos), value2;
            if (eventPos < module.get.trackOffset()) {
              value2 = module.is.reversed() ? module.get.max() : module.get.min();
            } else if (eventPos > module.get.trackOffset() + module.get.trackLength()) {
              value2 = module.is.reversed() ? module.get.min() : module.get.max();
            } else {
              value2 = module.determine.value(newPos);
            }
            return value2;
          },
          smoothValueFromEvent: function(event2) {
            var min = module.get.min(), max = module.get.max(), trackLength = module.get.trackLength(), eventPos = module.determine.eventPos(event2), newPos = eventPos - module.get.trackOffset(), ratio, value2;
            newPos = newPos < 0 ? 0 : newPos > trackLength ? trackLength : newPos;
            ratio = newPos / trackLength;
            if (module.is.reversed()) {
              ratio = 1 - ratio;
            }
            value2 = ratio * (max - min) + min;
            return value2;
          },
          eventPos: function(event2) {
            if (event2.type === "touchmove" || event2.type === "touchend") {
              var touchEvent = event2.touches ? event2 : event2.originalEvent, touch = touchEvent.changedTouches[0];
              for (var i = 0; i < touchEvent.touches.length; i++) {
                if (touchEvent.touches[i].identifier === touchIdentifier) {
                  touch = touchEvent.touches[i];
                  break;
                }
              }
              var touchY = touch.pageY, touchX = touch.pageX;
              return module.is.vertical() ? touchY : touchX;
            }
            var clickY = event2.pageY || event2.originalEvent.pageY, clickX = event2.pageX || event2.originalEvent.pageX;
            return module.is.vertical() ? clickY : clickX;
          },
          value: function(position2) {
            var startPos = module.is.reversed() ? module.get.trackEndPos() : module.get.trackStartPos(), endPos = module.is.reversed() ? module.get.trackStartPos() : module.get.trackEndPos(), ratio = (position2 - startPos) / (endPos - startPos), range = module.get.max() - module.get.min(), step = module.get.step(), value2 = ratio * range, difference = step === 0 ? value2 : Math.round(value2 / step) * step;
            module.verbose("Determined value based upon position: " + position2 + " as: " + value2);
            if (value2 !== difference) {
              module.verbose("Rounding value to closest step: " + difference);
            }
            module.verbose("Cutting off additional decimal places");
            return Math.round((difference + module.get.min()) * precision) / precision;
          },
          keyMovement: function(event2) {
            var key = event2.which, downArrow = module.is.vertical() ? module.is.reversed() ? keys.downArrow : keys.upArrow : keys.downArrow, upArrow = module.is.vertical() ? module.is.reversed() ? keys.upArrow : keys.downArrow : keys.upArrow, leftArrow = !module.is.vertical() ? module.is.reversed() ? keys.rightArrow : keys.leftArrow : keys.leftArrow, rightArrow = !module.is.vertical() ? module.is.reversed() ? keys.leftArrow : keys.rightArrow : keys.rightArrow;
            if (key === downArrow || key === leftArrow) {
              return SINGLE_BACKSTEP;
            }
            if (key === upArrow || key === rightArrow) {
              return SINGLE_STEP;
            }
            if (key === keys.pageDown) {
              return BIG_BACKSTEP;
            }
            if (key === keys.pageUp) {
              return BIG_STEP;
            }
            return NO_STEP;
          }
        },
        handleNewValuePosition: function(val) {
          var min = module.get.min(), max = module.get.max(), newPos;
          if (val <= min) {
            val = min;
          } else if (val >= max) {
            val = max;
          }
          newPos = module.determine.positionFromValue(val);
          return newPos;
        },
        set: {
          value: function(newValue, fireChange) {
            fireChange = fireChange !== false;
            var toReset = previousValue === void 0;
            previousValue = previousValue === void 0 ? module.get.value() : previousValue;
            module.update.value(newValue, function(value2, thumbVal, secondThumbVal) {
              if ((!initialLoad || settings.fireOnInit) && fireChange) {
                if (newValue !== previousValue) {
                  settings.onChange.call(element2, value2, thumbVal, secondThumbVal);
                }
                settings.onMove.call(element2, value2, thumbVal, secondThumbVal);
              }
              if (toReset) {
                previousValue = void 0;
              }
            });
          },
          rangeValue: function(first, second, fireChange) {
            fireChange = fireChange !== false;
            if (module.is.range()) {
              var min = module.get.min(), max = module.get.max(), toReset = previousValue === void 0;
              previousValue = previousValue === void 0 ? module.get.value() : previousValue;
              if (first <= min) {
                first = min;
              } else if (first >= max) {
                first = max;
              }
              if (second <= min) {
                second = min;
              } else if (second >= max) {
                second = max;
              }
              module.thumbVal = first;
              module.secondThumbVal = second;
              value = Math.abs(module.thumbVal - module.secondThumbVal);
              module.update.position(module.thumbVal, $thumb);
              module.update.position(module.secondThumbVal, $secondThumb);
              if ((!initialLoad || settings.fireOnInit) && fireChange) {
                if (value !== previousValue) {
                  settings.onChange.call(element2, value, module.thumbVal, module.secondThumbVal);
                }
                settings.onMove.call(element2, value, module.thumbVal, module.secondThumbVal);
              }
              if (toReset) {
                previousValue = void 0;
              }
            } else {
              module.error(error.notrange);
            }
          },
          position: function(position2, which) {
            var thumbVal = module.determine.value(position2);
            if (which === "second") {
              module.secondThumbVal = thumbVal;
              module.update.position(thumbVal, $secondThumb);
            } else {
              module.thumbVal = thumbVal;
              module.update.position(thumbVal, $thumb);
            }
            value = Math.abs(module.thumbVal - (module.secondThumbVal || 0));
            module.set.value(value);
          }
        },
        update: {
          value: function(newValue, callback) {
            var min = module.get.min(), max = module.get.max();
            if (newValue <= min) {
              newValue = min;
            } else if (newValue >= max) {
              newValue = max;
            }
            if (!module.is.range()) {
              value = newValue;
              module.thumbVal = value;
            } else {
              if ($currThumb === void 0) {
                $currThumb = newValue <= module.get.currentThumbValue() ? $thumb : $secondThumb;
              }
              if (!$currThumb.hasClass("second")) {
                if (settings.preventCrossover && module.is.range()) {
                  newValue = Math.min(module.secondThumbVal, newValue);
                }
                module.thumbVal = newValue;
              } else {
                if (settings.preventCrossover && module.is.range()) {
                  newValue = Math.max(module.thumbVal, newValue);
                }
                module.secondThumbVal = newValue;
              }
              value = Math.abs(module.thumbVal - module.secondThumbVal);
            }
            module.update.position(newValue);
            module.debug("Setting slider value to " + value);
            if (typeof callback === "function") {
              callback(value, module.thumbVal, module.secondThumbVal);
            }
          },
          position: function(newValue, $element) {
            var newPos = module.handleNewValuePosition(newValue), $targetThumb = $element || $currThumb, thumbVal = module.thumbVal || module.get.min(), secondThumbVal = module.secondThumbVal || module.get.min();
            if (module.is.range()) {
              if (!$targetThumb.hasClass("second")) {
                position = newPos;
                thumbVal = newValue;
              } else {
                secondPos = newPos;
                secondThumbVal = newValue;
              }
            } else {
              position = newPos;
              thumbVal = newValue;
            }
            var trackPosValue, thumbPosValue, min = module.get.min(), max = module.get.max(), thumbPosPercent = 100 * ((newValue - min) / (max - min)), trackStartPosPercent = 100 * ((Math.min(thumbVal, secondThumbVal) - min) / (max - min)), trackEndPosPercent = 100 * (1 - (Math.max(thumbVal, secondThumbVal) - min) / (max - min));
            if (module.is.vertical()) {
              if (module.is.reversed()) {
                thumbPosValue = { bottom: "calc(" + thumbPosPercent + "% - " + offset + "px)", top: "auto" };
                trackPosValue = { bottom: trackStartPosPercent + "%", top: trackEndPosPercent + "%" };
              } else {
                thumbPosValue = { top: "calc(" + thumbPosPercent + "% - " + offset + "px)", bottom: "auto" };
                trackPosValue = { top: trackStartPosPercent + "%", bottom: trackEndPosPercent + "%" };
              }
            } else {
              if (module.is.reversed()) {
                thumbPosValue = { right: "calc(" + thumbPosPercent + "% - " + offset + "px)", left: "auto" };
                trackPosValue = { right: trackStartPosPercent + "%", left: trackEndPosPercent + "%" };
              } else {
                thumbPosValue = { left: "calc(" + thumbPosPercent + "% - " + offset + "px)", right: "auto" };
                trackPosValue = { left: trackStartPosPercent + "%", right: trackEndPosPercent + "%" };
              }
            }
            $targetThumb.css(thumbPosValue);
            $trackFill.css(trackPosValue);
            module.debug("Setting slider position to " + newPos);
          },
          labelPosition: function(ratio, $label) {
            var startMargin = module.get.trackStartMargin(), endMargin = module.get.trackEndMargin(), posDir = module.is.vertical() ? module.is.reversed() ? "bottom" : "top" : module.is.reversed() ? "right" : "left", startMarginMod = module.is.reversed() && !module.is.vertical() ? " - " : " + ";
            var position2 = "(100% - " + startMargin + " - " + endMargin + ") * " + ratio;
            $label.css(posDir, "calc(" + position2 + startMarginMod + startMargin + ")");
          }
        },
        goto: {
          max: function() {
            module.set.value(module.get.max());
          },
          min: function() {
            module.set.value(module.get.min());
          }
        },
        read: {
          metadata: function() {
            var data = {
              thumbVal: $module.data(metadata.thumbVal),
              secondThumbVal: $module.data(metadata.secondThumbVal)
            };
            if (data.thumbVal) {
              if (module.is.range() && data.secondThumbVal) {
                module.debug("Current value set from metadata", data.thumbVal, data.secondThumbVal);
                module.set.rangeValue(data.thumbVal, data.secondThumbVal);
              } else {
                module.debug("Current value set from metadata", data.thumbVal);
                module.set.value(data.thumbVal);
              }
            }
          },
          settings: function() {
            if (settings.start !== false) {
              if (module.is.range()) {
                module.debug("Start position set from settings", settings.start, settings.end);
                module.set.rangeValue(settings.start, settings.end);
              } else {
                module.debug("Start position set from settings", settings.start);
                module.set.value(settings.start);
              }
            }
          }
        },
        setting: function(name, value2) {
          module.debug("Changing setting", name, value2);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value2 !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value2);
            } else {
              settings[name] = value2;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value2) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value2 !== void 0) {
            module[name] = value2;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value2) {
              var camelCaseValue = depth !== maxDepth ? value2 + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value2]) && depth !== maxDepth) {
                object = object[value2];
              } else if (object[value2] !== void 0) {
                found = object[value2];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.slider.settings = {
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    name: "Slider",
    namespace: "slider",
    error: {
      method: "The method you called is not defined.",
      notrange: "This slider is not a range slider"
    },
    metadata: {
      thumbVal: "thumbVal",
      secondThumbVal: "secondThumbVal"
    },
    min: 0,
    max: 20,
    step: 1,
    start: 0,
    end: 20,
    labelType: "number",
    showLabelTicks: false,
    smooth: false,
    autoAdjustLabels: true,
    labelDistance: 100,
    preventCrossover: true,
    fireOnInit: false,
    interpretLabel: false,
    // the decimal place to round to if step is undefined
    decimalPlaces: 2,
    // page up/down multiplier. How many more times the steps to take on page up/down press
    pageMultiplier: 2,
    selector: {},
    className: {
      reversed: "reversed",
      disabled: "disabled",
      labeled: "labeled",
      ticked: "ticked",
      vertical: "vertical",
      range: "range",
      smooth: "smooth"
    },
    keys: {
      pageUp: 33,
      pageDown: 34,
      leftArrow: 37,
      upArrow: 38,
      rightArrow: 39,
      downArrow: 40
    },
    labelTypes: {
      number: "number",
      letter: "letter"
    },
    onChange: function(value, thumbVal, secondThumbVal) {
    },
    onMove: function(value, thumbVal, secondThumbVal) {
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.rating = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.rating.settings, parameters) : $.extend({}, $.fn.rating.settings), namespace = settings.namespace, className = settings.className, error = settings.error, metadata = settings.metadata, selector = settings.selector, cssVars = settings.cssVars, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, element2 = this, instance68 = $(this).data(moduleNamespace), $module = $(this), $icon = $module.find(selector.icon), initialLoad, module;
      module = {
        initialize: function() {
          module.verbose("Initializing rating module", settings);
          if ($icon.length === 0) {
            module.setup.layout();
          }
          if (settings.interactive && !module.is.disabled()) {
            module.enable();
          } else {
            module.disable();
          }
          module.set.initialLoad();
          module.set.rating(module.get.initialRating());
          module.remove.initialLoad();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Instantiating module", settings);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous instance", instance68);
          module.remove.events();
          $module.removeData(moduleNamespace);
        },
        refresh: function() {
          $icon = $module.find(selector.icon);
        },
        setup: {
          layout: function() {
            var maxRating = module.get.maxRating(), icon = module.get.icon(), html = $.fn.rating.settings.templates.icon(maxRating, icon);
            module.debug("Generating icon html dynamically");
            $module.html(html);
            module.refresh();
          }
        },
        event: {
          mouseenter: function() {
            var $activeIcon = $(this);
            $activeIcon.nextAll().removeClass(className.selected);
            $module.addClass(className.selected);
            $activeIcon.addClass(className.selected).prevAll().addClass(className.selected);
          },
          mouseleave: function() {
            $module.removeClass(className.selected);
            $icon.removeClass(className.selected);
          },
          click: function() {
            var $activeIcon = $(this), currentRating = module.get.rating(), rating = $icon.index($activeIcon) + 1, canClear = settings.clearable === "auto" ? $icon.length === 1 : settings.clearable;
            if (canClear && currentRating === rating) {
              module.clearRating();
            } else {
              module.set.rating(rating);
            }
          }
        },
        clearRating: function() {
          module.debug("Clearing current rating");
          module.set.rating(0);
        },
        bind: {
          events: function() {
            module.verbose("Binding events");
            $module.on("mouseenter" + eventNamespace, selector.icon, module.event.mouseenter).on("mouseleave" + eventNamespace, selector.icon, module.event.mouseleave).on("click" + eventNamespace, selector.icon, module.event.click);
          }
        },
        remove: {
          events: function() {
            module.verbose("Removing events");
            $module.off(eventNamespace);
          },
          initialLoad: function() {
            initialLoad = false;
          }
        },
        enable: function() {
          module.debug("Setting rating to interactive mode");
          module.bind.events();
          $module.removeClass(className.disabled);
        },
        disable: function() {
          module.debug("Setting rating to read-only mode");
          module.remove.events();
          $module.addClass(className.disabled);
        },
        is: {
          initialLoad: function() {
            return initialLoad;
          },
          disabled: function() {
            return $module.hasClass(className.disabled);
          }
        },
        get: {
          icon: function() {
            var icon = $module.data(metadata.icon);
            if (icon) {
              $module.removeData(metadata.icon);
            }
            return icon || settings.icon;
          },
          initialRating: function() {
            if ($module.data(metadata.rating) !== void 0) {
              $module.removeData(metadata.rating);
              return $module.data(metadata.rating);
            }
            return settings.initialRating;
          },
          maxRating: function() {
            if ($module.data(metadata.maxRating) !== void 0) {
              $module.removeData(metadata.maxRating);
              return $module.data(metadata.maxRating);
            }
            return settings.maxRating;
          },
          rating: function() {
            var currentRating = $icon.filter("." + className.active).length;
            module.verbose("Current rating retrieved", currentRating);
            return currentRating;
          }
        },
        set: {
          rating: function(rating) {
            var ratingIndex = Math.floor(
              rating - 1 >= 0 ? rating - 1 : 0
            ), $activeIcon = $icon.eq(ratingIndex), $partialActiveIcon = rating <= 1 ? $activeIcon : $activeIcon.next(), filledPercentage = rating % 1 * 100;
            $module.removeClass(className.selected);
            $icon.removeClass(className.selected).removeClass(className.active).removeClass(className.partiallyActive);
            if (rating > 0) {
              module.verbose("Setting current rating to", rating);
              $activeIcon.prevAll().addBack().addClass(className.active);
              if ($activeIcon.next() && rating % 1 !== 0) {
                $partialActiveIcon.addClass(className.partiallyActive).addClass(className.active);
                $partialActiveIcon.css(cssVars.filledCustomPropName, filledPercentage + "%");
                if ($partialActiveIcon.css("backgroundColor") === "transparent") {
                  $partialActiveIcon.removeClass(className.partiallyActive).removeClass(className.active);
                }
              }
            }
            if (!module.is.initialLoad()) {
              settings.onRate.call(element2, rating);
            }
          },
          initialLoad: function() {
            initialLoad = true;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.rating.settings = {
    name: "Rating",
    namespace: "rating",
    icon: "star",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    initialRating: 0,
    interactive: true,
    maxRating: 4,
    clearable: "auto",
    fireOnInit: false,
    onRate: function(rating) {
    },
    error: {
      method: "The method you called is not defined"
    },
    metadata: {
      rating: "rating",
      maxRating: "maxRating",
      icon: "icon"
    },
    className: {
      active: "active",
      disabled: "disabled",
      selected: "selected",
      loading: "loading",
      partiallyActive: "partial"
    },
    cssVars: {
      filledCustomPropName: "--full"
    },
    selector: {
      icon: ".icon"
    },
    templates: {
      deQuote: function(string, encode) {
        return String(string).replace(/"/g, encode ? "&quot;" : "");
      },
      icon: function(maxRating, iconClass) {
        var icon = 1, html = "", deQuote = $.fn.rating.settings.templates.deQuote;
        while (icon <= maxRating) {
          html += '<i class="' + deQuote(iconClass) + ' icon"></i>';
          icon++;
        }
        return html;
      }
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.search = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.search.settings, parameters) : $.extend({}, $.fn.search.settings), className = settings.className, metadata = settings.metadata, regExp = settings.regExp, fields = settings.fields, selector = settings.selector, error = settings.error, namespace = settings.namespace, eventNamespace = "." + namespace, moduleNamespace = namespace + "-module", $module = $(this), $prompt = $module.find(selector.prompt), $searchButton = $module.find(selector.searchButton), $results = $module.find(selector.results), $result = $module.find(selector.result), $category = $module.find(selector.category), element2 = this, instance68 = $module.data(moduleNamespace), disabledBubbled = false, resultsDismissed = false, module;
      module = {
        initialize: function() {
          module.verbose("Initializing module");
          module.get.settings();
          module.determine.searchFields();
          module.bind.events();
          module.set.type();
          module.create.results();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying instance");
          $module.off(eventNamespace).removeData(moduleNamespace);
        },
        refresh: function() {
          module.debug("Refreshing selector cache");
          $prompt = $module.find(selector.prompt);
          $searchButton = $module.find(selector.searchButton);
          $category = $module.find(selector.category);
          $results = $module.find(selector.results);
          $result = $module.find(selector.result);
        },
        refreshResults: function() {
          $results = $module.find(selector.results);
          $result = $module.find(selector.result);
        },
        bind: {
          events: function() {
            module.verbose("Binding events to search");
            if (settings.automatic) {
              $module.on(module.get.inputEvent() + eventNamespace, selector.prompt, module.event.input);
              $prompt.attr("autocomplete", module.is.chrome() ? "fomantic-search" : "off");
            }
            $module.on("focus" + eventNamespace, selector.prompt, module.event.focus).on("blur" + eventNamespace, selector.prompt, module.event.blur).on("keydown" + eventNamespace, selector.prompt, module.handleKeyboard).on("click" + eventNamespace, selector.searchButton, module.query).on("mousedown" + eventNamespace, selector.results, module.event.result.mousedown).on("mouseup" + eventNamespace, selector.results, module.event.result.mouseup).on("click" + eventNamespace, selector.result, module.event.result.click);
          }
        },
        determine: {
          searchFields: function() {
            if (parameters && parameters.searchFields !== void 0) {
              settings.searchFields = parameters.searchFields;
            }
          }
        },
        event: {
          input: function() {
            if (settings.searchDelay) {
              clearTimeout(module.timer);
              module.timer = setTimeout(function() {
                if (module.is.focused()) {
                  module.query();
                }
              }, settings.searchDelay);
            } else {
              module.query();
            }
          },
          focus: function() {
            module.set.focus();
            if (settings.searchOnFocus && module.has.minimumCharacters()) {
              module.query(function() {
                if (module.can.show()) {
                  module.showResults();
                }
              });
            }
          },
          blur: function(event2) {
            var pageLostFocus = document2.activeElement === this, callback = function() {
              module.cancel.query();
              module.remove.focus();
              module.timer = setTimeout(module.hideResults, settings.hideDelay);
            };
            if (pageLostFocus) {
              return;
            }
            resultsDismissed = false;
            if (module.resultsClicked) {
              module.debug("Determining if user action caused search to close");
              $module.one("click.close" + eventNamespace, selector.results, function(event3) {
                if (module.is.inMessage(event3) || disabledBubbled) {
                  $prompt.trigger("focus");
                  return;
                }
                disabledBubbled = false;
                if (!module.is.animating() && !module.is.hidden()) {
                  callback();
                }
              });
            } else {
              module.debug("Input blurred without user action, closing results");
              callback();
            }
          },
          result: {
            mousedown: function() {
              module.resultsClicked = true;
            },
            mouseup: function() {
              module.resultsClicked = false;
            },
            click: function(event2) {
              module.debug("Search result selected");
              var $result2 = $(this), $title = $result2.find(selector.title).eq(0), $link = $result2.is("a[href]") ? $result2 : $result2.find("a[href]").eq(0), href = $link.attr("href") || false, target = $link.attr("target") || false, value = $title.length > 0 ? $title.text() : false, results = module.get.results(), result = $result2.data(metadata.result) || module.get.result(value, results);
              var oldValue = module.get.value();
              if (isFunction(settings.onSelect)) {
                if (settings.onSelect.call(element2, result, results) === false) {
                  module.debug("Custom onSelect callback cancelled default select action");
                  disabledBubbled = true;
                  return;
                }
              }
              module.hideResults();
              if (value && module.get.value() === oldValue) {
                module.set.value(value);
              }
              if (href) {
                event2.preventDefault();
                module.verbose("Opening search link found in result", $link);
                if (target === "_blank" || event2.ctrlKey) {
                  window2.open(href);
                } else {
                  window2.location.href = href;
                }
              }
            }
          }
        },
        ensureVisible: function($el) {
          var elTop, elBottom, resultsScrollTop, resultsHeight;
          if ($el.length === 0) {
            return;
          }
          elTop = $el.position().top;
          elBottom = elTop + $el.outerHeight(true);
          resultsScrollTop = $results.scrollTop();
          resultsHeight = $results.height();
          if (elTop < 0) {
            $results.scrollTop(resultsScrollTop + elTop);
          } else if (resultsHeight < elBottom) {
            $results.scrollTop(resultsScrollTop + (elBottom - resultsHeight));
          }
        },
        handleKeyboard: function(event2) {
          var $result2 = $module.find(selector.result), $category2 = $module.find(selector.category), $activeResult = $result2.filter("." + className.active), currentIndex = $result2.index($activeResult), resultSize = $result2.length, hasActiveResult = $activeResult.length > 0, keyCode = event2.which, keys = {
            backspace: 8,
            enter: 13,
            escape: 27,
            upArrow: 38,
            downArrow: 40
          }, newIndex;
          if (keyCode === keys.escape) {
            if (!module.is.visible()) {
              module.verbose("Escape key pressed, blurring search field");
              $prompt.trigger("blur");
            } else {
              module.hideResults();
            }
            event2.stopPropagation();
            resultsDismissed = true;
          }
          if (module.is.visible()) {
            if (keyCode === keys.enter) {
              module.verbose("Enter key pressed, selecting active result");
              if ($result2.filter("." + className.active).length > 0) {
                module.event.result.click.call($result2.filter("." + className.active), event2);
                event2.preventDefault();
                return false;
              }
            } else if (keyCode === keys.upArrow && hasActiveResult) {
              module.verbose("Up key pressed, changing active result");
              newIndex = currentIndex - 1 < 0 ? currentIndex : currentIndex - 1;
              $category2.removeClass(className.active);
              $result2.removeClass(className.active).eq(newIndex).addClass(className.active).closest($category2).addClass(className.active);
              module.ensureVisible($result2.eq(newIndex));
              event2.preventDefault();
            } else if (keyCode === keys.downArrow) {
              module.verbose("Down key pressed, changing active result");
              newIndex = currentIndex + 1 >= resultSize ? currentIndex : currentIndex + 1;
              $category2.removeClass(className.active);
              $result2.removeClass(className.active).eq(newIndex).addClass(className.active).closest($category2).addClass(className.active);
              module.ensureVisible($result2.eq(newIndex));
              event2.preventDefault();
            }
          } else {
            if (keyCode === keys.enter) {
              module.verbose("Enter key pressed, executing query");
              module.query();
              module.set.buttonPressed();
              $prompt.one("keyup", module.remove.buttonFocus);
            }
          }
        },
        setup: {
          api: function(searchTerm, callback) {
            var apiSettings = {
              debug: settings.debug,
              on: false,
              cache: settings.cache,
              action: "search",
              urlData: {
                query: searchTerm
              }
            }, apiCallbacks = {
              onSuccess: function(response, $module2, xhr) {
                module.parse.response.call(element2, response, searchTerm);
                callback();
                if (settings.apiSettings && typeof settings.apiSettings.onSuccess === "function") {
                  settings.apiSettings.onSuccess.call(this, response, $module2, xhr);
                }
              },
              onFailure: function(response, $module2, xhr) {
                module.displayMessage(error.serverError);
                callback();
                if (settings.apiSettings && typeof settings.apiSettings.onFailure === "function") {
                  settings.apiSettings.onFailure.call(this, response, $module2, xhr);
                }
              },
              onAbort: function(status, $module2, xhr) {
                if (settings.apiSettings && typeof settings.apiSettings.onAbort === "function") {
                  settings.apiSettings.onAbort.call(this, status, $module2, xhr);
                }
              },
              onError: function(errorMessage, $module2, xhr) {
                module.error();
                if (settings.apiSettings && typeof settings.apiSettings.onError === "function") {
                  settings.apiSettings.onError.call(this, errorMessage, $module2, xhr);
                }
              }
            };
            $.extend(true, apiSettings, settings.apiSettings, apiCallbacks);
            module.verbose("Setting up API request", apiSettings);
            $module.api(apiSettings);
          }
        },
        can: {
          useAPI: function() {
            return $.fn.api !== void 0;
          },
          show: function() {
            return module.is.focused() && !module.is.visible() && !module.is.empty();
          },
          transition: function() {
            return settings.transition && $.fn.transition !== void 0;
          }
        },
        is: {
          animating: function() {
            return $results.hasClass(className.animating);
          },
          chrome: function() {
            return !!window2.chrome && !window2.StyleMedia;
          },
          hidden: function() {
            return $results.hasClass(className.hidden);
          },
          inMessage: function(event2) {
            if (!event2.target) {
              return;
            }
            var $target = $(event2.target), isInDOM = $.contains(document2.documentElement, event2.target);
            return isInDOM && $target.closest(selector.message).length > 0;
          },
          empty: function() {
            return $results.html() === "";
          },
          visible: function() {
            return $results.filter(":visible").length > 0;
          },
          focused: function() {
            return $prompt.filter(":focus").length > 0;
          }
        },
        get: {
          settings: function() {
            if ($.isPlainObject(parameters) && parameters.searchFullText) {
              settings.fullTextSearch = parameters.searchFullText;
              module.error(settings.error.oldSearchSyntax, element2);
            }
            if (settings.ignoreDiacritics && !String.prototype.normalize) {
              settings.ignoreDiacritics = false;
              module.error(error.noNormalize, element2);
            }
          },
          inputEvent: function() {
            var prompt = $prompt[0], inputEvent = prompt !== void 0 && prompt.oninput !== void 0 ? "input" : prompt !== void 0 && prompt.onpropertychange !== void 0 ? "propertychange" : "keyup";
            return inputEvent;
          },
          value: function() {
            return $prompt.val();
          },
          results: function() {
            return $module.data(metadata.results);
          },
          result: function(value, results) {
            var result = false;
            value = value !== void 0 ? value : module.get.value();
            results = results !== void 0 ? results : module.get.results();
            if (settings.type === "category") {
              module.debug("Finding result that matches", value);
              $.each(results, function(index, category) {
                if (Array.isArray(category.results)) {
                  result = module.search.object(value, category.results)[0];
                  if (result) {
                    return false;
                  }
                }
              });
            } else {
              module.debug("Finding result in results object", value);
              result = module.search.object(value, results)[0];
            }
            return result || false;
          }
        },
        select: {
          firstResult: function() {
            module.verbose("Selecting first result");
            $result.first().addClass(className.active);
          }
        },
        set: {
          focus: function() {
            $module.addClass(className.focus);
          },
          loading: function() {
            $module.addClass(className.loading);
          },
          value: function(value) {
            module.verbose("Setting search input value", value);
            $prompt.val(value);
          },
          type: function(type) {
            type = type || settings.type;
            if (className[type]) {
              $module.addClass(className[type]);
            }
          },
          buttonPressed: function() {
            $searchButton.addClass(className.pressed);
          }
        },
        remove: {
          loading: function() {
            $module.removeClass(className.loading);
          },
          focus: function() {
            $module.removeClass(className.focus);
          },
          buttonPressed: function() {
            $searchButton.removeClass(className.pressed);
          },
          diacritics: function(text) {
            return settings.ignoreDiacritics ? text.normalize("NFD").replace(/[\u0300-\u036F]/g, "") : text;
          }
        },
        query: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          var searchTerm = module.get.value(), cache = module.read.cache(searchTerm);
          callback = callback || function() {
          };
          if (module.has.minimumCharacters()) {
            if (cache) {
              module.debug("Reading result from cache", searchTerm);
              module.save.results(cache.results);
              module.addResults(cache.html);
              module.inject.id(cache.results);
              callback();
            } else {
              module.debug("Querying for", searchTerm);
              if ($.isPlainObject(settings.source) || Array.isArray(settings.source)) {
                module.search.local(searchTerm);
                callback();
              } else if (module.can.useAPI()) {
                module.search.remote(searchTerm, callback);
              } else {
                module.error(error.source);
                callback();
              }
            }
            settings.onSearchQuery.call(element2, searchTerm);
          } else {
            module.hideResults();
          }
        },
        search: {
          local: function(searchTerm) {
            var results = module.search.object(searchTerm, settings.source), searchHTML;
            module.set.loading();
            module.save.results(results);
            module.debug("Returned full local search results", results);
            if (settings.maxResults > 0) {
              module.debug("Using specified max results", results);
              results = results.slice(0, settings.maxResults);
            }
            if (settings.type === "category") {
              results = module.create.categoryResults(results);
            }
            searchHTML = module.generateResults({
              results
            });
            module.remove.loading();
            module.addResults(searchHTML);
            module.inject.id(results);
            module.write.cache(searchTerm, {
              html: searchHTML,
              results
            });
          },
          remote: function(searchTerm, callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            if ($module.api("is loading")) {
              $module.api("abort");
            }
            module.setup.api(searchTerm, callback);
            $module.api("query");
          },
          object: function(searchTerm, source, searchFields) {
            searchTerm = module.remove.diacritics(String(searchTerm));
            var results = [], exactResults = [], fuzzyResults = [], searchExp = searchTerm.replace(regExp.escape, "\\$&"), matchRegExp = new RegExp(regExp.beginsWith + searchExp, "i"), addResult = function(array, result) {
              var notResult = $.inArray(result, results) === -1, notFuzzyResult = $.inArray(result, fuzzyResults) === -1, notExactResults = $.inArray(result, exactResults) === -1;
              if (notResult && notFuzzyResult && notExactResults) {
                array.push(result);
              }
            };
            source = source || settings.source;
            searchFields = searchFields !== void 0 ? searchFields : settings.searchFields;
            if (!Array.isArray(searchFields)) {
              searchFields = [searchFields];
            }
            if (source === void 0 || source === false) {
              module.error(error.source);
              return [];
            }
            var lastSearchFieldIndex = searchFields.length - 1;
            $.each(source, function(label, content) {
              var concatenatedContent = [];
              $.each(searchFields, function(index, field) {
                var fieldExists = typeof content[field] === "string" || typeof content[field] === "number";
                if (fieldExists) {
                  var text;
                  text = typeof content[field] === "string" ? module.remove.diacritics(content[field]) : content[field].toString();
                  if (settings.fullTextSearch === "all") {
                    concatenatedContent.push(text);
                    if (index < lastSearchFieldIndex) {
                      return true;
                    }
                    text = concatenatedContent.join(" ");
                  }
                  if (settings.fullTextSearch !== "all" && text.search(matchRegExp) !== -1) {
                    addResult(results, content);
                  } else if (settings.fullTextSearch === "exact" && module.exactSearch(searchTerm, text)) {
                    addResult(exactResults, content);
                  } else if (settings.fullTextSearch === "some" && module.wordSearch(searchTerm, text)) {
                    addResult(exactResults, content);
                  } else if (settings.fullTextSearch === "all" && module.wordSearch(searchTerm, text, true)) {
                    addResult(exactResults, content);
                  } else if (settings.fullTextSearch === true && module.fuzzySearch(searchTerm, text)) {
                    addResult(fuzzyResults, content);
                  }
                }
              });
            });
            $.merge(exactResults, fuzzyResults);
            $.merge(results, exactResults);
            return results;
          }
        },
        exactSearch: function(query2, term) {
          query2 = query2.toLowerCase();
          term = term.toLowerCase();
          return term.indexOf(query2) > -1;
        },
        wordSearch: function(query2, term, matchAll) {
          var allWords = query2.split(/\s+/), w, wL = allWords.length, found = false;
          for (w = 0; w < wL; w++) {
            found = module.exactSearch(allWords[w], term);
            if (!found && matchAll || found && !matchAll) {
              break;
            }
          }
          return found;
        },
        fuzzySearch: function(query2, term) {
          var termLength = term.length, queryLength = query2.length;
          if (typeof query2 !== "string") {
            return false;
          }
          query2 = query2.toLowerCase();
          term = term.toLowerCase();
          if (queryLength > termLength) {
            return false;
          }
          if (queryLength === termLength) {
            return query2 === term;
          }
          for (var characterIndex = 0, nextCharacterIndex = 0; characterIndex < queryLength; characterIndex++) {
            var continueSearch = false, queryCharacter = query2.charCodeAt(characterIndex);
            while (nextCharacterIndex < termLength) {
              if (term.charCodeAt(nextCharacterIndex++) === queryCharacter) {
                continueSearch = true;
                break;
              }
            }
            if (!continueSearch) {
              return false;
            }
          }
          return true;
        },
        parse: {
          response: function(response, searchTerm) {
            if (Array.isArray(response)) {
              var o = {};
              o[fields.results] = response;
              response = o;
            }
            var searchHTML = module.generateResults(response);
            module.verbose("Parsing server response", response);
            if (response !== void 0) {
              if (searchTerm !== void 0 && response[fields.results] !== void 0) {
                module.addResults(searchHTML);
                module.inject.id(response[fields.results]);
                module.write.cache(searchTerm, {
                  html: searchHTML,
                  results: response[fields.results]
                });
                module.save.results(response[fields.results]);
              }
            }
          }
        },
        cancel: {
          query: function() {
            if (module.can.useAPI()) {
              $module.api("abort");
            }
          }
        },
        has: {
          minimumCharacters: function() {
            var searchTerm = module.get.value(), numCharacters = searchTerm.length;
            return numCharacters >= settings.minCharacters;
          },
          results: function() {
            if ($results.length === 0) {
              return false;
            }
            var html = $results.html();
            return html !== "";
          }
        },
        clear: {
          cache: function(value) {
            var cache = $module.data(metadata.cache);
            if (!value) {
              module.debug("Clearing cache", value);
              $module.removeData(metadata.cache);
            } else if (value && cache && cache[value]) {
              module.debug("Removing value from cache", value);
              delete cache[value];
              $module.data(metadata.cache, cache);
            }
          }
        },
        read: {
          cache: function(name) {
            var cache = $module.data(metadata.cache);
            if (settings.cache) {
              module.verbose("Checking cache for generated html for query", name);
              return typeof cache === "object" && cache[name] !== void 0 ? cache[name] : false;
            }
            return false;
          }
        },
        create: {
          categoryResults: function(results) {
            var categoryResults = {};
            $.each(results, function(index, result) {
              if (!result.category) {
                return;
              }
              if (categoryResults[result.category] === void 0) {
                module.verbose("Creating new category of results", result.category);
                categoryResults[result.category] = {
                  name: result.category,
                  results: [result]
                };
              } else {
                categoryResults[result.category].results.push(result);
              }
            });
            return categoryResults;
          },
          id: function(resultIndex, categoryIndex) {
            var resultID = resultIndex + 1, letterID, id;
            if (categoryIndex !== void 0) {
              letterID = String.fromCharCode(97 + categoryIndex);
              id = letterID + resultID;
              module.verbose("Creating category result id", id);
            } else {
              id = resultID;
              module.verbose("Creating result id", id);
            }
            return id;
          },
          results: function() {
            if ($results.length === 0) {
              $results = $("<div />").addClass(className.results).appendTo($module);
            }
          }
        },
        inject: {
          result: function(result, resultIndex, categoryIndex) {
            module.verbose("Injecting result into results");
            var $selectedResult = categoryIndex !== void 0 ? $results.children().eq(categoryIndex).children(selector.results).first().children(selector.result).eq(resultIndex) : $results.children(selector.result).eq(resultIndex);
            module.verbose("Injecting results metadata", $selectedResult);
            $selectedResult.data(metadata.result, result);
          },
          id: function(results) {
            module.debug("Injecting unique ids into results");
            var categoryIndex = 0, resultIndex = 0;
            if (settings.type === "category") {
              $.each(results, function(index, category) {
                if (category.results.length > 0) {
                  resultIndex = 0;
                  $.each(category.results, function(index2, result) {
                    if (result.id === void 0) {
                      result.id = module.create.id(resultIndex, categoryIndex);
                    }
                    module.inject.result(result, resultIndex, categoryIndex);
                    resultIndex++;
                  });
                  categoryIndex++;
                }
              });
            } else {
              $.each(results, function(index, result) {
                if (result.id === void 0) {
                  result.id = module.create.id(resultIndex);
                }
                module.inject.result(result, resultIndex);
                resultIndex++;
              });
            }
            return results;
          }
        },
        save: {
          results: function(results) {
            module.verbose("Saving current search results to metadata", results);
            $module.data(metadata.results, results);
          }
        },
        write: {
          cache: function(name, value) {
            var cache = $module.data(metadata.cache) !== void 0 ? $module.data(metadata.cache) : {};
            if (settings.cache) {
              module.verbose("Writing generated html to cache", name, value);
              cache[name] = value;
              $module.data(metadata.cache, cache);
            }
          }
        },
        addResults: function(html) {
          if (isFunction(settings.onResultsAdd)) {
            if (settings.onResultsAdd.call($results, html) === false) {
              module.debug("onResultsAdd callback cancelled default action");
              return false;
            }
          }
          if (html) {
            $results.html(html);
            module.refreshResults();
            if (settings.selectFirstResult) {
              module.select.firstResult();
            }
            module.showResults();
          } else {
            module.hideResults(function() {
              $results.empty();
            });
          }
        },
        showResults: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (resultsDismissed) {
            return;
          }
          if (!module.is.visible() && module.has.results()) {
            if (module.can.transition()) {
              module.debug("Showing results with css animations");
              $results.transition({
                animation: settings.transition + " in",
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                duration: settings.duration,
                onShow: function() {
                  var $firstResult = $module.find(selector.result).eq(0);
                  module.ensureVisible($firstResult);
                },
                onComplete: function() {
                  callback();
                },
                queue: true
              });
            } else {
              module.debug("Showing results with javascript");
              $results.stop().fadeIn(settings.duration, settings.easing);
            }
            settings.onResultsOpen.call($results);
          }
        },
        hideResults: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (module.is.visible()) {
            if (module.can.transition()) {
              module.debug("Hiding results with css animations");
              $results.transition({
                animation: settings.transition + " out",
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                duration: settings.duration,
                onComplete: function() {
                  callback();
                },
                queue: true
              });
            } else {
              module.debug("Hiding results with javascript");
              $results.stop().fadeOut(settings.duration, settings.easing);
            }
            settings.onResultsClose.call($results);
          }
        },
        generateResults: function(response) {
          module.debug("Generating html from response", response);
          var template = settings.templates[settings.type], isProperObject = $.isPlainObject(response[fields.results]) && !$.isEmptyObject(response[fields.results]), isProperArray = Array.isArray(response[fields.results]) && response[fields.results].length > 0, html = "";
          if (isProperObject || isProperArray) {
            if (settings.maxResults > 0) {
              if (isProperObject) {
                if (settings.type === "standard") {
                  module.error(error.maxResults);
                }
              } else {
                response[fields.results] = response[fields.results].slice(0, settings.maxResults);
              }
            }
            if (isFunction(template)) {
              html = template(response, fields, settings.preserveHTML);
            } else {
              module.error(error.noTemplate, false);
            }
          } else if (settings.showNoResults) {
            html = module.displayMessage(error.noResults, "empty", error.noResultsHeader);
          }
          settings.onResults.call(element2, response);
          return html;
        },
        displayMessage: function(text, type, header) {
          type = type || "standard";
          module.debug("Displaying message", text, type, header);
          module.addResults(settings.templates.message(text, type, header));
          return settings.templates.message(text, type, header);
        },
        setting: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            settings[name] = value;
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.search.settings = {
    name: "Search",
    namespace: "search",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    // template to use (specified in settings.templates)
    type: "standard",
    // minimum characters required to search
    minCharacters: 1,
    // whether to select first result after searching automatically
    selectFirstResult: false,
    // API config
    apiSettings: false,
    // object to search
    source: false,
    // Whether search should query current term on focus
    searchOnFocus: true,
    // fields to search
    searchFields: [
      "id",
      "title",
      "description"
    ],
    // field to display in standard results template
    displayField: "",
    // search anywhere in value (set to 'exact' to require exact matches
    fullTextSearch: "exact",
    // match results also if they contain diacritics of the same base character (for example searching for "a" will also match "" or "" or "", etc...)
    ignoreDiacritics: false,
    // whether to add events to prompt automatically
    automatic: true,
    // delay before hiding menu after blur
    hideDelay: 0,
    // delay before searching
    searchDelay: 200,
    // maximum results returned from search
    maxResults: 7,
    // whether to store lookups in local cache
    cache: true,
    // whether no results errors should be shown
    showNoResults: true,
    // preserve possible html of resultset values
    preserveHTML: true,
    // transition settings
    transition: "scale",
    duration: 200,
    easing: "easeOutExpo",
    // callbacks
    onSelect: false,
    onResultsAdd: false,
    onSearchQuery: function(query) {
    },
    onResults: function(response) {
    },
    onResultsOpen: function() {
    },
    onResultsClose: function() {
    },
    className: {
      animating: "animating",
      active: "active",
      category: "category",
      empty: "empty",
      focus: "focus",
      hidden: "hidden",
      loading: "loading",
      results: "results",
      pressed: "down"
    },
    error: {
      source: "Cannot search. No source used, and Fomantic API module was not included",
      noResultsHeader: "No Results",
      noResults: "Your search returned no results",
      noTemplate: "A valid template name was not specified.",
      oldSearchSyntax: "searchFullText setting has been renamed fullTextSearch for consistency, please adjust your settings.",
      serverError: "There was an issue querying the server.",
      maxResults: "Results must be an array to use maxResults setting",
      method: "The method you called is not defined.",
      noNormalize: '"ignoreDiacritics" setting will be ignored. Browser does not support String().normalize(). You may consider including <https://cdn.jsdelivr.net/npm/unorm@1.4.1/lib/unorm.min.js> as a polyfill.'
    },
    metadata: {
      cache: "cache",
      results: "results",
      result: "result"
    },
    regExp: {
      escape: /[$()*+./?[\\\]^{|}-]/g,
      beginsWith: "(?:\\s|^)"
    },
    // maps api response attributes to internal representation
    fields: {
      categories: "results",
      // array of categories (category view)
      categoryName: "name",
      // name of category (category view)
      categoryResults: "results",
      // array of results (category view)
      description: "description",
      // result description
      image: "image",
      // result image
      price: "price",
      // result price
      results: "results",
      // array of results (standard)
      title: "title",
      // result title
      url: "url",
      // result url
      action: "action",
      // "view more" object name
      actionText: "text",
      // "view more" text
      actionURL: "url"
      // "view more" url
    },
    selector: {
      prompt: ".prompt",
      searchButton: ".search.button",
      results: ".results",
      message: ".results > .message",
      category: ".category",
      result: ".result",
      title: ".title, .name"
    },
    templates: {
      escape: function(string, preserveHTML) {
        if (preserveHTML) {
          return string;
        }
        var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;",
          "`": "&#x60;"
        }, escapedChar = function(chr) {
          return escape2[chr];
        };
        if (shouldEscape.test(string)) {
          string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
          return string.replace(badChars, escapedChar);
        }
        return string;
      },
      message: function(message, type, header) {
        var html = "";
        if (message !== void 0 && type !== void 0) {
          html += '<div class="message ' + type + '">';
          if (header) {
            html += '<div class="header">' + header + "</div>";
          }
          html += ' <div class="description">' + message + "</div>";
          html += "</div>";
        }
        return html;
      },
      category: function(response, fields, preserveHTML) {
        var html = "", escape2 = $.fn.search.settings.templates.escape;
        if (response[fields.categoryResults] !== void 0) {
          $.each(response[fields.categoryResults], function(index, category) {
            if (category[fields.results] !== void 0 && category.results.length > 0) {
              html += '<div class="category">';
              if (category[fields.categoryName] !== void 0) {
                html += '<div class="name">' + escape2(category[fields.categoryName], preserveHTML) + "</div>";
              }
              html += '<div class="results">';
              $.each(category.results, function(index2, result) {
                html += result[fields.url] ? '<a class="result" href="' + result[fields.url].replace(/"/g, "") + '">' : '<a class="result">';
                if (result[fields.image] !== void 0) {
                  html += '<div class="image"> <img src="' + result[fields.image].replace(/"/g, "") + '"></div>';
                }
                html += '<div class="content">';
                if (result[fields.price] !== void 0) {
                  html += '<div class="price">' + escape2(result[fields.price], preserveHTML) + "</div>";
                }
                if (result[fields.title] !== void 0) {
                  html += '<div class="title">' + escape2(result[fields.title], preserveHTML) + "</div>";
                }
                if (result[fields.description] !== void 0) {
                  html += '<div class="description">' + escape2(result[fields.description], preserveHTML) + "</div>";
                }
                html += "</div>";
                html += "</a>";
              });
              html += "</div>";
              html += "</div>";
            }
          });
          if (response[fields.action]) {
            html += fields.actionURL === false ? '<div class="action">' + escape2(response[fields.action][fields.actionText], preserveHTML) + "</div>" : '<a href="' + response[fields.action][fields.actionURL].replace(/"/g, "") + '" class="action">' + escape2(response[fields.action][fields.actionText], preserveHTML) + "</a>";
          }
          return html;
        }
        return false;
      },
      standard: function(response, fields, preserveHTML) {
        var html = "", escape2 = $.fn.search.settings.templates.escape;
        if (response[fields.results] !== void 0) {
          $.each(response[fields.results], function(index, result) {
            html += result[fields.url] ? '<a class="result" href="' + result[fields.url].replace(/"/g, "") + '">' : '<a class="result">';
            if (result[fields.image] !== void 0) {
              html += '<div class="image"> <img src="' + result[fields.image].replace(/"/g, "") + '"></div>';
            }
            html += '<div class="content">';
            if (result[fields.price] !== void 0) {
              html += '<div class="price">' + escape2(result[fields.price], preserveHTML) + "</div>";
            }
            if (result[fields.title] !== void 0) {
              html += '<div class="title">' + escape2(result[fields.title], preserveHTML) + "</div>";
            }
            if (result[fields.description] !== void 0) {
              html += '<div class="description">' + escape2(result[fields.description], preserveHTML) + "</div>";
            }
            html += "</div>";
            html += "</a>";
          });
          if (response[fields.action]) {
            html += fields.actionURL === false ? '<div class="action">' + escape2(response[fields.action][fields.actionText], preserveHTML) + "</div>" : '<a href="' + response[fields.action][fields.actionURL].replace(/"/g, "") + '" class="action">' + escape2(response[fields.action][fields.actionText], preserveHTML) + "</a>";
          }
          return html;
        }
        return false;
      }
    }
  };
  $.extend($.easing, {
    easeOutExpo: function(x) {
      return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
    }
  });
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.shape = function(parameters) {
    var $allModules = $(this), time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var moduleSelector = $allModules.selector || "", settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.shape.settings, parameters) : $.extend({}, $.fn.shape.settings), namespace = settings.namespace, selector = settings.selector, error = settings.error, className = settings.className, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $sides = $module.find(">" + selector.sides), $side = $sides.find(">" + selector.side), nextIndex = false, $activeSide, $nextSide, element2 = this, instance68 = $module.data(moduleNamespace), module;
      module = {
        initialize: function() {
          module.verbose("Initializing module for", element2);
          module.set.defaultSide();
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        destroy: function() {
          module.verbose("Destroying previous module for", element2);
          $module.removeData(moduleNamespace).off(eventNamespace);
        },
        refresh: function() {
          module.verbose("Refreshing selector cache for", element2);
          $module = $(element2);
          $sides = $(this).find(selector.sides);
          $side = $(this).find(selector.side);
        },
        repaint: function() {
          module.verbose("Forcing repaint event");
          var shape = $sides[0] || document2.createElement("div"), fakeAssignment = shape.offsetWidth;
        },
        animate: function(propertyObject, callback) {
          module.verbose("Animating box with properties", propertyObject);
          callback = callback || function(event2) {
            module.verbose("Executing animation callback");
            if (event2 !== void 0) {
              event2.stopPropagation();
            }
            module.reset();
            module.set.active();
          };
          settings.onBeforeChange.call($nextSide[0]);
          module.verbose("Starting CSS animation");
          $module.addClass(className.animating);
          $sides.css(propertyObject).one("transitionend", callback);
          module.set.duration(settings.duration);
          requestAnimationFrame(function() {
            $module.addClass(className.animating);
            $activeSide.addClass(className.hidden);
          });
        },
        queue: function(method) {
          module.debug("Queueing animation of", method);
          $sides.one("transitionend", function() {
            module.debug("Executing queued animation");
            setTimeout(function() {
              $module.shape(method);
            }, 0);
          });
        },
        reset: function() {
          module.verbose("Animating states reset");
          $module.removeClass(className.animating).attr("style", "").removeAttr("style");
          $sides.attr("style", "").removeAttr("style");
          $side.attr("style", "").removeAttr("style").removeClass(className.hidden);
          $nextSide.removeClass(className.animating).attr("style", "").removeAttr("style");
        },
        is: {
          complete: function() {
            return $side.filter("." + className.active)[0] === $nextSide[0];
          },
          animating: function() {
            return $module.hasClass(className.animating);
          },
          hidden: function() {
            return $module.closest(":hidden").length > 0;
          }
        },
        set: {
          defaultSide: function() {
            $activeSide = $side.filter("." + settings.className.active);
            $nextSide = $activeSide.next(selector.side).length > 0 ? $activeSide.next(selector.side) : $side.first();
            nextIndex = false;
            module.verbose("Active side set to", $activeSide);
            module.verbose("Next side set to", $nextSide);
          },
          duration: function(duration) {
            duration = duration || settings.duration;
            duration = typeof duration === "number" ? duration + "ms" : duration;
            module.verbose("Setting animation duration", duration);
            if (settings.duration || settings.duration === 0) {
              $sides.add($side).css({
                "transition-duration": duration
              });
            }
          },
          currentStageSize: function() {
            var $activeSide2 = $side.filter("." + settings.className.active), width = $activeSide2.outerWidth(true), height = $activeSide2.outerHeight(true);
            $module.css({
              width,
              height
            });
          },
          stageSize: function() {
            var $clone = $module.clone().addClass(className.loading), $side2 = $clone.find(">" + selector.sides + ">" + selector.side), $activeSide2 = $side2.filter("." + settings.className.active), $nextSide2 = nextIndex ? $side2.eq(nextIndex) : $activeSide2.next(selector.side).length > 0 ? $activeSide2.next(selector.side) : $side2.first(), newWidth = settings.width === "next" ? $nextSide2.outerWidth(true) : settings.width === "initial" ? $module.width() : settings.width, newHeight = settings.height === "next" ? $nextSide2.outerHeight(true) : settings.height === "initial" ? $module.height() : settings.height;
            $activeSide2.removeClass(className.active);
            $nextSide2.addClass(className.active);
            $clone.insertAfter($module);
            $clone.remove();
            if (settings.width !== "auto") {
              $module.css("width", newWidth + settings.jitter);
              module.verbose("Specifying width during animation", newWidth);
            }
            if (settings.height !== "auto") {
              $module.css("height", newHeight + settings.jitter);
              module.verbose("Specifying height during animation", newHeight);
            }
          },
          nextSide: function(selector2) {
            nextIndex = selector2;
            $nextSide = $side.filter(selector2);
            nextIndex = $side.index($nextSide);
            if ($nextSide.length === 0) {
              module.set.defaultSide();
              module.error(error.side);
            }
            module.verbose("Next side manually set to", $nextSide);
          },
          active: function() {
            module.verbose("Setting new side to active", $nextSide);
            $side.removeClass(className.active);
            $nextSide.addClass(className.active);
            settings.onChange.call($nextSide[0]);
            module.set.defaultSide();
          }
        },
        flip: {
          to: function(type, stage) {
            if (module.is.hidden()) {
              module.debug("Module not visible", $nextSide);
              return;
            }
            if (module.is.complete() && !module.is.animating() && !settings.allowRepeats) {
              module.debug("Side already visible", $nextSide);
              return;
            }
            var transform = module.get.transform[type]();
            if (!module.is.animating()) {
              module.debug("Flipping " + type, $nextSide);
              module.set.stageSize();
              module.stage[stage]();
              module.animate(transform);
            } else {
              module.queue("flip " + type);
            }
          },
          up: function() {
            module.flip.to("up", "above");
          },
          down: function() {
            module.flip.to("down", "below");
          },
          left: function() {
            module.flip.to("left", "left");
          },
          right: function() {
            module.flip.to("right", "right");
          },
          over: function() {
            module.flip.to("over", "behind");
          },
          back: function() {
            module.flip.to("back", "behind");
          }
        },
        get: {
          transform: {
            up: function() {
              var translateZ = $activeSide.outerHeight(true) / 2, translateY = $nextSide.outerHeight(true) - translateZ;
              return {
                transform: "translateY(" + translateY + "px) translateZ(-" + translateZ + "px) rotateX(-90deg)"
              };
            },
            down: function() {
              var translate = {
                z: $activeSide.outerHeight(true) / 2
              };
              return {
                transform: "translateY(-" + translate.z + "px) translateZ(-" + translate.z + "px) rotateX(90deg)"
              };
            },
            left: function() {
              var translateZ = $activeSide.outerWidth(true) / 2, translateX = $nextSide.outerWidth(true) - translateZ;
              return {
                transform: "translateX(" + translateX + "px) translateZ(-" + translateZ + "px) rotateY(90deg)"
              };
            },
            right: function() {
              var translate = {
                z: $activeSide.outerWidth(true) / 2
              };
              return {
                transform: "translateX(-" + translate.z + "px) translateZ(-" + translate.z + "px) rotateY(-90deg)"
              };
            },
            over: function() {
              var translate = {
                x: -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2)
              };
              return {
                transform: "translateX(" + translate.x + "px) rotateY(180deg)"
              };
            },
            back: function() {
              var translate = {
                x: -(($activeSide.outerWidth(true) - $nextSide.outerWidth(true)) / 2)
              };
              return {
                transform: "translateX(" + translate.x + "px) rotateY(-180deg)"
              };
            }
          },
          nextSide: function() {
            return $activeSide.next(selector.side).length > 0 ? $activeSide.next(selector.side) : $side.first();
          }
        },
        stage: {
          above: function() {
            var box = {
              origin: ($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2,
              depth: {
                active: $nextSide.outerHeight(true) / 2,
                next: $activeSide.outerHeight(true) / 2
              }
            };
            module.verbose("Setting the initial animation position as above", $nextSide, box);
            $activeSide.css({
              transform: "rotateX(0deg)"
            });
            $nextSide.addClass(className.animating).css({
              top: box.origin + "px",
              transform: "rotateX(90deg) translateZ(" + box.depth.next + "px) translateY(-" + box.depth.active + "px)"
            });
          },
          below: function() {
            var box = {
              origin: ($activeSide.outerHeight(true) - $nextSide.outerHeight(true)) / 2,
              depth: {
                active: $nextSide.outerHeight(true) / 2,
                next: $activeSide.outerHeight(true) / 2
              }
            };
            module.verbose("Setting the initial animation position as below", $nextSide, box);
            $activeSide.css({
              transform: "rotateX(0deg)"
            });
            $nextSide.addClass(className.animating).css({
              top: box.origin + "px",
              transform: "rotateX(-90deg) translateZ(" + box.depth.next + "px) translateY(" + box.depth.active + "px)"
            });
          },
          left: function() {
            var height = {
              active: $activeSide.outerWidth(true),
              next: $nextSide.outerWidth(true)
            }, box = {
              origin: (height.active - height.next) / 2,
              depth: {
                active: height.next / 2,
                next: height.active / 2
              }
            };
            module.verbose("Setting the initial animation position as left", $nextSide, box);
            $activeSide.css({
              transform: "rotateY(0deg)"
            });
            $nextSide.addClass(className.animating).css({
              left: box.origin + "px",
              transform: "rotateY(-90deg) translateZ(" + box.depth.next + "px) translateX(-" + box.depth.active + "px)"
            });
          },
          right: function() {
            var height = {
              active: $activeSide.outerWidth(true),
              next: $nextSide.outerWidth(true)
            }, box = {
              origin: (height.active - height.next) / 2,
              depth: {
                active: height.next / 2,
                next: height.active / 2
              }
            };
            module.verbose("Setting the initial animation position as right", $nextSide, box);
            $activeSide.css({
              transform: "rotateY(0deg)"
            });
            $nextSide.addClass(className.animating).css({
              left: box.origin + "px",
              transform: "rotateY(90deg) translateZ(" + box.depth.next + "px) translateX(" + box.depth.active + "px)"
            });
          },
          behind: function() {
            var height = {
              active: $activeSide.outerWidth(true),
              next: $nextSide.outerWidth(true)
            }, box = {
              origin: (height.active - height.next) / 2,
              depth: {
                active: height.next / 2,
                next: height.active / 2
              }
            };
            module.verbose("Setting the initial animation position as behind", $nextSide, box);
            $activeSide.css({
              transform: "rotateY(0deg)"
            });
            $nextSide.addClass(className.animating).css({
              left: box.origin + "px",
              transform: "rotateY(-180deg)"
            });
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        var $inputs = $module.find("input");
        if ($inputs.length > 0) {
          $inputs.trigger("blur");
          setTimeout(function() {
            module.invoke(query);
          }, 150);
        } else {
          module.invoke(query);
        }
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.shape.settings = {
    // module info
    name: "Shape",
    // hide all debug content
    silent: false,
    // debug content outputted to console
    debug: false,
    // verbose debug output
    verbose: false,
    // fudge factor in pixels when swapping from 2d to 3d (can be useful to correct rounding errors)
    jitter: 0,
    // performance data output
    performance: true,
    // event namespace
    namespace: "shape",
    // width during animation, can be set to 'auto', initial', 'next' or pixel amount
    width: "initial",
    // height during animation, can be set to 'auto', 'initial', 'next' or pixel amount
    height: "initial",
    // callback occurs on side change
    onBeforeChange: function() {
    },
    onChange: function() {
    },
    // allow animation to same side
    allowRepeats: false,
    // animation duration
    duration: false,
    // possible errors
    error: {
      side: "You tried to switch to a side that does not exist.",
      method: "The method you called is not defined"
    },
    // classnames used
    className: {
      animating: "animating",
      hidden: "hidden",
      loading: "loading",
      active: "active"
    },
    // selectors used
    selector: {
      sides: ".sides",
      side: ".side"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.sidebar = function(parameters) {
    var $allModules = $(this), $window = $(window2), $document = $(document2), $body = $("body"), $html = $("html"), $head = $("head"), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.sidebar.settings, parameters) : $.extend({}, $.fn.sidebar.settings), selector = settings.selector, className = settings.className, namespace = settings.namespace, regExp = settings.regExp, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $body, isBody = $context[0] === $body[0], $sidebars = $module.children(selector.sidebar), $fixed = $context.children(selector.fixed), $pusher = $context.children(selector.pusher), $style, element2 = this, instance68 = $module.data(moduleNamespace), elementNamespace, id, currentScroll, initialBodyMargin = "", tempBodyMargin = "", hadScrollbar = false, module;
      module = {
        initialize: function() {
          module.debug("Initializing sidebar", parameters);
          module.create.id();
          if (settings.delaySetup) {
            requestAnimationFrame(module.setup.layout);
          } else {
            module.setup.layout();
          }
          requestAnimationFrame(function() {
            module.setup.cache();
          });
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        create: {
          id: function() {
            id = (Math.random().toString(16) + "000000000").slice(2, 10);
            elementNamespace = "." + id;
            module.verbose("Creating unique id for element", id);
          }
        },
        destroy: function() {
          module.verbose("Destroying previous module for", $module);
          $module.off(eventNamespace).removeData(moduleNamespace);
          if (module.is.ios()) {
            module.remove.ios();
          }
          $context.off(elementNamespace);
          $window.off(elementNamespace);
          $document.off(elementNamespace);
        },
        event: {
          clickaway: function(event2) {
            if (settings.closable) {
              var clickedInPusher = $pusher.find(event2.target).length > 0 || $pusher.is(event2.target), clickedContext = $context.is(event2.target);
              if (clickedInPusher) {
                module.verbose("User clicked on dimmed page");
                module.hide();
              }
              if (clickedContext) {
                module.verbose("User clicked on dimmable context (scaled out page)");
                module.hide();
              }
            }
          },
          touch: function(event2) {
          },
          containScroll: function(event2) {
            if (element2.scrollTop <= 0) {
              element2.scrollTop = 1;
            }
            if (element2.scrollTop + element2.offsetHeight >= element2.scrollHeight) {
              element2.scrollTop = element2.scrollHeight - element2.offsetHeight - 1;
            }
          },
          scroll: function(event2) {
            if ($(event2.target).closest(selector.sidebar).length === 0) {
              event2.preventDefault();
            }
          }
        },
        bind: {
          clickaway: function() {
            module.verbose("Adding clickaway events to context", $context);
            $context.on("click" + elementNamespace, module.event.clickaway).on("touchend" + elementNamespace, module.event.clickaway);
          },
          scrollLock: function() {
            if (settings.scrollLock) {
              module.debug("Disabling page scroll");
              hadScrollbar = module.has.scrollbar();
              if (hadScrollbar) {
                module.save.bodyMargin();
                module.set.bodyMargin();
              }
              $context.addClass(className.locked);
            }
            module.verbose("Adding events to contain sidebar scroll");
            $document.on("touchmove" + elementNamespace, module.event.touch);
            $module.on("scroll" + eventNamespace, module.event.containScroll);
          }
        },
        unbind: {
          clickaway: function() {
            module.verbose("Removing clickaway events from context", $context);
            $context.off(elementNamespace);
          },
          scrollLock: function() {
            module.verbose("Removing scroll lock from page");
            if (hadScrollbar) {
              module.restore.bodyMargin();
            }
            $context.removeClass(className.locked);
            $document.off(elementNamespace);
            $module.off("scroll" + eventNamespace);
          }
        },
        add: {
          inlineCSS: function() {
            var width = module.cache.width || $module.outerWidth(), height = module.cache.height || $module.outerHeight(), isRTL = module.is.rtl(), direction = module.get.direction(), distance = {
              left: width,
              right: -width,
              top: height,
              bottom: -height
            }, style;
            if (isRTL) {
              module.verbose("RTL detected, flipping widths");
              distance.left = -width;
              distance.right = width;
            }
            style = "<style>";
            if (direction === "left" || direction === "right") {
              module.debug("Adding CSS rules for animation distance", width);
              style += " .ui.visible." + direction + ".sidebar ~ .fixed, .ui.visible." + direction + ".sidebar ~ .pusher {           transform: translate3d(" + distance[direction] + "px, 0, 0); }";
            } else if (direction === "top" || direction === "bottom") {
              style += " .ui.visible." + direction + ".sidebar ~ .fixed, .ui.visible." + direction + ".sidebar ~ .pusher {           transform: translate3d(0, " + distance[direction] + "px, 0); }";
            }
            if (module.is.ie()) {
              if (direction === "left" || direction === "right") {
                module.debug("Adding CSS rules for animation distance", width);
                style += " body.pushable > .ui.visible." + direction + ".sidebar ~ .pusher::after {           transform: translate3d(" + distance[direction] + "px, 0, 0); }";
              } else if (direction === "top" || direction === "bottom") {
                style += " body.pushable > .ui.visible." + direction + ".sidebar ~ .pusher::after {           transform: translate3d(0, " + distance[direction] + "px, 0); }";
              }
              style += " body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher::after, body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher::after {           transform: translate3d(0, 0, 0); }";
            }
            style += "</style>";
            $style = $(style).appendTo($head);
            module.debug("Adding sizing css to head", $style);
          }
        },
        refresh: function() {
          module.verbose("Refreshing selector cache");
          $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $body;
          module.refreshSidebars();
          $pusher = $context.children(selector.pusher);
          $fixed = $context.children(selector.fixed);
          module.clear.cache();
        },
        refreshSidebars: function() {
          module.verbose("Refreshing other sidebars");
          $sidebars = $context.children(selector.sidebar);
        },
        repaint: function() {
          module.verbose("Forcing repaint event");
          element2.style.display = "none";
          var ignored = element2.offsetHeight;
          element2.scrollTop = element2.scrollTop;
          element2.style.display = "";
        },
        setup: {
          cache: function() {
            module.cache = {
              width: $module.outerWidth(),
              height: $module.outerHeight()
            };
          },
          layout: function() {
            if ($context.children(selector.pusher).length === 0) {
              module.debug("Adding wrapper element for sidebar");
              module.error(error.pusher);
              $pusher = $('<div class="pusher" />');
              $context.children().not(selector.omitted).not($sidebars).wrapAll($pusher);
              module.refresh();
            }
            if ($module.nextAll(selector.pusher).length === 0 || $module.nextAll(selector.pusher)[0] !== $pusher[0]) {
              module.debug("Moved sidebar to correct parent element");
              module.error(error.movedSidebar, element2);
              $module.detach().prependTo($context);
              module.refresh();
            }
            module.clear.cache();
            module.set.pushable();
            module.set.direction();
          }
        },
        attachEvents: function(selector2, event2) {
          var $toggle = $(selector2);
          event2 = isFunction(module[event2]) ? module[event2] : module.toggle;
          if ($toggle.length > 0) {
            module.debug("Attaching sidebar events to element", selector2, event2);
            $toggle.on("click" + eventNamespace, event2);
          } else {
            module.error(error.notFound, selector2);
          }
        },
        can: {
          leftBodyScrollbar: function() {
            if (module.cache.leftBodyScrollbar === void 0) {
              module.cache.leftBodyScrollbar = module.is.rtl() && (module.is.iframe && !module.is.firefox() || module.is.safari() || module.is.edge() || module.is.ie());
            }
            return module.cache.leftBodyScrollbar;
          }
        },
        save: {
          bodyMargin: function() {
            initialBodyMargin = $context.css((isBody ? "margin-" : "padding-") + (module.can.leftBodyScrollbar() ? "left" : "right"));
            var bodyMarginRightPixel = parseInt(initialBodyMargin.replace(/[^\d.]/g, ""), 10), bodyScrollbarWidth = isBody ? window2.innerWidth - document2.documentElement.clientWidth : $context[0].offsetWidth - $context[0].clientWidth;
            tempBodyMargin = bodyMarginRightPixel + bodyScrollbarWidth;
          }
        },
        show: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if (module.is.hidden()) {
            if (settings.onShow.call(element2) === false) {
              module.verbose("Show callback returned false cancelling show");
              return;
            }
            if (settings.overlay) {
              module.error(error.overlay);
              settings.transition = "overlay";
            }
            module.refresh();
            if (module.othersActive()) {
              module.debug("Other sidebars currently visible");
              if (settings.exclusive) {
                if (settings.transition !== "overlay") {
                  module.hideOthers(module.show);
                  return;
                }
                module.hideOthers();
              } else {
                settings.transition = "overlay";
              }
            }
            module.set.dimmerStyles();
            module.pushPage(function() {
              callback.call(element2);
              settings.onVisible.call(element2);
            });
            settings.onChange.call(element2);
          } else {
            module.debug("Sidebar is already visible");
          }
        },
        hide: function(callback) {
          callback = isFunction(callback) ? callback : function() {
          };
          if ((module.is.visible() || module.is.animating()) && settings.onHide.call(element2) !== false) {
            module.debug("Hiding sidebar", callback);
            module.refreshSidebars();
            module.pullPage(function() {
              callback.call(element2);
              settings.onHidden.call(element2);
            });
            settings.onChange.call(element2);
          }
        },
        othersAnimating: function() {
          return $sidebars.not($module).filter("." + className.animating).length > 0;
        },
        othersVisible: function() {
          return $sidebars.not($module).filter("." + className.visible).length > 0;
        },
        othersActive: function() {
          return module.othersVisible() || module.othersAnimating();
        },
        hideOthers: function(callback) {
          var $otherSidebars = $sidebars.not($module).filter("." + className.visible), sidebarCount = $otherSidebars.length, callbackCount = 0;
          callback = callback || function() {
          };
          $otherSidebars.sidebar("hide", function() {
            callbackCount++;
            if (callbackCount === sidebarCount) {
              callback();
            }
          });
        },
        toggle: function() {
          module.verbose("Determining toggled direction");
          if (module.is.hidden()) {
            module.show();
          } else {
            module.hide();
          }
        },
        pushPage: function(callback) {
          var transition = module.get.transition(), $transition = transition === "overlay" || module.othersActive() ? $module : $pusher, animate, dim, transitionEnd;
          callback = isFunction(callback) ? callback : function() {
          };
          if (settings.returnScroll) {
            currentScroll = (isBody ? $window : $context).scrollTop();
          }
          if (settings.transition === "scale down") {
            module.scrollToTop();
          }
          module.bind.scrollLock();
          module.set.transition(transition);
          module.repaint();
          animate = function() {
            module.bind.clickaway();
            module.add.inlineCSS();
            module.set.animating();
            module.set.visible();
          };
          dim = function() {
            module.set.dimmed();
          };
          transitionEnd = function(event2) {
            if (event2.target === $transition[0]) {
              $transition.off("transitionend" + elementNamespace, transitionEnd);
              module.remove.animating();
              callback.call(element2);
            }
          };
          $transition.off("transitionend" + elementNamespace);
          $transition.on("transitionend" + elementNamespace, transitionEnd);
          requestAnimationFrame(animate);
          if (settings.dimPage && !module.othersVisible()) {
            requestAnimationFrame(dim);
          }
        },
        pullPage: function(callback) {
          var transition = module.get.transition(), $transition = transition === "overlay" || module.othersActive() ? $module : $pusher, animate, transitionEnd;
          callback = isFunction(callback) ? callback : function() {
          };
          module.verbose("Removing context push state", module.get.direction());
          module.unbind.clickaway();
          module.unbind.scrollLock();
          animate = function() {
            module.set.transition(transition);
            module.set.animating();
            if (settings.dimPage && !module.othersVisible()) {
              module.set.closing();
            }
            module.remove.visible();
          };
          transitionEnd = function(event2) {
            if (event2.target === $transition[0]) {
              $transition.off("transitionend" + elementNamespace, transitionEnd);
              module.remove.animating();
              module.remove.closing();
              module.remove.transition();
              module.remove.inlineCSS();
              if (transition === "scale down" || settings.returnScroll) {
                module.scrollBack();
              }
              if (settings.dimPage && !module.othersVisible()) {
                $pusher.removeClass(className.dimmed);
              }
              callback.call(element2);
            }
          };
          $transition.off("transitionend" + elementNamespace);
          $transition.on("transitionend" + elementNamespace, transitionEnd);
          requestAnimationFrame(animate);
        },
        scrollToTop: function() {
          module.verbose("Scrolling to top of page to avoid animation issues");
          $module.scrollTop(0);
          (isBody ? $window : $context)[0].scrollTo(0, 0);
        },
        scrollBack: function() {
          module.verbose("Scrolling back to original page position");
          (isBody ? $window : $context)[0].scrollTo(0, currentScroll);
        },
        clear: {
          cache: function() {
            module.verbose("Clearing cached dimensions");
            module.cache = {};
          }
        },
        set: {
          bodyMargin: function() {
            var position = module.can.leftBodyScrollbar() ? "left" : "right";
            $context.css((isBody ? "margin-" : "padding-") + position, tempBodyMargin + "px");
            $context.find(selector.bodyFixed.replace("right", position)).each(function() {
              var el = $(this), attribute = el.css("position") === "fixed" ? "padding-" + position : position;
              el.css(attribute, "calc(" + el.css(attribute) + " + " + tempBodyMargin + "px)");
            });
          },
          dimmerStyles: function() {
            if (settings.blurring) {
              $pusher.addClass(className.blurring);
            } else {
              $pusher.removeClass(className.blurring);
            }
          },
          // ios only (scroll on html not document). This prevent auto-resize canvas/scroll in ios
          // (This is no longer necessary in latest iOS)
          ios: function() {
            $html.addClass(className.ios);
          },
          // container
          pushed: function() {
            $context.addClass(className.pushed);
          },
          pushable: function() {
            $context.addClass(className.pushable);
          },
          // pusher
          dimmed: function() {
            $pusher.addClass(className.dimmed);
          },
          // sidebar
          active: function() {
            $module.addClass(className.active);
          },
          animating: function() {
            $module.addClass(className.animating);
          },
          closing: function() {
            $pusher.addClass(className.closing);
          },
          transition: function(transition) {
            transition = transition || module.get.transition();
            $module.addClass(transition);
          },
          direction: function(direction) {
            direction = direction || module.get.direction();
            $module.addClass(className[direction]);
          },
          visible: function() {
            $module.addClass(className.visible);
          },
          overlay: function() {
            $module.addClass(className.overlay);
          }
        },
        remove: {
          inlineCSS: function() {
            module.debug("Removing inline css styles", $style);
            if ($style && $style.length > 0) {
              $style.remove();
            }
          },
          // ios scroll on html not document
          ios: function() {
            $html.removeClass(className.ios);
          },
          // context
          pushed: function() {
            $context.removeClass(className.pushed);
          },
          pushable: function() {
            $context.removeClass(className.pushable);
          },
          // sidebar
          active: function() {
            $module.removeClass(className.active);
          },
          animating: function() {
            $module.removeClass(className.animating);
          },
          closing: function() {
            $pusher.removeClass(className.closing);
          },
          transition: function(transition) {
            transition = transition || module.get.transition();
            $module.removeClass(transition);
          },
          direction: function(direction) {
            direction = direction || module.get.direction();
            $module.removeClass(className[direction]);
          },
          visible: function() {
            $module.removeClass(className.visible);
          },
          overlay: function() {
            $module.removeClass(className.overlay);
          }
        },
        restore: {
          bodyMargin: function() {
            var position = module.can.leftBodyScrollbar() ? "left" : "right";
            $context.css((isBody ? "margin-" : "padding-") + position, initialBodyMargin);
            $context.find(selector.bodyFixed.replace("right", position)).each(function() {
              var el = $(this), attribute = el.css("position") === "fixed" ? "padding-" + position : position;
              el.css(attribute, "");
            });
          }
        },
        get: {
          direction: function() {
            if ($module.hasClass(className.top)) {
              return className.top;
            }
            if ($module.hasClass(className.right)) {
              return className.right;
            }
            if ($module.hasClass(className.bottom)) {
              return className.bottom;
            }
            return className.left;
          },
          transition: function() {
            var direction = module.get.direction(), transition;
            transition = module.is.mobile() ? settings.mobileTransition === "auto" ? settings.defaultTransition.mobile[direction] : settings.mobileTransition : settings.transition === "auto" ? settings.defaultTransition.computer[direction] : settings.transition;
            module.verbose("Determined transition", transition);
            return transition;
          }
        },
        has: {
          scrollbar: function() {
            return isBody || $context.css("overflow-y") !== "hidden";
          }
        },
        is: {
          safari: function() {
            if (module.cache.isSafari === void 0) {
              module.cache.isSafari = /constructor/i.test(window2.HTMLElement) || !!window2.ApplePaySession;
            }
            return module.cache.isSafari;
          },
          edge: function() {
            if (module.cache.isEdge === void 0) {
              module.cache.isEdge = !!window2.setImmediate && !module.is.ie();
            }
            return module.cache.isEdge;
          },
          firefox: function() {
            if (module.cache.isFirefox === void 0) {
              module.cache.isFirefox = !!window2.InstallTrigger;
            }
            return module.cache.isFirefox;
          },
          iframe: function() {
            return !(self === top);
          },
          ie: function() {
            if (module.cache.isIE === void 0) {
              var isIE11 = !window2.ActiveXObject && "ActiveXObject" in window2, isIE = "ActiveXObject" in window2;
              module.cache.isIE = isIE11 || isIE;
            }
            return module.cache.isIE;
          },
          ios: function() {
            var userAgent = navigator.userAgent, isIOS = userAgent.match(regExp.ios), isMobileChrome = userAgent.match(regExp.mobileChrome);
            if (isIOS && !isMobileChrome) {
              module.verbose("Browser was found to be iOS", userAgent);
              return true;
            }
            return false;
          },
          mobile: function() {
            var userAgent = navigator.userAgent, isMobile = userAgent.match(regExp.mobile);
            if (isMobile) {
              module.verbose("Browser was found to be mobile", userAgent);
              return true;
            }
            module.verbose("Browser is not mobile, using regular transition", userAgent);
            return false;
          },
          hidden: function() {
            return !module.is.visible();
          },
          visible: function() {
            return $module.hasClass(className.visible);
          },
          // alias
          open: function() {
            return module.is.visible();
          },
          closed: function() {
            return module.is.hidden();
          },
          vertical: function() {
            return $module.hasClass(className.top);
          },
          animating: function() {
            return $context.hasClass(className.animating);
          },
          rtl: function() {
            if (module.cache.isRTL === void 0) {
              module.cache.isRTL = $module.attr("dir") === "rtl" || $module.css("direction") === "rtl" || $body.attr("dir") === "rtl" || $body.css("direction") === "rtl" || $context.attr("dir") === "rtl" || $context.css("direction") === "rtl";
            }
            return module.cache.isRTL;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          module.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.sidebar.settings = {
    name: "Sidebar",
    namespace: "sidebar",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    transition: "auto",
    mobileTransition: "auto",
    defaultTransition: {
      computer: {
        left: "uncover",
        right: "uncover",
        top: "overlay",
        bottom: "overlay"
      },
      mobile: {
        left: "uncover",
        right: "uncover",
        top: "overlay",
        bottom: "overlay"
      }
    },
    context: "body",
    exclusive: false,
    closable: true,
    dimPage: true,
    scrollLock: false,
    returnScroll: false,
    delaySetup: false,
    onChange: function() {
    },
    onShow: function() {
    },
    onHide: function() {
    },
    onHidden: function() {
    },
    onVisible: function() {
    },
    className: {
      active: "active",
      animating: "animating",
      blurring: "blurring",
      closing: "closing",
      dimmed: "dimmed",
      ios: "ios",
      locked: "locked",
      pushable: "pushable",
      pushed: "pushed",
      right: "right",
      top: "top",
      left: "left",
      bottom: "bottom",
      visible: "visible"
    },
    selector: {
      bodyFixed: "> .ui.fixed.menu, > .ui.right.toast-container, > .ui.right.sidebar, > .ui.fixed.nag, > .ui.fixed.nag > .close",
      fixed: ".fixed",
      omitted: "script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed",
      pusher: ".pusher",
      sidebar: ".ui.sidebar"
    },
    regExp: {
      ios: /(iPad|iPhone|iPod)/g,
      mobileChrome: /(CriOS)/g,
      mobile: /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g
    },
    error: {
      method: "The method you called is not defined.",
      pusher: "Had to add pusher element. For optimal performance make sure body content is inside a pusher element",
      movedSidebar: "Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag",
      overlay: "The overlay setting is no longer supported, use animation: overlay",
      notFound: "There were no elements that matched the specified selector"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.sticky = function(parameters) {
    var $allModules = $(this), $document = $(document2), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.sticky.settings, parameters) : $.extend({}, $.fn.sticky.settings), className = settings.className, namespace = settings.namespace, error = settings.error, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $window = $(window2), $scroll = [window2, document2].indexOf(settings.scrollContext) < 0 ? $document.find(settings.scrollContext) : $(settings.scrollContext), $container, $context, instance68 = $module.data(moduleNamespace), element2 = this, documentObserver, observer, module;
      module = {
        initialize: function() {
          module.determineContainer();
          module.determineContext();
          module.verbose("Initializing sticky", settings, $container);
          module.save.positions();
          module.checkErrors();
          module.bind.events();
          if (settings.observeChanges) {
            module.observeChanges();
          }
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous instance");
          module.reset();
          if (documentObserver) {
            documentObserver.disconnect();
          }
          if (observer) {
            observer.disconnect();
          }
          $window.off("load" + eventNamespace, module.event.load).off("resize" + eventNamespace, module.event.resize);
          $scroll.off("scrollchange" + eventNamespace, module.event.scrollchange);
          $module.removeData(moduleNamespace);
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            documentObserver = new MutationObserver(module.event.documentChanged);
            observer = new MutationObserver(module.event.changed);
            documentObserver.observe(document2, {
              childList: true,
              subtree: true
            });
            observer.observe(element2, {
              childList: true,
              subtree: true
            });
            observer.observe($context[0], {
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", observer);
          }
        },
        determineContainer: function() {
          if (settings.container) {
            $container = [window2, document2].indexOf(settings.container) < 0 ? $document.find(settings.container) : $(settings.container);
          } else {
            $container = $module.offsetParent();
          }
        },
        determineContext: function() {
          if (settings.context) {
            $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $(settings.context);
          } else {
            $context = $container;
          }
          if ($context.length === 0) {
            module.error(error.invalidContext, settings.context, $module);
          }
        },
        checkErrors: function() {
          if (module.is.hidden()) {
            module.error(error.visible, $module);
          }
          if (module.cache.element.height > module.cache.context.height) {
            module.reset();
            module.error(error.elementSize, $module);
          }
        },
        bind: {
          events: function() {
            $window.on("load" + eventNamespace, module.event.load).on("resize" + eventNamespace, module.event.resize);
            $scroll.off("scroll" + eventNamespace).on("scroll" + eventNamespace, module.event.scroll).on("scrollchange" + eventNamespace, module.event.scrollchange);
          }
        },
        event: {
          changed: function(mutations) {
            clearTimeout(module.timer);
            module.timer = setTimeout(function() {
              module.verbose("DOM tree modified, updating sticky menu", mutations);
              module.refresh();
            }, 100);
          },
          documentChanged: function(mutations) {
            [].forEach.call(mutations, function(mutation) {
              if (mutation.removedNodes) {
                [].forEach.call(mutation.removedNodes, function(node) {
                  if (node === element2 || $(node).find(element2).length > 0) {
                    module.debug("Element removed from DOM, tearing down events");
                    module.destroy();
                  }
                });
              }
            });
          },
          load: function() {
            module.verbose("Page contents finished loading");
            requestAnimationFrame(module.refresh);
          },
          resize: function() {
            module.verbose("Window resized");
            requestAnimationFrame(module.refresh);
          },
          scroll: function() {
            requestAnimationFrame(function() {
              $scroll.triggerHandler("scrollchange" + eventNamespace, $scroll.scrollTop());
            });
          },
          scrollchange: function(event2, scrollPosition) {
            module.stick(scrollPosition);
            settings.onScroll.call(element2);
          }
        },
        refresh: function(hardRefresh) {
          module.reset();
          if (!settings.context) {
            module.determineContext();
          }
          if (hardRefresh) {
            module.determineContainer();
          }
          module.save.positions();
          module.stick();
          settings.onReposition.call(element2);
        },
        supports: {
          sticky: function() {
            var $element = $("<div/>");
            $element.addClass(className.supported);
            return $element.css("position").match("sticky");
          }
        },
        save: {
          lastScroll: function(scroll) {
            module.lastScroll = scroll;
          },
          elementScroll: function(scroll) {
            module.elementScroll = scroll;
          },
          positions: function() {
            var scrollContext = {
              height: $scroll.height()
            }, element3 = {
              margin: {
                top: parseInt($module.css("margin-top"), 10),
                bottom: parseInt($module.css("margin-bottom"), 10)
              },
              offset: $module.offset(),
              width: $module.outerWidth(),
              height: $module.outerHeight()
            }, context = {
              offset: $context.offset(),
              height: $context.outerHeight()
            };
            if (!module.is.standardScroll()) {
              module.debug("Non-standard scroll. Removing scroll offset from element offset");
              scrollContext.top = $scroll.scrollTop();
              scrollContext.left = $scroll.scrollLeft();
              element3.offset.top += scrollContext.top;
              context.offset.top += scrollContext.top;
              element3.offset.left += scrollContext.left;
              context.offset.left += scrollContext.left;
            }
            module.cache = {
              fits: element3.height + settings.offset <= scrollContext.height,
              sameHeight: element3.height === context.height,
              scrollContext: {
                height: scrollContext.height
              },
              element: {
                margin: element3.margin,
                top: element3.offset.top - element3.margin.top,
                left: element3.offset.left,
                width: element3.width,
                height: element3.height,
                bottom: element3.offset.top + element3.height
              },
              context: {
                top: context.offset.top,
                height: context.height,
                bottom: context.offset.top + context.height
              }
            };
            module.set.containerSize();
            module.stick();
            module.debug("Caching element positions", module.cache);
          }
        },
        get: {
          direction: function(scroll) {
            var direction = "down";
            scroll = scroll || $scroll.scrollTop();
            if (module.lastScroll && module.lastScroll > scroll) {
              direction = "up";
            }
            return direction;
          },
          scrollChange: function(scroll) {
            scroll = scroll || $scroll.scrollTop();
            return module.lastScroll ? scroll - module.lastScroll : 0;
          },
          currentElementScroll: function() {
            if (module.elementScroll) {
              return module.elementScroll;
            }
            return module.is.top() ? Math.abs(parseInt($module.css("top"), 10)) || 0 : Math.abs(parseInt($module.css("bottom"), 10)) || 0;
          },
          elementScroll: function(scroll) {
            scroll = scroll || $scroll.scrollTop();
            var element3 = module.cache.element, scrollContext = module.cache.scrollContext, delta = module.get.scrollChange(scroll), maxScroll = element3.height - scrollContext.height + settings.offset, elementScroll = module.get.currentElementScroll(), possibleScroll = elementScroll + delta;
            if (module.cache.fits || possibleScroll < 0) {
              elementScroll = 0;
            } else if (possibleScroll > maxScroll) {
              elementScroll = maxScroll;
            } else {
              elementScroll = possibleScroll;
            }
            return elementScroll;
          }
        },
        remove: {
          lastScroll: function() {
            delete module.lastScroll;
          },
          elementScroll: function() {
            delete module.elementScroll;
          },
          minimumSize: function() {
            $container.css("min-height", "");
          },
          offset: function() {
            $module.css("margin-top", "");
          }
        },
        set: {
          offset: function() {
            module.verbose("Setting offset on element", settings.offset);
            $module.css("margin-top", settings.offset);
          },
          containerSize: function() {
            var tagName = $container[0].tagName;
            if (tagName === "HTML" || tagName === "body") {
              module.determineContainer();
            } else {
              var tallestHeight = Math.max(module.cache.context.height, module.cache.element.height);
              if (tallestHeight - $container.outerHeight() > settings.jitter) {
                module.debug("Context is taller than container. Specifying exact height for container", module.cache.context.height);
                $container.css({
                  height: tallestHeight
                });
              } else {
                $container.css({
                  height: ""
                });
              }
              if (Math.abs($container.outerHeight() - module.cache.context.height) > settings.jitter) {
                module.debug("Context has padding, specifying exact height for container", module.cache.context.height);
                $container.css({
                  height: module.cache.context.height
                });
              }
            }
          },
          minimumSize: function() {
            var element3 = module.cache.element;
            $container.css("min-height", element3.height);
          },
          scroll: function(scroll) {
            module.debug("Setting scroll on element", scroll);
            if (module.elementScroll === scroll) {
              return;
            }
            if (module.is.top()) {
              $module.css("bottom", "").css("top", -scroll + "px");
            }
            if (module.is.bottom()) {
              $module.css("top", "").css("bottom", scroll + "px");
            }
          },
          size: function() {
            if (module.cache.element.height !== 0 && module.cache.element.width !== 0) {
              element2.style.setProperty("width", module.cache.element.width + "px", "important");
              element2.style.setProperty("height", module.cache.element.height + "px", "important");
            }
          }
        },
        is: {
          standardScroll: function() {
            return $scroll[0] === window2;
          },
          top: function() {
            return $module.hasClass(className.top);
          },
          bottom: function() {
            return $module.hasClass(className.bottom);
          },
          initialPosition: function() {
            return !module.is.fixed() && !module.is.bound();
          },
          hidden: function() {
            return !$module.is(":visible");
          },
          bound: function() {
            return $module.hasClass(className.bound);
          },
          fixed: function() {
            return $module.hasClass(className.fixed);
          }
        },
        stick: function(scrollPosition) {
          var cachedPosition = scrollPosition || $scroll.scrollTop(), cache = module.cache, fits = cache.fits, sameHeight = cache.sameHeight, element3 = cache.element, scrollContext = cache.scrollContext, context = cache.context, offset = module.is.bottom() && settings.pushing ? settings.bottomOffset : settings.offset, scroll = {
            top: cachedPosition + offset,
            bottom: cachedPosition + offset + scrollContext.height
          }, elementScroll = fits ? 0 : module.get.elementScroll(scroll.top), doesntFit = !fits, elementVisible = element3.height !== 0;
          if (elementVisible && !sameHeight) {
            if (module.is.initialPosition()) {
              if (scroll.top >= context.bottom) {
                module.debug("Initial element position is bottom of container");
                module.bindBottom();
              } else if (scroll.top > element3.top) {
                if (element3.height + scroll.top - elementScroll >= context.bottom && element3.height < context.height) {
                  module.debug("Initial element position is bottom of container");
                  module.bindBottom();
                } else {
                  module.debug("Initial element position is fixed");
                  module.fixTop();
                }
              }
            } else if (module.is.fixed()) {
              if (module.is.top()) {
                if (scroll.top <= element3.top) {
                  module.debug("Fixed element reached top of container");
                  module.setInitialPosition();
                } else if (element3.height + scroll.top - elementScroll >= context.bottom) {
                  module.debug("Fixed element reached bottom of container");
                  module.bindBottom();
                } else if (doesntFit) {
                  module.set.scroll(elementScroll);
                  module.save.lastScroll(scroll.top);
                  module.save.elementScroll(elementScroll);
                }
              } else if (module.is.bottom()) {
                if (scroll.bottom - element3.height <= element3.top) {
                  module.debug("Bottom fixed rail has reached top of container");
                  module.setInitialPosition();
                } else if (scroll.bottom >= context.bottom) {
                  module.debug("Bottom fixed rail has reached bottom of container");
                  module.bindBottom();
                } else if (doesntFit) {
                  module.set.scroll(elementScroll);
                  module.save.lastScroll(scroll.top);
                  module.save.elementScroll(elementScroll);
                }
              }
            } else if (module.is.bottom()) {
              if (scroll.top <= element3.top) {
                module.debug("Jumped from bottom fixed to top fixed, most likely used home/end button");
                module.setInitialPosition();
              } else {
                if (settings.pushing) {
                  if (module.is.bound() && scroll.bottom <= context.bottom) {
                    module.debug("Fixing bottom attached element to bottom of browser.");
                    module.fixBottom();
                  }
                } else {
                  if (module.is.bound() && scroll.top <= context.bottom - element3.height) {
                    module.debug("Fixing bottom attached element to top of browser.");
                    module.fixTop();
                  }
                }
              }
            }
          }
        },
        bindTop: function() {
          module.debug("Binding element to top of parent container");
          module.remove.offset();
          if (settings.setSize) {
            module.set.size();
          }
          $module.css({
            left: "",
            top: "",
            marginBottom: ""
          }).removeClass(className.fixed).removeClass(className.bottom).addClass(className.bound).addClass(className.top);
          settings.onTop.call(element2);
          settings.onUnstick.call(element2);
        },
        bindBottom: function() {
          module.debug("Binding element to bottom of parent container");
          module.remove.offset();
          if (settings.setSize) {
            module.set.size();
          }
          $module.css({
            left: "",
            top: ""
          }).removeClass(className.fixed).removeClass(className.top).addClass(className.bound).addClass(className.bottom);
          settings.onBottom.call(element2);
          settings.onUnstick.call(element2);
        },
        setInitialPosition: function() {
          module.debug("Returning to initial position");
          module.unfix();
          module.unbind();
        },
        fixTop: function() {
          module.debug("Fixing element to top of page");
          if (settings.setSize) {
            module.set.size();
          }
          module.set.minimumSize();
          module.set.offset();
          $module.css({
            left: module.cache.element.left,
            bottom: "",
            marginBottom: ""
          }).removeClass(className.bound).removeClass(className.bottom).addClass(className.fixed).addClass(className.top);
          settings.onStick.call(element2);
        },
        fixBottom: function() {
          module.debug("Sticking element to bottom of page");
          if (settings.setSize) {
            module.set.size();
          }
          module.set.minimumSize();
          module.set.offset();
          $module.css({
            left: module.cache.element.left,
            bottom: "",
            marginBottom: ""
          }).removeClass(className.bound).removeClass(className.top).addClass(className.fixed).addClass(className.bottom);
          settings.onStick.call(element2);
        },
        unbind: function() {
          if (module.is.bound()) {
            module.debug("Removing container bound position on element");
            module.remove.offset();
            $module.removeClass(className.bound).removeClass(className.top).removeClass(className.bottom);
          }
        },
        unfix: function() {
          if (module.is.fixed()) {
            module.debug("Removing fixed position on element");
            module.remove.minimumSize();
            module.remove.offset();
            $module.removeClass(className.fixed).removeClass(className.top).removeClass(className.bottom);
            settings.onUnstick.call(element2);
          }
        },
        reset: function() {
          module.debug("Resetting elements position");
          module.unbind();
          module.unfix();
          module.resetCSS();
          module.remove.offset();
          module.remove.lastScroll();
        },
        resetCSS: function() {
          $module.css({
            width: "",
            height: ""
          });
          $container.css({
            height: ""
          });
        },
        setting: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            settings[name] = value;
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 0);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.sticky.settings = {
    name: "Sticky",
    namespace: "sticky",
    silent: false,
    debug: false,
    verbose: true,
    performance: true,
    // whether to stick in the opposite direction on scroll up
    pushing: false,
    context: false,
    container: false,
    // Context to watch scroll events
    scrollContext: window2,
    // Offset to adjust scroll
    offset: 0,
    // Offset to adjust scroll when attached to bottom of screen
    bottomOffset: 0,
    // will only set container height if difference between context and container is larger than this number
    jitter: 5,
    // set width of sticky element when it is fixed to page (used to make sure 100% width is maintained if no fixed size set)
    setSize: true,
    // Whether to automatically observe changes with Mutation Observers
    observeChanges: false,
    // Called when position is recalculated
    onReposition: function() {
    },
    // Called on each scroll
    onScroll: function() {
    },
    // Called when element is stuck to viewport
    onStick: function() {
    },
    // Called when element is unstuck from viewport
    onUnstick: function() {
    },
    // Called when element reaches top of context
    onTop: function() {
    },
    // Called when element reaches bottom of context
    onBottom: function() {
    },
    error: {
      visible: "Element is hidden, you must call refresh after element becomes visible. Use silent setting to suppress this warning in production.",
      method: "The method you called is not defined.",
      invalidContext: "Context specified does not exist",
      elementSize: "Sticky element is larger than its container, cannot create sticky."
    },
    className: {
      bound: "bound",
      fixed: "fixed",
      supported: "native",
      top: "top",
      bottom: "bottom"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isWindow(obj) {
    return obj !== null && obj === obj.window;
  }
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.tab = function(parameters) {
    var $allModules = isFunction(this) ? $(window2) : $(this), $document = $(document2), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), initializedHistory = false, returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.tab.settings, parameters) : $.extend({}, $.fn.tab.settings), className = settings.className, metadata = settings.metadata, selector = settings.selector, error = settings.error, regExp = settings.regExp, eventNamespace = "." + settings.namespace, moduleNamespace = "module-" + settings.namespace, $module = $(this), $context, $tabs, cache = {}, firstLoad = true, recursionDepth = 0, element2 = this, instance68 = $module.data(moduleNamespace), activeTabPath, parameterArray, module, historyEvent;
      module = {
        initialize: function() {
          module.debug("Initializing tab menu item", $module);
          module.determineTabs();
          module.debug("Determining tabs", settings.context, $tabs);
          if (settings.auto) {
            module.set.auto();
          }
          module.bind.events();
          if (settings.history && !initializedHistory) {
            module.initializeHistory();
            initializedHistory = true;
          }
          var activeTab = module.determine.activeTab();
          if (settings.autoTabActivation && instance68 === void 0 && activeTab === null) {
            activeTab = settings.autoTabActivation === true ? module.get.initialPath() : settings.autoTabActivation;
            module.debug("No active tab detected, setting tab active", activeTab);
            module.changeTab(activeTab);
          }
          if (activeTab !== null && settings.history) {
            var autoUpdate = $.address.autoUpdate();
            $.address.autoUpdate(false);
            $.address.value(activeTab);
            $.address.autoUpdate(autoUpdate);
          }
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.debug("Destroying tabs", $module);
          $module.removeData(moduleNamespace).off(eventNamespace);
        },
        bind: {
          events: function() {
            if (!isWindow(element2)) {
              module.debug("Attaching tab activation events to element", $module);
              $module.on("click" + eventNamespace, module.event.click);
            }
          }
        },
        determineTabs: function() {
          var $reference;
          if (settings.context === "parent") {
            if ($module.closest(selector.ui).length > 0) {
              $reference = $module.closest(selector.ui);
              module.verbose("Using closest UI element as parent", $reference);
            } else {
              $reference = $module;
            }
            $context = $reference.parent();
            module.verbose("Determined parent element for creating context", $context);
          } else if (settings.context) {
            $context = [window2, document2].indexOf(settings.context) < 0 ? $document.find(settings.context) : $(settings.context);
            module.verbose("Using selector for tab context", settings.context, $context);
          } else {
            $context = $("body");
          }
          if (settings.childrenOnly) {
            $tabs = $context.children(selector.tabs);
            module.debug("Searching tab context children for tabs", $context, $tabs);
          } else {
            $tabs = $context.find(selector.tabs);
            module.debug("Searching tab context for tabs", $context, $tabs);
          }
        },
        initializeHistory: function() {
          module.debug("Initializing page state");
          if ($.address === void 0) {
            module.error(error.state);
            return false;
          }
          if (settings.historyType === "state") {
            module.debug("Using HTML5 to manage state");
            if (settings.path !== false) {
              $.address.history(true).state(settings.path);
              $(window2).trigger("popstate");
            } else {
              module.error(error.path);
              return false;
            }
          }
          $.address.bind("change", module.event.history.change);
        },
        event: {
          click: function(event2) {
            var tabPath = $(this).data(metadata.tab);
            if (tabPath !== void 0) {
              if (settings.history) {
                module.verbose("Updating page state", event2);
                $.address.value(tabPath);
              } else {
                module.verbose("Changing tab", event2);
                module.changeTab(tabPath);
              }
              event2.preventDefault();
            } else {
              module.debug("No tab specified");
            }
          },
          history: {
            change: function(event2) {
              var tabPath = event2.pathNames.join("/") || module.get.initialPath(), pageTitle = settings.templates.determineTitle(tabPath) || false;
              module.performance.display();
              module.debug("History change event", tabPath, event2);
              historyEvent = event2;
              if (tabPath !== void 0) {
                module.changeTab(tabPath);
              }
              if (pageTitle) {
                $.address.title(pageTitle);
              }
            }
          }
        },
        refresh: function() {
          if (activeTabPath) {
            module.debug("Refreshing tab", activeTabPath);
            module.changeTab(activeTabPath);
          }
        },
        cache: {
          read: function(cacheKey) {
            return cacheKey !== void 0 ? cache[cacheKey] : false;
          },
          add: function(cacheKey, content) {
            cacheKey = cacheKey || activeTabPath;
            module.debug("Adding cached content for", cacheKey);
            cache[cacheKey] = content;
          },
          remove: function(cacheKey) {
            cacheKey = cacheKey || activeTabPath;
            module.debug("Removing cached content for", cacheKey);
            delete cache[cacheKey];
          }
        },
        escape: {
          string: function(text) {
            text = String(text);
            return text.replace(regExp.escape, "\\$&");
          }
        },
        set: {
          auto: function() {
            var url = typeof settings.path === "string" ? settings.path.replace(/\/$/, "") + "/{$tab}" : "/{$tab}";
            module.verbose("Setting up automatic tab retrieval from server", url);
            if ($.isPlainObject(settings.apiSettings)) {
              settings.apiSettings.url = url;
            } else {
              settings.apiSettings = {
                url
              };
            }
          },
          loading: function(tabPath) {
            var $tab = module.get.tabElement(tabPath), isLoading = $tab.hasClass(className.loading);
            if (!isLoading) {
              module.verbose("Setting loading state for", $tab);
              $tab.addClass(className.loading).siblings($tabs).removeClass(className.active + " " + className.loading);
              if ($tab.length > 0) {
                settings.onRequest.call($tab[0], tabPath);
              }
            }
          },
          state: function(state) {
            $.address.value(state);
          }
        },
        changeTab: function(tabPath) {
          var pushStateAvailable = window2.history && window2.history.pushState, shouldIgnoreLoad = pushStateAvailable && settings.ignoreFirstLoad && firstLoad, remoteContent = settings.auto || $.isPlainObject(settings.apiSettings), pathArray = remoteContent && !shouldIgnoreLoad ? module.utilities.pathToArray(tabPath) : module.get.defaultPathArray(tabPath);
          tabPath = module.utilities.arrayToPath(pathArray);
          $.each(pathArray, function(index, tab) {
            var currentPathArray = pathArray.slice(0, index + 1), currentPath = module.utilities.arrayToPath(currentPathArray), isTab = module.is.tab(currentPath), isLastIndex = index + 1 === pathArray.length, $tab = module.get.tabElement(currentPath), $anchor, nextPathArray, nextPath, isLastTab;
            module.verbose("Looking for tab", tab);
            if (isTab) {
              module.verbose("Tab was found", tab);
              activeTabPath = currentPath;
              parameterArray = module.utilities.filterArray(pathArray, currentPathArray);
              if (isLastIndex) {
                isLastTab = true;
              } else {
                nextPathArray = pathArray.slice(0, index + 2);
                nextPath = module.utilities.arrayToPath(nextPathArray);
                isLastTab = !module.is.tab(nextPath);
                if (isLastTab) {
                  module.verbose("Tab parameters found", nextPathArray);
                }
              }
              if (settings.onBeforeChange.call(element2, currentPath) === false) {
                module.debug("onBeforeChange returned false, cancelling tab change", $tab);
                return false;
              }
              if (isLastTab && remoteContent) {
                if (!shouldIgnoreLoad) {
                  module.activate.navigation(currentPath);
                  module.fetch.content(currentPath, tabPath);
                } else {
                  module.debug("Ignoring remote content on first tab load", currentPath);
                  firstLoad = false;
                  module.cache.add(tabPath, $tab.html());
                  module.activate.all(currentPath);
                  settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                  settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                }
                return false;
              }
              module.debug("Opened local tab", currentPath);
              module.activate.all(currentPath);
              if (!module.cache.read(currentPath)) {
                module.cache.add(currentPath, true);
                module.debug("First time tab loaded calling tab init");
                settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
              }
              settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
            } else if (tabPath.search("/") === -1 && tabPath !== "") {
              tabPath = module.escape.string(tabPath);
              $anchor = $("#" + tabPath + ', a[name="' + tabPath + '"]');
              currentPath = $anchor.closest("[data-tab]").data(metadata.tab);
              $tab = module.get.tabElement(currentPath);
              if ($anchor && $anchor.length > 0 && currentPath) {
                module.debug("Anchor link used, opening parent tab", $tab, $anchor);
                if (settings.onBeforeChange.call(element2, currentPath) === false) {
                  module.debug("onBeforeChange returned false, cancelling tab change", $tab);
                  return false;
                }
                if (!$tab.hasClass(className.active)) {
                  setTimeout(function() {
                    module.scrollTo($anchor);
                  }, 0);
                }
                module.activate.all(currentPath);
                if (!module.cache.read(currentPath)) {
                  module.cache.add(currentPath, true);
                  module.debug("First time tab loaded calling tab init");
                  settings.onFirstLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                }
                settings.onLoad.call($tab[0], currentPath, parameterArray, historyEvent);
                return false;
              }
            } else {
              module.error(error.missingTab, $module, $context, currentPath);
              return false;
            }
          });
        },
        scrollTo: function($element) {
          var scrollOffset = $element && $element.length > 0 ? $element.offset().top : false;
          if (scrollOffset !== false) {
            module.debug("Forcing scroll to an in-page link in a hidden tab", scrollOffset, $element);
            $document.scrollTop(scrollOffset);
          }
        },
        update: {
          content: function(tabPath, html, evaluateScripts) {
            var $tab = module.get.tabElement(tabPath), tab = $tab[0];
            evaluateScripts = evaluateScripts !== void 0 ? evaluateScripts : settings.evaluateScripts;
            if (typeof settings.cacheType === "string" && settings.cacheType.toLowerCase() === "dom" && typeof html !== "string") {
              $tab.empty().append($(html).clone(true));
            } else {
              if (evaluateScripts) {
                module.debug("Updating HTML and evaluating inline scripts", tabPath, html);
                $tab.html(html);
              } else {
                module.debug("Updating HTML", tabPath, html);
                tab.innerHTML = html;
              }
            }
          }
        },
        fetch: {
          content: function(tabPath, fullTabPath) {
            var $tab = module.get.tabElement(tabPath), apiSettings = {
              dataType: "html",
              encodeParameters: false,
              on: "now",
              cache: settings.alwaysRefresh,
              headers: {
                "X-Remote": true
              },
              onSuccess: function(response) {
                if (settings.cacheType === "response") {
                  module.cache.add(fullTabPath, response);
                }
                module.update.content(tabPath, response);
                if (tabPath == activeTabPath) {
                  module.debug("Content loaded", tabPath);
                  module.activate.tab(tabPath);
                } else {
                  module.debug("Content loaded in background", tabPath);
                }
                settings.onFirstLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                settings.onLoad.call($tab[0], tabPath, parameterArray, historyEvent);
                if (settings.loadOnce) {
                  module.cache.add(fullTabPath, true);
                } else if (typeof settings.cacheType === "string" && settings.cacheType.toLowerCase() === "dom" && $tab.children().length > 0) {
                  setTimeout(function() {
                    var $clone = $tab.children().clone(true);
                    $clone = $clone.not("script");
                    module.cache.add(fullTabPath, $clone);
                  }, 0);
                } else {
                  module.cache.add(fullTabPath, $tab.html());
                }
              },
              urlData: {
                tab: fullTabPath
              }
            }, request = $tab.api("get request") || false, existingRequest = request && request.state() === "pending", requestSettings, cachedContent;
            fullTabPath = fullTabPath || tabPath;
            cachedContent = module.cache.read(fullTabPath);
            if (settings.cache && cachedContent) {
              module.activate.tab(tabPath);
              module.debug("Adding cached content", fullTabPath);
              if (!settings.loadOnce) {
                if (settings.evaluateScripts === "once") {
                  module.update.content(tabPath, cachedContent, false);
                } else {
                  module.update.content(tabPath, cachedContent);
                }
              }
              settings.onLoad.call($tab[0], tabPath, parameterArray, historyEvent);
            } else if (existingRequest) {
              module.set.loading(tabPath);
              module.debug("Content is already loading", fullTabPath);
            } else if ($.api !== void 0) {
              requestSettings = $.extend(true, {}, settings.apiSettings, apiSettings);
              module.debug("Retrieving remote content", fullTabPath, requestSettings);
              module.set.loading(tabPath);
              $tab.api(requestSettings);
            } else {
              module.error(error.api);
            }
          }
        },
        activate: {
          all: function(tabPath) {
            module.activate.tab(tabPath);
            module.activate.navigation(tabPath);
          },
          tab: function(tabPath) {
            var $tab = module.get.tabElement(tabPath), $deactiveTabs = settings.deactivate === "siblings" ? $tab.siblings($tabs) : $tabs.not($tab), isActive = $tab.hasClass(className.active);
            module.verbose("Showing tab content for", $tab);
            if (!isActive) {
              $tab.addClass(className.active);
              $deactiveTabs.removeClass(className.active + " " + className.loading);
              if ($tab.length > 0) {
                settings.onVisible.call($tab[0], tabPath);
              }
            }
          },
          navigation: function(tabPath) {
            var $navigation = module.get.navElement(tabPath), $deactiveNavigation = settings.deactivate === "siblings" ? $navigation.siblings($allModules) : $allModules.not($navigation), isActive = $navigation.hasClass(className.active);
            module.verbose("Activating tab navigation for", $navigation, tabPath);
            if (!isActive) {
              $navigation.addClass(className.active);
              $deactiveNavigation.removeClass(className.active + " " + className.loading);
            }
          }
        },
        deactivate: {
          all: function() {
            module.deactivate.navigation();
            module.deactivate.tabs();
          },
          navigation: function() {
            $allModules.removeClass(className.active);
          },
          tabs: function() {
            $tabs.removeClass(className.active + " " + className.loading);
          }
        },
        is: {
          tab: function(tabName) {
            return tabName !== void 0 ? module.get.tabElement(tabName).length > 0 : false;
          }
        },
        get: {
          initialPath: function() {
            return $allModules.eq(0).data(metadata.tab) || $tabs.eq(0).data(metadata.tab);
          },
          path: function() {
            return $.address.value();
          },
          // adds default tabs to tab path
          defaultPathArray: function(tabPath) {
            return module.utilities.pathToArray(module.get.defaultPath(tabPath));
          },
          defaultPath: function(tabPath) {
            var $defaultNav = $allModules.filter("[data-" + metadata.tab + '^="' + module.escape.string(tabPath) + '/"]').eq(0), defaultTab = $defaultNav.data(metadata.tab) || false;
            if (defaultTab) {
              module.debug("Found default tab", defaultTab);
              if (recursionDepth < settings.maxDepth) {
                recursionDepth++;
                return module.get.defaultPath(defaultTab);
              }
              module.error(error.recursion);
            } else {
              module.debug("No default tabs found for", tabPath, $tabs);
            }
            recursionDepth = 0;
            return tabPath;
          },
          navElement: function(tabPath) {
            tabPath = tabPath || activeTabPath;
            return $allModules.filter("[data-" + metadata.tab + '="' + module.escape.string(tabPath) + '"]');
          },
          tabElement: function(tabPath) {
            var $fullPathTab, $simplePathTab, tabPathArray, lastTab;
            tabPath = tabPath || activeTabPath;
            tabPathArray = module.utilities.pathToArray(tabPath);
            lastTab = module.utilities.last(tabPathArray);
            $fullPathTab = $tabs.filter("[data-" + metadata.tab + '="' + module.escape.string(tabPath) + '"]');
            $simplePathTab = $tabs.filter("[data-" + metadata.tab + '="' + module.escape.string(lastTab) + '"]');
            return $fullPathTab.length > 0 ? $fullPathTab : $simplePathTab;
          },
          tab: function() {
            return activeTabPath;
          }
        },
        determine: {
          activeTab: function() {
            var activeTab = null;
            $tabs.each(function(_index, tab) {
              var $tab = $(tab);
              if ($tab.hasClass(className.active)) {
                var tabPath = $(this).data(metadata.tab), $anchor = $allModules.filter("[data-" + metadata.tab + '="' + module.escape.string(tabPath) + '"]');
                if ($anchor.hasClass(className.active)) {
                  activeTab = tabPath;
                }
              }
            });
            return activeTab;
          }
        },
        utilities: {
          filterArray: function(keepArray, removeArray) {
            return $.grep(keepArray, function(keepValue) {
              return $.inArray(keepValue, removeArray) === -1;
            });
          },
          last: function(array) {
            return Array.isArray(array) ? array[array.length - 1] : false;
          },
          pathToArray: function(pathName) {
            if (pathName === void 0) {
              pathName = activeTabPath;
            }
            return typeof pathName === "string" ? pathName.split("/") : [pathName];
          },
          arrayToPath: function(pathArray) {
            return Array.isArray(pathArray) ? pathArray.join("/") : false;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.tab = function() {
    $(window2).tab.apply(this, arguments);
  };
  $.fn.tab.settings = {
    name: "Tab",
    namespace: "tab",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    auto: false,
    // uses pjax style endpoints fetching content from same url with remote-content headers
    history: false,
    // use browser history
    historyType: "hash",
    // #/ or html5 state
    path: false,
    // base path of url
    context: false,
    // specify a context that tabs must appear inside
    childrenOnly: false,
    // use only tabs that are children of context
    maxDepth: 25,
    // max depth a tab can be nested
    deactivate: "siblings",
    // whether tabs should deactivate sibling menu elements or all elements initialized together
    alwaysRefresh: false,
    // load tab content new every tab click
    cache: true,
    // cache the content requests to pull locally
    loadOnce: false,
    // Whether tab data should only be loaded once when using remote content
    cacheType: "response",
    // Whether to cache exact response, or to html cache contents after scripts execute
    ignoreFirstLoad: false,
    // don't load remote content on first load
    apiSettings: false,
    // settings for api call
    evaluateScripts: "once",
    // whether inline scripts should be parsed (true/false/once). Once will not re-evaluate on cached content
    autoTabActivation: true,
    // whether a non existing active tab will auto activate the first available tab
    onFirstLoad: function(tabPath, parameterArray, historyEvent) {
    },
    // called first time loaded
    onLoad: function(tabPath, parameterArray, historyEvent) {
    },
    // called on every load
    onVisible: function(tabPath, parameterArray, historyEvent) {
    },
    // called every time tab visible
    onRequest: function(tabPath, parameterArray, historyEvent) {
    },
    // called ever time a tab beings loading remote content
    onBeforeChange: function(tabPath) {
    },
    // called before a tab is about to be changed. Returning false will cancel the tab change
    templates: {
      determineTitle: function(tabArray) {
      }
      // returns page title for path
    },
    error: {
      api: "You attempted to load content without API module",
      method: "The method you called is not defined",
      missingTab: "Activated tab cannot be found. Tabs are case-sensitive.",
      noContent: "The tab you specified is missing a content url.",
      path: "History enabled, but no path was specified",
      recursion: "Max recursive depth reached",
      state: "History requires Asual's Address library <https://github.com/asual/jquery-address>"
    },
    regExp: {
      escape: /[\s#$()*+,.:=?@[\\\]^{|}-]/g
    },
    metadata: {
      tab: "tab",
      loaded: "loaded",
      promise: "promise"
    },
    className: {
      loading: "loading",
      active: "active"
    },
    selector: {
      tabs: ".ui.tab",
      ui: ".ui"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.toast = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.toast.settings, parameters) : $.extend({}, $.fn.toast.settings), className = settings.className, selector = settings.selector, error = settings.error, namespace = settings.namespace, fields = settings.fields, eventNamespace = "." + namespace, moduleNamespace = namespace + "-module", $module = $(this), $toastBox, $toast, $actions, $progress, $progressBar, $animationObject, $close, $context = settings.context ? [window2, document2].indexOf(settings.context) < 0 ? $(document2).find(settings.context) : $(settings.context) : $("body"), isToastComponent = $module.hasClass("toast") || $module.hasClass("message") || $module.hasClass("card"), element2 = this, instance68 = isToastComponent ? $module.data(moduleNamespace) : void 0, id, module;
      module = {
        initialize: function() {
          module.verbose("Initializing element");
          module.create.id();
          if (!module.has.container()) {
            module.create.container();
          }
          if (isToastComponent || settings.message !== "" || settings.title !== "" || module.get.iconClass() !== "" || settings.showImage || module.has.configActions()) {
            if (typeof settings.showProgress !== "string" || [className.top, className.bottom].indexOf(settings.showProgress) === -1) {
              settings.showProgress = false;
            }
            module.create.toast();
            if (settings.closeOnClick && (settings.closeIcon || $($toast).find(selector.input).length > 0 || module.has.configActions())) {
              settings.closeOnClick = false;
            }
            if (!settings.closeOnClick) {
              $toastBox.addClass(className.unclickable);
            }
            module.bind.events();
          }
          module.instantiate();
          if ($toastBox) {
            module.show();
          }
        },
        instantiate: function() {
          module.verbose("Storing instance of toast");
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        destroy: function() {
          if ($toastBox) {
            module.debug("Removing toast", $toastBox);
            module.unbind.events();
            $toastBox.remove();
            $toastBox = void 0;
            $toast = void 0;
            $animationObject = void 0;
            settings.onRemove.call($toastBox, element2);
            $progress = void 0;
            $progressBar = void 0;
            $close = void 0;
          }
          $module.removeData(moduleNamespace);
        },
        show: function(callback) {
          if (settings.onShow.call($toastBox, element2) === false) {
            module.debug("onShow callback returned false, cancelling toast animation");
            return;
          }
          callback = callback || function() {
          };
          module.debug("Showing toast");
          module.animate.show(callback);
        },
        close: function(callback) {
          if (settings.onHide.call($toastBox, element2) === false) {
            module.debug("onHide callback returned false, cancelling toast animation");
            return;
          }
          callback = callback || function() {
          };
          module.debug("Closing toast");
          module.remove.visible();
          module.unbind.events();
          module.animate.close(callback);
        },
        create: {
          container: function() {
            module.verbose("Creating container");
            $context.append($("<div/>", {
              class: settings.position + " " + className.container + " " + (settings.horizontal ? className.horizontal : "") + " " + (settings.context && settings.context !== "body" ? className.absolute : "")
            }));
          },
          id: function() {
            id = (Math.random().toString(16) + "000000000").slice(2, 10);
            module.verbose("Creating unique id for element", id);
          },
          toast: function() {
            $toastBox = $("<div/>", { class: className.box });
            var iconClass = module.get.iconClass();
            if (!isToastComponent) {
              module.verbose("Creating toast");
              $toast = $("<div/>", { role: "alert" });
              var $content = $("<div/>", { class: className.content });
              if (iconClass !== "") {
                $toast.append($("<i/>", { class: iconClass + " " + className.icon }));
              }
              if (settings.showImage) {
                $toast.append($("<img>", {
                  class: className.image + " " + settings.classImage,
                  src: settings.showImage
                }));
              }
              if (settings.title !== "") {
                var titleId = "_" + module.get.id() + "title";
                $toast.attr("aria-labelledby", titleId);
                $content.append($("<div/>", {
                  class: className.title,
                  id: titleId,
                  html: module.helpers.escape(settings.title, settings.preserveHTML)
                }));
              }
              var descId = "_" + module.get.id() + "desc";
              $toast.attr("aria-describedby", descId);
              $content.append($("<div/>", {
                class: className.message,
                id: descId,
                html: module.helpers.escape(settings.message, settings.preserveHTML)
              }));
              $toast.addClass(settings.class + " " + className.toast).append($content);
              $toast.css("opacity", String(settings.opacity));
              if (settings.closeIcon) {
                $close = $("<i/>", {
                  class: className.close + " " + (typeof settings.closeIcon === "string" ? settings.closeIcon : ""),
                  role: "button",
                  tabindex: 0,
                  "aria-label": settings.text.close
                });
                if ($close.hasClass(className.left)) {
                  $toast.prepend($close);
                } else {
                  $toast.append($close);
                }
              }
            } else {
              $toast = settings.cloneModule ? $module.clone().removeAttr("id") : $module;
              $close = $toast.find("> i" + module.helpers.toClass(className.close));
              settings.closeIcon = $close.length > 0;
              if (iconClass !== "") {
                $toast.find(selector.icon).attr("class", iconClass + " " + className.icon);
              }
              if (settings.showImage) {
                $toast.find(selector.image).attr("src", settings.showImage);
              }
              if (settings.title !== "") {
                $toast.find(selector.title).html(module.helpers.escape(settings.title, settings.preserveHTML));
              }
              if (settings.message !== "") {
                $toast.find(selector.message).html(module.helpers.escape(settings.message, settings.preserveHTML));
              }
            }
            if ($toast.hasClass(className.compact)) {
              settings.compact = true;
            }
            if ($toast.hasClass("card")) {
              settings.compact = false;
            }
            $actions = $toast.find(".actions");
            if (module.has.configActions()) {
              if ($actions.length === 0) {
                $actions = $("<div/>", { class: className.actions + " " + (settings.classActions || "") }).appendTo($toast);
              }
              if ($toast.hasClass("card") && !$actions.hasClass(className.attached)) {
                $actions.addClass(className.extraContent);
                if ($actions.hasClass(className.vertical)) {
                  $actions.removeClass(className.vertical);
                  module.error(error.verticalCard);
                }
              }
              settings.actions.forEach(function(el) {
                var icon = el[fields.icon] ? "<i " + (el[fields.text] ? 'aria-hidden="true"' : "") + ' class="' + module.helpers.deQuote(el[fields.icon]) + ' icon"></i>' : "", text = module.helpers.escape(el[fields.text] || "", settings.preserveHTML), cls = module.helpers.deQuote(el[fields.class] || ""), click = el[fields.click] && isFunction(el[fields.click]) ? el[fields.click] : function() {
                };
                $actions.append($("<button/>", {
                  html: icon + text,
                  "aria-label": (el[fields.text] || el[fields.icon] || "").replace(/<[^>]+(>|$)/g, ""),
                  class: className.button + " " + cls,
                  on: {
                    click: function() {
                      var $button = $(this);
                      if ($button.is(selector.approve) || $button.is(selector.deny) || click.call(element2, $module) === false) {
                        return;
                      }
                      module.close();
                    }
                  }
                }));
              });
            }
            if ($actions && $actions.hasClass(className.vertical)) {
              $toast.addClass(className.vertical);
            }
            if ($actions.length > 0 && !$actions.hasClass(className.attached)) {
              if ($actions && (!$actions.hasClass(className.basic) || $actions.hasClass(className.left))) {
                $toast.addClass(className.actions);
              }
            }
            if (settings.displayTime === "auto") {
              settings.displayTime = Math.max(settings.minDisplayTime, $toast.text().split(" ").length / settings.wordsPerMinute * 6e4);
            }
            $toastBox.append($toast);
            if ($actions.length > 0 && $actions.hasClass(className.attached)) {
              $actions.addClass(className.buttons);
              $actions.detach();
              $toast.addClass(className.attached);
              if (!$actions.hasClass(className.vertical)) {
                if ($actions.hasClass(className.top)) {
                  $toastBox.prepend($actions);
                  $toast.addClass(className.bottom);
                } else {
                  $toastBox.append($actions);
                  $toast.addClass(className.top);
                }
              } else {
                $toast.wrap(
                  $("<div/>", {
                    class: className.vertical + " " + className.attached + " " + (settings.compact ? className.compact : "")
                  })
                );
                if ($actions.hasClass(className.left)) {
                  $toast.addClass(className.left).parent().addClass(className.left).prepend($actions);
                } else {
                  $toast.parent().append($actions);
                }
              }
            }
            if ($module !== $toast) {
              $module = $toast;
              element2 = $toast[0];
            }
            if (settings.displayTime > 0) {
              var progressingClass = className.progressing + " " + (settings.pauseOnHover ? className.pausable : "");
              if (settings.showProgress) {
                $progress = $("<div/>", {
                  class: className.progress + " " + (settings.classProgress || settings.class),
                  "data-percent": ""
                });
                if (!settings.classProgress) {
                  if ($toast.hasClass("toast") && !$toast.hasClass(className.inverted)) {
                    $progress.addClass(className.inverted);
                  } else {
                    $progress.removeClass(className.inverted);
                  }
                }
                $progressBar = $("<div/>", { class: "bar " + (settings.progressUp ? "up " : "down ") + progressingClass });
                $progress.addClass(settings.showProgress).append($progressBar);
                if ($progress.hasClass(className.top)) {
                  $toastBox.prepend($progress);
                } else {
                  $toastBox.append($progress);
                }
                $progressBar.css("animation-duration", settings.displayTime / 1e3 + "s");
              }
              $animationObject = $("<span/>", { class: "wait " + progressingClass });
              $animationObject.css("animation-duration", settings.displayTime / 1e3 + "s");
              $animationObject.appendTo($toast);
            }
            if (settings.compact) {
              $toastBox.addClass(className.compact);
              $toast.addClass(className.compact);
              if ($progress) {
                $progress.addClass(className.compact);
              }
            }
            if (settings.newestOnTop) {
              $toastBox.prependTo(module.get.container());
            } else {
              $toastBox.appendTo(module.get.container());
            }
          }
        },
        bind: {
          events: function() {
            module.debug("Binding events to toast");
            if (settings.closeIcon) {
              $close.on("click" + eventNamespace, module.event.close);
            }
            $toast.on("click" + eventNamespace, module.event.click);
            if ($animationObject) {
              $animationObject.on("animationend" + eventNamespace, module.event.close);
            }
            $toastBox.on("click" + eventNamespace, selector.approve, module.event.approve).on("click" + eventNamespace, selector.deny, module.event.deny);
          }
        },
        unbind: {
          events: function() {
            module.debug("Unbinding events to toast");
            if (settings.closeIcon) {
              $close.off("click" + eventNamespace);
            }
            $toast.off("click" + eventNamespace);
            if ($animationObject) {
              $animationObject.off("animationend" + eventNamespace);
            }
            $toastBox.off("click" + eventNamespace);
          }
        },
        animate: {
          show: function(callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            if (settings.transition && module.can.useElement("transition")) {
              module.set.visible();
              $toastBox.transition({
                animation: settings.transition.showMethod + " in",
                queue: false,
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                duration: settings.transition.showDuration,
                onComplete: function() {
                  callback.call($toastBox, element2);
                  settings.onVisible.call($toastBox, element2);
                }
              });
            }
          },
          close: function(callback) {
            callback = isFunction(callback) ? callback : function() {
            };
            if (settings.transition && $.fn.transition !== void 0) {
              $toastBox.transition({
                animation: settings.transition.hideMethod + " out",
                queue: false,
                duration: settings.transition.hideDuration,
                debug: settings.debug,
                verbose: settings.verbose,
                silent: settings.silent,
                interval: 50,
                onBeforeHide: function(callback2) {
                  callback2 = isFunction(callback2) ? callback2 : function() {
                  };
                  if (settings.transition.closeEasing !== "") {
                    if ($toastBox) {
                      $toastBox.css("opacity", "0");
                      $toastBox.wrap("<div/>").parent().hide(settings.transition.closeDuration, settings.transition.closeEasing, function() {
                        if ($toastBox) {
                          $toastBox.parent().remove();
                          callback2.call($toastBox);
                        }
                      });
                    }
                  } else {
                    callback2.call($toastBox);
                  }
                },
                onComplete: function() {
                  callback.call($toastBox, element2);
                  settings.onHidden.call($toastBox, element2);
                  module.destroy();
                }
              });
            } else {
              module.error(error.noTransition);
            }
          },
          pause: function() {
            $animationObject.css("animationPlayState", "paused");
            if ($progressBar) {
              $progressBar.css("animationPlayState", "paused");
            }
          },
          continue: function() {
            $animationObject.css("animationPlayState", "running");
            if ($progressBar) {
              $progressBar.css("animationPlayState", "running");
            }
          }
        },
        has: {
          container: function() {
            module.verbose("Determining if there is already a container");
            return module.get.containers().length > 0;
          },
          toast: function() {
            return !!module.get.toast();
          },
          toasts: function() {
            return module.get.toasts().length > 0;
          },
          configActions: function() {
            return Array.isArray(settings.actions) && settings.actions.length > 0;
          }
        },
        get: {
          id: function() {
            return id;
          },
          containers: function() {
            return $context.children(module.helpers.toClass(settings.position) + selector.container + (settings.horizontal ? module.helpers.toClass(className.horizontal) : ":not(" + module.helpers.toClass(className.horizontal) + ")") + (settings.context && settings.context !== "body" ? module.helpers.toClass(className.absolute) : ":not(" + module.helpers.toClass(className.absolute) + ")"));
          },
          container: function() {
            return module.get.containers()[0];
          },
          toastBox: function() {
            return $toastBox || null;
          },
          toast: function() {
            return $toast || null;
          },
          toasts: function() {
            return $(module.get.container()).find(selector.box);
          },
          iconClass: function() {
            return typeof settings.showIcon === "string" ? settings.showIcon : settings.showIcon && settings.icons[settings.class] ? settings.icons[settings.class] : "";
          },
          remainingTime: function() {
            return $animationObject ? $animationObject.css("opacity") * settings.displayTime : 0;
          }
        },
        set: {
          visible: function() {
            $toast.addClass(className.visible);
          }
        },
        remove: {
          visible: function() {
            $toast.removeClass(className.visible);
          }
        },
        event: {
          close: function() {
            module.close();
          },
          click: function(event2) {
            if ($(event2.target).closest(selector.clickable).length === 0) {
              if (settings.onClick.call($toastBox, element2) === false || !settings.closeOnClick) {
                module.verbose("Click callback returned false or close denied by setting cancelling close");
                return;
              }
              module.close();
            }
          },
          approve: function() {
            if (settings.onApprove.call(element2, $module) === false) {
              module.verbose("Approve callback returned false cancelling close");
              return;
            }
            module.close();
          },
          deny: function() {
            if (settings.onDeny.call(element2, $module) === false) {
              module.verbose("Deny callback returned false cancelling close");
              return;
            }
            module.close();
          }
        },
        helpers: {
          toClass: function(selector2) {
            var classes = selector2.trim().split(/\s+/), result = "";
            classes.forEach(function(element3) {
              result += "." + element3;
            });
            return result;
          },
          deQuote: function(string) {
            return String(string).replace(/"/g, "");
          },
          escape: function(string, preserveHTML) {
            if (preserveHTML) {
              return string;
            }
            var badChars = /["'<>`]/g, shouldEscape = /["&'<>`]/, escape2 = {
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#x27;",
              "`": "&#x60;"
            }, escapedChar = function(chr) {
              return escape2[chr];
            };
            if (shouldEscape.test(string)) {
              string = string.replace(/&(?![\d#a-z]{1,12};)/gi, "&amp;");
              return string.replace(badChars, escapedChar);
            }
            return string;
          }
        },
        can: {
          useElement: function(element3) {
            if ($.fn[element3] !== void 0) {
              return true;
            }
            module.error(error.noElement.replace("{element}", element3));
            return false;
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
        returnedValue = $module;
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.toast = $.fn.toast;
  $.fn.toast.settings = {
    name: "Toast",
    namespace: "toast",
    silent: false,
    debug: false,
    verbose: false,
    performance: true,
    context: "body",
    position: "top right",
    horizontal: false,
    class: "neutral",
    classProgress: false,
    classActions: false,
    classImage: "mini",
    title: "",
    message: "",
    displayTime: 3e3,
    // set to zero to require manually dismissal, otherwise hides on its own
    minDisplayTime: 1e3,
    // minimum displaytime in case displayTime is set to 'auto'
    wordsPerMinute: 120,
    showIcon: false,
    newestOnTop: false,
    showProgress: false,
    pauseOnHover: true,
    progressUp: false,
    // if true, the bar will start at 0% and increase to 100%
    opacity: 1,
    compact: true,
    closeIcon: false,
    closeOnClick: true,
    cloneModule: true,
    actions: false,
    preserveHTML: true,
    showImage: false,
    // transition settings
    transition: {
      showMethod: "scale",
      showDuration: 500,
      hideMethod: "scale",
      hideDuration: 500,
      closeEasing: "easeOutCubic",
      // Set to empty string to stack the closed toast area immediately (old behaviour)
      closeDuration: 500
    },
    error: {
      method: "The method you called is not defined.",
      noElement: "This module requires ui {element}",
      verticalCard: "Vertical but not attached actions are not supported for card layout"
    },
    className: {
      container: "ui toast-container",
      absolute: "absolute",
      box: "floating toast-box",
      progress: "ui attached active progress",
      toast: "ui toast",
      icon: "centered icon",
      visible: "visible",
      content: "content",
      title: "ui header",
      message: "message",
      actions: "actions",
      extraContent: "extra content",
      button: "ui button",
      buttons: "ui buttons",
      close: "close icon",
      image: "ui image",
      vertical: "vertical",
      horizontal: "horizontal",
      attached: "attached",
      inverted: "inverted",
      compact: "compact",
      pausable: "pausable",
      progressing: "progressing",
      top: "top",
      bottom: "bottom",
      left: "left",
      basic: "basic",
      unclickable: "unclickable"
    },
    text: {
      close: "Close"
    },
    icons: {
      info: "info",
      success: "checkmark",
      warning: "warning",
      error: "times"
    },
    selector: {
      container: ".ui.toast-container",
      box: ".toast-box",
      toast: ".ui.toast",
      title: ".header",
      message: ".message:not(.ui)",
      image: "> img.image, > .image > img",
      icon: "> i.icon",
      input: 'input:not([type="hidden"]), textarea, select, button, .ui.button, ui.dropdown',
      clickable: "a, details, .ui.accordion",
      approve: ".actions .positive, .actions .approve, .actions .ok",
      deny: ".actions .negative, .actions .deny, .actions .cancel"
    },
    fields: {
      class: "class",
      text: "text",
      icon: "icon",
      click: "click"
    },
    // callbacks
    onShow: function() {
    },
    onVisible: function() {
    },
    onClick: function() {
    },
    onHide: function() {
    },
    onHidden: function() {
    },
    onRemove: function() {
    },
    onApprove: function() {
    },
    onDeny: function() {
    }
  };
  $.extend($.easing, {
    easeOutBounce: function(x) {
      var n1 = 7.5625, d1 = 2.75;
      if (x < 1 / d1) {
        return n1 * x * x;
      }
      if (x < 2 / d1) {
        x -= 1.5 / d1;
        return n1 * x * x + 0.75;
      }
      if (x < 2.5 / d1) {
        x -= 2.25 / d1;
        return n1 * x * x + 0.9375;
      }
      x -= 2.625 / d1;
      return n1 * x * x + 0.984375;
    },
    easeOutCubic: function(t) {
      return --t * t * t + 1;
    }
  });
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.transition = function() {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], moduleArguments = arguments, query = moduleArguments[0], queryArguments = [].slice.call(arguments, 1), methodInvoked = typeof query === "string", returnedValue;
    $allModules.each(function(index) {
      var $module = $(this), element2 = this, settings, instance68, error, className, metadata, moduleNamespace, eventNamespace, module;
      module = {
        initialize: function() {
          settings = module.get.settings.apply(element2, moduleArguments);
          className = settings.className;
          error = settings.error;
          metadata = settings.metadata;
          eventNamespace = "." + settings.namespace;
          moduleNamespace = "module-" + settings.namespace;
          instance68 = $module.data(moduleNamespace) || module;
          if (methodInvoked) {
            methodInvoked = module.invoke(query);
          }
          if (methodInvoked === false) {
            module.verbose("Converted arguments into settings object", settings);
            if (settings.interval) {
              module.delay(settings.interval);
            } else {
              module.animate();
            }
            module.instantiate();
          }
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        destroy: function() {
          module.verbose("Destroying previous module for", element2);
          $module.removeData(moduleNamespace);
        },
        refresh: function() {
          module.verbose("Refreshing display type on next animation");
          delete module.displayType;
        },
        forceRepaint: function() {
          module.verbose("Forcing element repaint");
          var $parentElement = $module.parent(), $nextElement = $module.next();
          if ($nextElement.length === 0) {
            $module.detach().appendTo($parentElement);
          } else {
            $module.detach().insertBefore($nextElement);
          }
        },
        repaint: function() {
          module.verbose("Repainting element");
          var fakeAssignment = element2.offsetWidth;
        },
        delay: function(interval) {
          var direction = module.get.animationDirection(), shouldReverse, delay;
          if (!direction) {
            direction = module.can.transition() ? module.get.direction() : "static";
          }
          interval = interval !== void 0 ? interval : settings.interval;
          shouldReverse = settings.reverse === "auto" && direction === className.outward;
          delay = shouldReverse || settings.reverse === true ? ($allModules.length - index) * interval : index * interval;
          module.debug("Delaying animation by", delay);
          setTimeout(module.animate, delay);
        },
        animate: function(overrideSettings) {
          settings = overrideSettings || settings;
          module.debug("Preparing animation", settings.animation);
          if (module.is.animating()) {
            if (settings.queue) {
              if (!settings.allowRepeats && module.has.direction() && module.is.occurring() && module.queuing !== true) {
                module.debug("Animation is currently occurring, preventing queueing same animation", settings.animation);
              } else {
                module.queue(settings.animation);
              }
              return false;
            }
            if (!settings.allowRepeats && module.is.occurring()) {
              module.debug("Animation is already occurring, will not execute repeated animation", settings.animation);
              return false;
            }
            module.debug("New animation started, completing previous early", settings.animation);
            instance68.complete();
          }
          if (module.can.animate()) {
            module.set.animating(settings.animation);
          } else {
            module.error(error.noAnimation, settings.animation, element2);
          }
        },
        reset: function() {
          module.debug("Resetting animation to beginning conditions");
          module.remove.animationCallbacks();
          module.restore.conditions();
          module.remove.animating();
        },
        queue: function(animation) {
          module.debug("Queueing animation of", animation);
          module.queuing = true;
          $module.one("animationend.queue" + eventNamespace, function() {
            module.queuing = false;
            module.repaint();
            module.animate.apply(this, settings);
          });
        },
        complete: function(event2) {
          if (event2 && event2.target === element2) {
            event2.stopPropagation();
          }
          module.debug("Animation complete", settings.animation);
          module.remove.completeCallback();
          module.remove.failSafe();
          if (!module.is.looping()) {
            if (module.is.outward()) {
              module.verbose("Animation is outward, hiding element");
              module.restore.conditions();
              module.hide();
            } else if (module.is.inward()) {
              module.verbose("Animation is inward, showing element");
              module.restore.conditions();
              module.show();
            } else {
              module.verbose("Static animation completed");
              module.restore.conditions();
              settings.onComplete.call(element2);
            }
          }
        },
        force: {
          visible: function() {
            var style = $module.attr("style"), userStyle = module.get.userStyle(style), displayType = module.get.displayType(), overrideStyle = userStyle + "display: " + displayType + " !important;", inlineDisplay = $module[0].style.display, mustStayHidden = !displayType || inlineDisplay === "none" && settings.skipInlineHidden || $module[0].tagName.match(/(script|link|style)/i);
            if (mustStayHidden) {
              module.remove.transition();
              return false;
            }
            module.verbose("Overriding default display to show element", displayType);
            $module.attr("style", overrideStyle);
            return true;
          },
          hidden: function() {
            var style = $module.attr("style"), currentDisplay = $module.css("display"), emptyStyle = style === void 0 || style === "";
            if (currentDisplay !== "none" && !module.is.hidden()) {
              module.verbose("Overriding default display to hide element");
              $module.css("display", "none");
            } else if (emptyStyle) {
              $module.removeAttr("style");
            }
          }
        },
        has: {
          direction: function(animation) {
            var hasDirection = false;
            animation = animation || settings.animation;
            if (typeof animation === "string") {
              animation = animation.split(" ");
              $.each(animation, function(index2, word) {
                if (word === className.inward || word === className.outward) {
                  hasDirection = true;
                }
              });
            }
            return hasDirection;
          },
          inlineDisplay: function() {
            var style = $module.attr("style") || "";
            return Array.isArray(style.match(/display.*?;/, ""));
          }
        },
        set: {
          animating: function(animation) {
            module.remove.completeCallback();
            animation = animation || settings.animation;
            var animationClass = module.get.animationClass(animation);
            module.save.animation(animationClass);
            if (module.force.visible()) {
              module.remove.hidden();
              module.remove.direction();
              module.start.animation(animationClass);
            }
          },
          duration: function(animationName, duration) {
            duration = duration || settings.duration;
            duration = typeof duration === "number" ? duration + "ms" : duration;
            if (duration || duration === 0) {
              module.verbose("Setting animation duration", duration);
              $module.css({
                "animation-duration": duration
              });
            }
          },
          direction: function(direction) {
            direction = direction || module.get.direction();
            if (direction === className.inward) {
              module.set.inward();
            } else {
              module.set.outward();
            }
          },
          looping: function() {
            module.debug("Transition set to loop");
            $module.addClass(className.looping);
          },
          hidden: function() {
            $module.addClass(className.transition).addClass(className.hidden);
          },
          inward: function() {
            module.debug("Setting direction to inward");
            $module.removeClass(className.outward).addClass(className.inward);
          },
          outward: function() {
            module.debug("Setting direction to outward");
            $module.removeClass(className.inward).addClass(className.outward);
          },
          visible: function() {
            $module.addClass(className.transition).addClass(className.visible);
          }
        },
        start: {
          animation: function(animationClass) {
            animationClass = animationClass || module.get.animationClass();
            module.debug("Starting tween", animationClass);
            $module.addClass(animationClass).one("animationend.complete" + eventNamespace, module.complete);
            if (settings.useFailSafe) {
              module.add.failSafe();
            }
            module.set.duration(settings.duration);
            settings.onStart.call(element2);
          }
        },
        save: {
          animation: function(animation) {
            if (!module.cache) {
              module.cache = {};
            }
            module.cache.animation = animation;
          },
          displayType: function(displayType) {
            if (displayType !== "none") {
              $module.data(metadata.displayType, displayType);
            }
          },
          transitionExists: function(animation, exists) {
            $.fn.transition.exists[animation] = exists;
            module.verbose("Saving existence of transition", animation, exists);
          }
        },
        restore: {
          conditions: function() {
            var animation = module.get.currentAnimation();
            if (animation) {
              $module.removeClass(animation);
              module.verbose("Removing animation class", module.cache);
            }
            module.remove.duration();
          }
        },
        add: {
          failSafe: function() {
            var duration = module.get.duration();
            module.timer = setTimeout(function() {
              $module.triggerHandler("animationend");
            }, duration + settings.failSafeDelay);
            module.verbose("Adding fail safe timer", module.timer);
          }
        },
        remove: {
          animating: function() {
            $module.removeClass(className.animating);
          },
          animationCallbacks: function() {
            module.remove.queueCallback();
            module.remove.completeCallback();
          },
          queueCallback: function() {
            $module.off(".queue" + eventNamespace);
          },
          completeCallback: function() {
            $module.off(".complete" + eventNamespace);
          },
          display: function() {
            $module.css("display", "");
          },
          direction: function() {
            $module.removeClass(className.inward).removeClass(className.outward);
          },
          duration: function() {
            $module.css("animation-duration", "");
          },
          failSafe: function() {
            module.verbose("Removing fail safe timer", module.timer);
            if (module.timer) {
              clearTimeout(module.timer);
            }
          },
          hidden: function() {
            $module.removeClass(className.hidden);
          },
          visible: function() {
            $module.removeClass(className.visible);
          },
          looping: function() {
            module.debug("Transitions are no longer looping");
            if (module.is.looping()) {
              module.reset();
              $module.removeClass(className.looping);
            }
          },
          transition: function() {
            $module.removeClass(className.transition).removeClass(className.visible).removeClass(className.hidden);
          }
        },
        get: {
          settings: function(animation, duration, onComplete) {
            if (typeof animation === "object") {
              return $.extend(true, {}, $.fn.transition.settings, animation);
            }
            if (typeof onComplete === "function") {
              return $.extend({}, $.fn.transition.settings, {
                animation,
                onComplete,
                duration
              });
            }
            if (typeof duration === "string" || typeof duration === "number") {
              return $.extend({}, $.fn.transition.settings, {
                animation,
                duration
              });
            }
            if (typeof duration === "object") {
              return $.extend({}, $.fn.transition.settings, duration, {
                animation
              });
            }
            if (typeof duration === "function") {
              return $.extend({}, $.fn.transition.settings, {
                animation,
                onComplete: duration
              });
            }
            return $.extend({}, $.fn.transition.settings, {
              animation
            });
          },
          animationClass: function(animation) {
            var animationClass = animation || settings.animation, directionClass = module.can.transition() && !module.has.direction() ? module.get.direction() + " " : "";
            return className.animating + " " + className.transition + " " + directionClass + animationClass;
          },
          currentAnimation: function() {
            return module.cache && module.cache.animation !== void 0 ? module.cache.animation : false;
          },
          currentDirection: function() {
            return module.is.inward() ? className.inward : className.outward;
          },
          direction: function() {
            return module.is.hidden() || !module.is.visible() ? className.inward : className.outward;
          },
          animationDirection: function(animation) {
            var direction;
            animation = animation || settings.animation;
            if (typeof animation === "string") {
              animation = animation.split(" ");
              $.each(animation, function(index2, word) {
                if (word === className.inward) {
                  direction = className.inward;
                } else if (word === className.outward) {
                  direction = className.outward;
                }
              });
            }
            if (direction) {
              return direction;
            }
            return false;
          },
          duration: function(duration) {
            duration = duration || settings.duration;
            if (duration === false) {
              duration = $module.css("animation-duration") || 0;
            }
            return typeof duration === "string" ? duration.indexOf("ms") > -1 ? parseFloat(duration) : parseFloat(duration) * 1e3 : duration;
          },
          displayType: function(shouldDetermine) {
            shouldDetermine = shouldDetermine !== void 0 ? shouldDetermine : true;
            if (settings.displayType) {
              return settings.displayType;
            }
            if (shouldDetermine && $module.data(metadata.displayType) === void 0) {
              var currentDisplay = $module.css("display");
              if (currentDisplay === "" || currentDisplay === "none") {
                module.can.transition(true);
              } else {
                module.save.displayType(currentDisplay);
              }
            }
            return $module.data(metadata.displayType);
          },
          userStyle: function(style) {
            style = style || $module.attr("style") || "";
            return style.replace(/display.*?;/, "");
          },
          transitionExists: function(animation) {
            return $.fn.transition.exists[animation];
          }
        },
        can: {
          transition: function(forced) {
            var animation = settings.animation, transitionExists = module.get.transitionExists(animation), displayType = module.get.displayType(false), elementClass, tagName, $clone, currentAnimation, inAnimation, directionExists;
            if (transitionExists === void 0 || forced) {
              module.verbose("Determining whether animation exists");
              elementClass = $module.attr("class");
              tagName = $module.prop("tagName");
              $clone = $("<" + tagName + " />").addClass(elementClass).insertAfter($module);
              currentAnimation = $clone.addClass(animation).removeClass(className.inward).removeClass(className.outward).addClass(className.animating).addClass(className.transition).css("animationName");
              $clone.detach().insertAfter($module);
              inAnimation = $clone.addClass(className.inward).css("animationName");
              if (!displayType) {
                $clone.detach().insertAfter($module);
                displayType = $clone.attr("class", elementClass).removeAttr("style").removeClass(className.hidden).removeClass(className.visible).show().css("display");
                module.verbose("Determining final display state", displayType);
                module.save.displayType(displayType);
              }
              $clone.remove();
              if (currentAnimation !== inAnimation) {
                module.debug("Direction exists for animation", animation);
                directionExists = true;
              } else if (currentAnimation === "none" || !currentAnimation) {
                module.debug("No animation defined in css", animation);
                return;
              } else {
                module.debug("Static animation found", animation, displayType);
                directionExists = false;
              }
              module.save.transitionExists(animation, directionExists);
            }
            return transitionExists !== void 0 ? transitionExists : directionExists;
          },
          animate: function() {
            return module.can.transition() !== void 0;
          }
        },
        is: {
          animating: function() {
            return $module.hasClass(className.animating);
          },
          inward: function() {
            return $module.hasClass(className.inward);
          },
          outward: function() {
            return $module.hasClass(className.outward);
          },
          looping: function() {
            return $module.hasClass(className.looping);
          },
          occurring: function(animation) {
            animation = animation || settings.animation;
            animation = "." + animation.replace(" ", ".");
            return $module.filter(animation).length > 0;
          },
          visible: function() {
            return $module.is(":visible");
          },
          hidden: function() {
            return $module.css("visibility") === "hidden";
          },
          supported: function() {
            return true;
          }
        },
        hide: function() {
          if (settings.onHide.call(element2) === false) {
            module.verbose("Hide callback returned false cancelling hide");
            return false;
          }
          module.verbose("Hiding element");
          if (module.is.animating()) {
            module.reset();
          }
          element2.blur();
          module.remove.display();
          module.remove.visible();
          settings.onBeforeHide.call(element2, module.hideNow);
        },
        hideNow: function() {
          module.set.hidden();
          module.force.hidden();
          settings.onHidden.call(element2);
          settings.onComplete.call(element2);
        },
        show: function(display) {
          if (module.force.visible() && settings.onShow.call(element2) !== false) {
            module.verbose("Showing element", display);
            module.remove.hidden();
            settings.onBeforeShow.call(element2, module.showNow);
          }
        },
        showNow: function() {
          module.set.visible();
          settings.onVisible.call(element2);
          settings.onComplete.call(element2);
        },
        toggle: function() {
          if (module.is.visible()) {
            module.hide();
          } else {
            module.show();
          }
        },
        stop: function() {
          module.debug("Stopping current animation");
          $module.triggerHandler("animationend");
        },
        stopAll: function() {
          module.debug("Stopping all animation");
          module.remove.queueCallback();
          $module.triggerHandler("animationend");
        },
        clear: {
          queue: function() {
            module.debug("Clearing animation queue");
            module.remove.queueCallback();
          }
        },
        enable: function() {
          module.verbose("Starting animation");
          $module.removeClass(className.disabled);
        },
        disable: function() {
          module.debug("Stopping animation");
          $module.addClass(className.disabled);
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index2, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if ($allModules.length > 1) {
              title += " (" + $allModules.length + ")";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index2, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        // modified for transition to return invoke success
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found !== void 0 ? found : false;
        }
      };
      module.initialize();
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.transition.exists = {};
  $.fn.transition.settings = {
    // module info
    name: "Transition",
    // hide all output from this component regardless of other settings
    silent: false,
    // debug content outputted to console
    debug: false,
    // verbose debug output
    verbose: false,
    // performance data output
    performance: true,
    // event namespace
    namespace: "transition",
    // delay between animations in group
    interval: 0,
    // whether group animations should be reversed
    reverse: "auto",
    // animation callback event
    onStart: function() {
    },
    onComplete: function() {
    },
    onShow: function() {
    },
    onBeforeShow: function(callback) {
      callback.call(this);
    },
    onVisible: function() {
    },
    onHide: function() {
    },
    onHidden: function() {
    },
    onBeforeHide: function(callback) {
      callback.call(this);
    },
    // whether timeout should be used to ensure callback fires in cases animationend does not
    useFailSafe: true,
    // delay in ms for fail safe
    failSafeDelay: 100,
    // whether EXACT animation can occur twice in a row
    allowRepeats: false,
    // Override final display type on visible
    displayType: false,
    // animation duration
    animation: "fade",
    duration: false,
    // new animations will occur after previous ones
    queue: true,
    // whether initially inline hidden objects should be skipped for transition
    skipInlineHidden: false,
    metadata: {
      displayType: "display"
    },
    className: {
      animating: "animating",
      disabled: "disabled",
      hidden: "hidden",
      inward: "in",
      loading: "loading",
      looping: "looping",
      outward: "out",
      transition: "transition",
      visible: "visible"
    },
    // possible errors
    error: {
      noAnimation: "Element is no longer attached to DOM. Unable to animate.  Use silent setting to suppress this warning in production."
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isWindow(obj) {
    return obj !== null && obj === obj.window;
  }
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.api = function(parameters) {
    var $allModules = isFunction(this) ? $(window2) : $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.api.settings, parameters) : $.extend({}, $.fn.api.settings), namespace = settings.namespace, metadata = settings.metadata, selector = settings.selector, error = settings.error, className = settings.className, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $module = $(this), $form = $module.closest(selector.form), $context = settings.stateContext ? [window2, document2].indexOf(settings.stateContext) < 0 ? $(document2).find(settings.stateContext) : $(settings.stateContext) : $module, ajaxSettings, requestSettings, url, data, requestStartTime, originalData, element2 = this, context = $context[0], instance68 = $module.data(moduleNamespace), module;
      module = {
        initialize: function() {
          if (!methodInvoked) {
            originalData = settings.data;
            module.bind.events();
          }
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, instance68);
        },
        destroy: function() {
          module.verbose("Destroying previous module for", element2);
          $module.removeData(moduleNamespace).off(eventNamespace);
        },
        bind: {
          events: function() {
            var triggerEvent = module.get.event();
            if (triggerEvent) {
              module.verbose("Attaching API events to element", triggerEvent);
              $module.on(triggerEvent + eventNamespace, module.event.trigger);
            } else if (settings.on === "now") {
              module.debug("Querying API endpoint immediately");
              module.query();
            }
          }
        },
        decode: {
          json: function(response) {
            if (response !== void 0 && typeof response === "string") {
              try {
                response = JSON.parse(response);
              } catch (e) {
              }
            }
            return response;
          }
        },
        read: {
          cachedResponse: function(url2) {
            var response;
            if (window2.Storage === void 0) {
              module.error(error.noStorage);
              return;
            }
            response = sessionStorage.getItem(url2 + module.get.normalizedData());
            module.debug("Using cached response", url2, settings.data, response);
            response = module.decode.json(response);
            return response;
          }
        },
        write: {
          cachedResponse: function(url2, response) {
            if (window2.Storage === void 0) {
              module.error(error.noStorage);
              return;
            }
            if ($.isPlainObject(response)) {
              response = JSON.stringify(response);
            }
            sessionStorage.setItem(url2 + module.get.normalizedData(), response);
            module.verbose("Storing cached response for url", url2, settings.data, response);
          }
        },
        query: function() {
          if (module.is.disabled()) {
            module.debug("Element is disabled API request aborted");
            return;
          }
          if (module.is.loading()) {
            if (settings.interruptRequests) {
              module.debug("Interrupting previous request");
              module.abort();
            } else {
              module.debug("Cancelling request, previous request is still pending");
              return;
            }
          }
          if (settings.defaultData) {
            $.extend(true, settings.urlData, module.get.defaultData());
          }
          if (settings.serializeForm) {
            settings.data = module.add.formData(originalData || settings.data);
          }
          requestSettings = module.get.settings();
          if (requestSettings === false) {
            module.cancelled = true;
            module.error(error.beforeSend);
            return;
          }
          module.cancelled = false;
          url = module.get.templatedURL();
          if (!url && !module.is.mocked()) {
            module.error(error.missingURL);
            return;
          }
          url = module.add.urlData(url);
          if (!url && !module.is.mocked()) {
            return;
          }
          requestSettings.url = settings.base + url;
          ajaxSettings = $.extend(true, {}, settings, {
            type: settings.method || settings.type,
            data,
            url: settings.base + url,
            beforeSend: settings.beforeXHR,
            success: function() {
            },
            failure: function() {
            },
            complete: function() {
            }
          });
          module.debug("Querying URL", ajaxSettings.url);
          module.verbose("Using AJAX settings", ajaxSettings);
          if (settings.cache === "local" && module.read.cachedResponse(url)) {
            module.debug("Response returned from local cache");
            module.request = module.create.request();
            module.request.resolveWith(context, [module.read.cachedResponse(url)]);
            return;
          }
          if (!settings.throttle) {
            module.debug("Sending request", data, ajaxSettings.method);
            module.send.request();
          } else {
            if (!settings.throttleFirstRequest && !module.timer) {
              module.debug("Sending request", data, ajaxSettings.method);
              module.send.request();
              module.timer = setTimeout(function() {
              }, settings.throttle);
            } else {
              module.debug("Throttling request", settings.throttle);
              clearTimeout(module.timer);
              module.timer = setTimeout(function() {
                if (module.timer) {
                  delete module.timer;
                }
                module.debug("Sending throttled request", data, ajaxSettings.method);
                module.send.request();
              }, settings.throttle);
            }
          }
        },
        should: {
          removeError: function() {
            return settings.hideError === true || settings.hideError === "auto" && !module.is.form();
          }
        },
        is: {
          disabled: function() {
            return $module.filter(selector.disabled).length > 0;
          },
          expectingJSON: function() {
            return settings.dataType === "json" || settings.dataType === "jsonp";
          },
          form: function() {
            return $module.is("form") || $context.is("form");
          },
          mocked: function() {
            return settings.mockResponse || settings.mockResponseAsync || settings.response || settings.responseAsync;
          },
          input: function() {
            return $module.is("input");
          },
          loading: function() {
            return module.request ? module.request.state() === "pending" : false;
          },
          abortedRequest: function(xhr) {
            if (xhr && xhr.readyState !== void 0 && xhr.readyState === 0) {
              module.verbose("XHR request determined to be aborted");
              return true;
            }
            module.verbose("XHR request was not aborted");
            return false;
          },
          validResponse: function(response) {
            if (!module.is.expectingJSON() || !isFunction(settings.successTest)) {
              module.verbose("Response is not JSON, skipping validation", settings.successTest, response);
              return true;
            }
            module.debug("Checking JSON returned success", settings.successTest, response);
            if (settings.successTest(response)) {
              module.debug("Response passed success test", response);
              return true;
            }
            module.debug("Response failed success test", response);
            return false;
          }
        },
        was: {
          cancelled: function() {
            return module.cancelled || false;
          },
          successful: function() {
            return module.request && module.request.state() === "resolved";
          },
          failure: function() {
            return module.request && module.request.state() === "rejected";
          },
          complete: function() {
            return module.request && (module.request.state() === "resolved" || module.request.state() === "rejected");
          }
        },
        add: {
          urlData: function(url2, urlData) {
            var requiredVariables, optionalVariables;
            if (url2) {
              requiredVariables = url2.match(settings.regExp.required);
              optionalVariables = url2.match(settings.regExp.optional);
              urlData = urlData || settings.urlData;
              if (requiredVariables) {
                module.debug("Looking for required URL variables", requiredVariables);
                $.each(requiredVariables, function(index, templatedString) {
                  var variable = templatedString.indexOf("$") !== -1 ? templatedString.slice(2, -1) : templatedString.slice(1, -1), value = $.isPlainObject(urlData) && urlData[variable] !== void 0 ? urlData[variable] : $module.data(variable) !== void 0 ? $module.data(variable) : $context.data(variable) !== void 0 ? $context.data(variable) : urlData[variable];
                  if (value === void 0) {
                    module.error(error.requiredParameter, variable, url2);
                    url2 = false;
                    return false;
                  }
                  module.verbose("Found required variable", variable, value);
                  value = settings.encodeParameters ? module.get.urlEncodedValue(value) : value;
                  url2 = url2.replace(templatedString, value);
                });
              }
              if (optionalVariables) {
                module.debug("Looking for optional URL variables", requiredVariables);
                $.each(optionalVariables, function(index, templatedString) {
                  var variable = templatedString.indexOf("$") !== -1 ? templatedString.slice(3, -1) : templatedString.slice(2, -1), value = $.isPlainObject(urlData) && urlData[variable] !== void 0 ? urlData[variable] : $module.data(variable) !== void 0 ? $module.data(variable) : $context.data(variable) !== void 0 ? $context.data(variable) : urlData[variable];
                  if (value !== void 0) {
                    module.verbose("Optional variable Found", variable, value);
                    url2 = url2.replace(templatedString, value);
                  } else {
                    module.verbose("Optional variable not found", variable);
                    url2 = url2.indexOf("/" + templatedString) !== -1 ? url2.replace("/" + templatedString, "") : url2.replace(templatedString, "");
                  }
                });
              }
            }
            return url2;
          },
          formData: function(data2) {
            var formData = {}, hasOtherData, useFormDataApi = settings.serializeForm === "formdata";
            data2 = data2 || originalData || settings.data;
            hasOtherData = $.isPlainObject(data2);
            if (useFormDataApi) {
              formData = new FormData($form[0]);
              settings.processData = settings.processData !== void 0 ? settings.processData : false;
              settings.contentType = settings.contentType !== void 0 ? settings.contentType : false;
            } else {
              var formArray = $form.serializeArray(), pushes = {}, pushValues = {}, build = function(base, key, value) {
                base[key] = value;
                return base;
              };
              $.each($('input[type="file"]', $form), function(i, tag) {
                $.each($(tag)[0].files, function(j, file67) {
                  formArray.push({ name: tag.name, value: file67 });
                });
              });
              $.each(formArray, function(i, el) {
                if (!settings.regExp.validate.test(el.name)) {
                  return;
                }
                var isCheckbox = $('[name="' + el.name + '"]', $form).attr("type") === "checkbox", floatValue = parseFloat(el.value), value = isCheckbox && el.value === "on" || el.value === "true" || (String(floatValue) === el.value ? floatValue : el.value === "false" ? false : el.value), nameKeys = el.name.match(settings.regExp.key) || [], pushKey = el.name.replace(/\[]$/, "");
                if (!(pushKey in pushes)) {
                  pushes[pushKey] = 0;
                  pushValues[pushKey] = value;
                } else if (Array.isArray(pushValues[pushKey])) {
                  pushValues[pushKey].push(value);
                } else {
                  pushValues[pushKey] = [pushValues[pushKey], value];
                }
                if (pushKey.indexOf("[]") === -1) {
                  value = pushValues[pushKey];
                }
                while (nameKeys.length > 0) {
                  var k = nameKeys.pop();
                  if (k === "" && !Array.isArray(value)) {
                    value = build([], pushes[pushKey]++, value);
                  } else if (settings.regExp.fixed.test(k)) {
                    value = build([], k, value);
                  } else if (settings.regExp.named.test(k)) {
                    value = build({}, k, value);
                  }
                }
                formData = $.extend(true, formData, value);
              });
            }
            if (hasOtherData) {
              module.debug("Extending existing data with form data", data2, formData);
              if (useFormDataApi) {
                $.each(Object.keys(data2), function(i, el) {
                  formData.append(el, data2[el]);
                });
                data2 = formData;
              } else {
                data2 = $.extend(true, {}, data2, formData);
              }
            } else {
              module.debug("Adding form data", formData);
              data2 = formData;
            }
            return data2;
          }
        },
        send: {
          request: function() {
            module.set.loading();
            module.request = module.create.request();
            if (module.is.mocked()) {
              module.mockedXHR = module.create.mockedXHR();
            } else {
              module.xhr = module.create.xhr();
            }
            settings.onRequest.call(context, module.request, module.xhr);
          }
        },
        event: {
          trigger: function(event2) {
            module.query();
            if (event2.type === "submit" || event2.type === "click") {
              event2.preventDefault();
            }
          },
          xhr: {
            always: function() {
            },
            done: function(response, textStatus, xhr) {
              var context2 = this, elapsedTime = Date.now() - requestStartTime, timeLeft = settings.loadingDuration - elapsedTime, translatedResponse = isFunction(settings.onResponse) ? module.is.expectingJSON() && !settings.rawResponse ? settings.onResponse.call(context2, $.extend(true, {}, response)) : settings.onResponse.call(context2, response) : false;
              timeLeft = timeLeft > 0 ? timeLeft : 0;
              if (translatedResponse) {
                module.debug("Modified API response in onResponse callback", settings.onResponse, translatedResponse, response);
                response = translatedResponse;
              }
              if (timeLeft > 0) {
                module.debug("Response completed early delaying state change by", timeLeft);
              }
              setTimeout(function() {
                if (module.is.validResponse(response)) {
                  module.request.resolveWith(context2, [response, xhr]);
                } else {
                  module.request.rejectWith(context2, [xhr, "invalid"]);
                }
              }, timeLeft);
            },
            fail: function(xhr, status, httpMessage) {
              var context2 = this, elapsedTime = Date.now() - requestStartTime, timeLeft = settings.loadingDuration - elapsedTime;
              timeLeft = timeLeft > 0 ? timeLeft : 0;
              if (timeLeft > 0) {
                module.debug("Response completed early delaying state change by", timeLeft);
              }
              setTimeout(function() {
                if (module.is.abortedRequest(xhr)) {
                  module.request.rejectWith(context2, [xhr, "aborted", httpMessage]);
                } else {
                  module.request.rejectWith(context2, [xhr, "error", status, httpMessage]);
                }
              }, timeLeft);
            }
          },
          request: {
            done: function(response, xhr) {
              module.debug("Successful API Response", response);
              if (settings.cache === "local" && url) {
                module.write.cachedResponse(url, response);
                module.debug("Saving server response locally", module.cache);
              }
              settings.onSuccess.call(context, response, $module, xhr);
            },
            complete: function(firstParameter, secondParameter) {
              var xhr, response;
              if (module.was.successful()) {
                response = firstParameter;
                xhr = secondParameter;
              } else {
                xhr = firstParameter;
                response = module.get.responseFromXHR(xhr);
              }
              module.remove.loading();
              settings.onComplete.call(context, response, $module, xhr);
            },
            fail: function(xhr, status, httpMessage) {
              var response = module.get.responseFromXHR(xhr), errorMessage = module.get.errorFromRequest(response, status, httpMessage);
              if (status === "aborted") {
                module.debug("XHR Aborted (Most likely caused by page navigation or CORS Policy)", status, httpMessage);
                settings.onAbort.call(context, status, $module, xhr);
                return true;
              }
              if (status === "invalid") {
                module.debug("JSON did not pass success test. A server-side error has most likely occurred", response);
              } else if (status === "error") {
                if (xhr !== void 0) {
                  module.debug("XHR produced a server error", status, httpMessage);
                  if ((xhr.status < 200 || xhr.status >= 300) && httpMessage !== void 0 && httpMessage !== "") {
                    module.error(error.statusMessage + httpMessage, ajaxSettings.url);
                  }
                  settings.onError.call(context, errorMessage, $module, xhr);
                }
              }
              if (settings.errorDuration && status !== "aborted") {
                module.debug("Adding error state");
                module.set.error();
                if (module.should.removeError()) {
                  setTimeout(module.remove.error, settings.errorDuration);
                }
              }
              module.debug("API Request failed", errorMessage, xhr);
              settings.onFailure.call(context, response, $module, xhr);
            }
          }
        },
        create: {
          request: function() {
            return $.Deferred().always(module.event.request.complete).done(module.event.request.done).fail(module.event.request.fail);
          },
          mockedXHR: function() {
            var textStatus = false, status = false, httpMessage = false, responder = settings.mockResponse || settings.response, asyncResponder = settings.mockResponseAsync || settings.responseAsync, asyncCallback, response, mockedXHR;
            mockedXHR = $.Deferred().always(module.event.xhr.complete).done(module.event.xhr.done).fail(module.event.xhr.fail);
            if (responder) {
              if (isFunction(responder)) {
                module.debug("Using specified synchronous callback", responder);
                response = responder.call(context, requestSettings);
              } else {
                module.debug("Using settings specified response", responder);
                response = responder;
              }
              mockedXHR.resolveWith(context, [response, textStatus, { responseText: response }]);
            } else if (isFunction(asyncResponder)) {
              asyncCallback = function(response2) {
                module.debug("Async callback returned response", response2);
                if (response2) {
                  mockedXHR.resolveWith(context, [response2, textStatus, { responseText: response2 }]);
                } else {
                  mockedXHR.rejectWith(context, [{ responseText: response2 }, status, httpMessage]);
                }
              };
              module.debug("Using specified async response callback", asyncResponder);
              asyncResponder.call(context, requestSettings, asyncCallback);
            }
            return mockedXHR;
          },
          xhr: function() {
            var xhr;
            xhr = $.ajax(ajaxSettings).always(module.event.xhr.always).done(module.event.xhr.done).fail(module.event.xhr.fail);
            module.verbose("Created server request", xhr, ajaxSettings);
            return xhr;
          }
        },
        set: {
          error: function() {
            module.verbose("Adding error state to element", $context);
            $context.addClass(className.error);
          },
          loading: function() {
            module.verbose("Adding loading state to element", $context);
            $context.addClass(className.loading);
            requestStartTime = Date.now();
          }
        },
        remove: {
          error: function() {
            module.verbose("Removing error state from element", $context);
            $context.removeClass(className.error);
          },
          loading: function() {
            module.verbose("Removing loading state from element", $context);
            $context.removeClass(className.loading);
          }
        },
        get: {
          normalizedData: function() {
            return typeof settings.data === "string" ? settings.data : JSON.stringify(settings.data, Object.keys(settings.data).sort());
          },
          responseFromXHR: function(xhr) {
            return $.isPlainObject(xhr) ? module.is.expectingJSON() ? module.decode.json(xhr.responseText) : xhr.responseText : false;
          },
          errorFromRequest: function(response, status, httpMessage) {
            return $.isPlainObject(response) && response.error !== void 0 ? response.error : settings.error[status] !== void 0 ? settings.error[status] : httpMessage;
          },
          request: function() {
            return module.request || false;
          },
          xhr: function() {
            return module.xhr || false;
          },
          settings: function() {
            var runSettings;
            runSettings = settings.beforeSend.call($module, settings);
            if (runSettings) {
              if (runSettings.success !== void 0) {
                module.debug("Legacy success callback detected", runSettings);
                module.error(error.legacyParameters, runSettings.success);
                runSettings.onSuccess = runSettings.success;
              }
              if (runSettings.failure !== void 0) {
                module.debug("Legacy failure callback detected", runSettings);
                module.error(error.legacyParameters, runSettings.failure);
                runSettings.onFailure = runSettings.failure;
              }
              if (runSettings.complete !== void 0) {
                module.debug("Legacy complete callback detected", runSettings);
                module.error(error.legacyParameters, runSettings.complete);
                runSettings.onComplete = runSettings.complete;
              }
            }
            if (runSettings === void 0) {
              module.error(error.noReturnedValue);
            }
            if (runSettings === false) {
              return runSettings;
            }
            return runSettings !== void 0 ? $.extend(true, {}, runSettings) : $.extend(true, {}, settings);
          },
          urlEncodedValue: function(value) {
            var decodedValue = window2.decodeURIComponent(value), encodedValue = window2.encodeURIComponent(value), alreadyEncoded = decodedValue !== value;
            if (alreadyEncoded) {
              module.debug("URL value is already encoded, avoiding double encoding", value);
              return value;
            }
            module.verbose("Encoding value using encodeURIComponent", value, encodedValue);
            return encodedValue;
          },
          defaultData: function() {
            var data2 = {};
            if (!isWindow(element2)) {
              if (module.is.input()) {
                data2.value = $module.val();
              } else if (!module.is.form()) {
                data2.text = $module.text();
              }
            }
            return data2;
          },
          event: function() {
            if (isWindow(element2) || settings.on === "now") {
              module.debug("API called without element, no events attached");
              return false;
            }
            if (settings.on === "auto") {
              if ($module.is("input")) {
                return element2.oninput !== void 0 ? "input" : element2.onpropertychange !== void 0 ? "propertychange" : "keyup";
              }
              if ($module.is("form")) {
                return "submit";
              }
              return "click";
            }
            return settings.on;
          },
          templatedURL: function(action) {
            action = action || settings.action || $module.data(metadata.action) || false;
            url = settings.url || $module.data(metadata.url) || false;
            if (url) {
              module.debug("Using specified url", url);
              return url;
            }
            if (action) {
              module.debug("Looking up url for action", action, settings.api);
              if (settings.api[action] === void 0 && !module.is.mocked()) {
                module.error(error.missingAction, settings.action, settings.api);
                return;
              }
              url = settings.api[action];
            } else if (module.is.form()) {
              url = $module.attr("action") || $context.attr("action") || false;
              module.debug("No url or action specified, defaulting to form action", url);
            }
            return url;
          }
        },
        abort: function() {
          var xhr = module.get.xhr();
          if (xhr && xhr.state() !== "resolved") {
            module.debug("Cancelling API request");
            xhr.abort();
          }
        },
        // reset state
        reset: function() {
          module.remove.error();
          module.remove.loading();
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                // 'Element'        : element,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data2) {
              totalTime += data2["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data2) {
                  console.log(data2.Name + ": " + data2["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context2) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context2 = context2 || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context2, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.api = $.fn.api;
  $.api.settings = {
    name: "API",
    namespace: "api",
    debug: false,
    verbose: false,
    performance: true,
    // object containing all templates endpoints
    api: {},
    // whether to cache responses
    cache: true,
    // whether new requests should abort previous requests
    interruptRequests: true,
    // event binding
    on: "auto",
    // context for applying state classes
    stateContext: false,
    // duration for loading state
    loadingDuration: 0,
    // whether to hide errors after a period of time
    hideError: "auto",
    // duration for error state
    errorDuration: 2e3,
    // whether parameters should be encoded with encodeURIComponent
    encodeParameters: true,
    // API action to use
    action: false,
    // templated URL to use
    url: false,
    // base URL to apply to all endpoints
    base: "",
    // data that will
    urlData: {},
    // whether to add default data to url data
    defaultData: true,
    // whether to serialize closest form
    // use true to convert complex named keys like a[b][1][c][] into a nested object
    // use 'formdata' for formdata web api
    serializeForm: false,
    // how long to wait before request should occur
    throttle: 0,
    // whether to throttle first request or only repeated
    throttleFirstRequest: true,
    // standard ajax settings
    method: "get",
    data: {},
    dataType: "json",
    // mock response
    mockResponse: false,
    mockResponseAsync: false,
    // aliases for mock
    response: false,
    responseAsync: false,
    // whether onResponse should work with response value without force converting into an object
    rawResponse: true,
    // callbacks before request
    beforeSend: function(settings) {
      return settings;
    },
    beforeXHR: function(xhr) {
    },
    onRequest: function(promise, xhr) {
    },
    // after request
    onResponse: false,
    // function(response) { },
    // response was successful, if JSON passed validation
    onSuccess: function(response, $module) {
    },
    // request finished without aborting
    onComplete: function(response, $module) {
    },
    // failed JSON success test
    onFailure: function(response, $module) {
    },
    // server error
    onError: function(errorMessage, $module) {
    },
    // request aborted
    onAbort: function(errorMessage, $module) {
    },
    successTest: false,
    // errors
    error: {
      beforeSend: "The before send function has aborted the request",
      error: "There was an error with your request",
      exitConditions: "API Request Aborted. Exit conditions met",
      JSONParse: "JSON could not be parsed during error handling",
      legacyParameters: "You are using legacy API success callback names",
      method: "The method you called is not defined",
      missingAction: "API action used but no url was defined",
      missingURL: "No URL specified for api event",
      noReturnedValue: "The beforeSend callback must return a settings object, beforeSend ignored.",
      noStorage: "Caching responses locally requires session storage",
      parseError: "There was an error parsing your request",
      requiredParameter: "Missing a required URL parameter: ",
      statusMessage: "Server gave an error: ",
      timeout: "Your request timed out"
    },
    regExp: {
      required: /{\$*[\da-z]+}/gi,
      optional: /{\/\$*[\da-z]+}/gi,
      validate: /^[_a-z][\w-]*(?:\[[\w-]*])*$/i,
      key: /[\w-]+|(?=\[])/gi,
      push: /^$/,
      fixed: /^\d+$/,
      named: /^[\w-]+$/i
    },
    className: {
      loading: "loading",
      error: "error"
    },
    selector: {
      disabled: ".disabled",
      form: "form"
    },
    metadata: {
      action: "action",
      url: "url"
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.state = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.state.settings, parameters) : $.extend({}, $.fn.state.settings), error = settings.error, metadata = settings.metadata, className = settings.className, namespace = settings.namespace, states = settings.states, text = settings.text, eventNamespace = "." + namespace, moduleNamespace = namespace + "-module", $module = $(this), element2 = this, instance68 = $module.data(moduleNamespace), module;
      module = {
        initialize: function() {
          module.verbose("Initializing module");
          if (settings.automatic) {
            module.add.defaults();
          }
          if (settings.context && moduleSelector !== "") {
            ([window2, document2].indexOf(settings.context) < 0 ? $(document2).find(settings.context) : $(settings.context)).on(moduleSelector, "mouseenter" + eventNamespace, module.change.text).on(moduleSelector, "mouseleave" + eventNamespace, module.reset.text).on(moduleSelector, "click" + eventNamespace, module.toggle.state);
          } else {
            $module.on("mouseenter" + eventNamespace, module.change.text).on("mouseleave" + eventNamespace, module.reset.text).on("click" + eventNamespace, module.toggle.state);
          }
          module.instantiate();
        },
        instantiate: function() {
          module.verbose("Storing instance of module", module);
          instance68 = module;
          $module.data(moduleNamespace, module);
        },
        destroy: function() {
          module.verbose("Destroying previous module", instance68);
          $module.off(eventNamespace).removeData(moduleNamespace);
        },
        refresh: function() {
          module.verbose("Refreshing selector cache");
          $module = $(element2);
        },
        add: {
          defaults: function() {
            var userStates = parameters && $.isPlainObject(parameters.states) ? parameters.states : {};
            $.each(settings.defaults, function(type, typeStates) {
              if (module.is[type] !== void 0 && module.is[type]()) {
                module.verbose("Adding default states", type, element2);
                $.extend(settings.states, typeStates, userStates);
              }
            });
          }
        },
        is: {
          active: function() {
            return $module.hasClass(className.active);
          },
          loading: function() {
            return $module.hasClass(className.loading);
          },
          inactive: function() {
            return !$module.hasClass(className.active);
          },
          state: function(state) {
            if (className[state] === void 0) {
              return false;
            }
            return $module.hasClass(className[state]);
          },
          enabled: function() {
            return !$module.is(settings.filter.active);
          },
          disabled: function() {
            return $module.is(settings.filter.active);
          },
          textEnabled: function() {
            return !$module.is(settings.filter.text);
          },
          // definitions for automatic type detection
          button: function() {
            return $module.is(".button:not(a, .submit)");
          },
          input: function() {
            return $module.is("input");
          },
          progress: function() {
            return $module.is(".ui.progress");
          }
        },
        allow: function(state) {
          module.debug("Now allowing state", state);
          states[state] = true;
        },
        disallow: function(state) {
          module.debug("No longer allowing", state);
          states[state] = false;
        },
        allows: function(state) {
          return states[state] || false;
        },
        enable: function() {
          $module.removeClass(className.disabled);
        },
        disable: function() {
          $module.addClass(className.disabled);
        },
        setState: function(state) {
          if (module.allows(state)) {
            $module.addClass(className[state]);
          }
        },
        removeState: function(state) {
          if (module.allows(state)) {
            $module.removeClass(className[state]);
          }
        },
        toggle: {
          state: function() {
            var apiRequest, requestCancelled;
            if (module.allows("active") && module.is.enabled()) {
              module.refresh();
              if ($.fn.api !== void 0) {
                apiRequest = $module.api("get request");
                requestCancelled = $module.api("was cancelled");
                if (requestCancelled) {
                  module.debug("API Request cancelled by beforesend");
                  settings.activateTest = function() {
                    return false;
                  };
                  settings.deactivateTest = function() {
                    return false;
                  };
                } else if (apiRequest) {
                  module.listenTo(apiRequest);
                  return;
                }
              }
              module.change.state();
            }
          }
        },
        listenTo: function(apiRequest) {
          module.debug("API request detected, waiting for state signal", apiRequest);
          if (apiRequest) {
            if (text.loading) {
              module.update.text(text.loading);
            }
            $.when(apiRequest).then(function() {
              if (apiRequest.state() === "resolved") {
                module.debug("API request succeeded");
                settings.activateTest = function() {
                  return true;
                };
                settings.deactivateTest = function() {
                  return true;
                };
              } else {
                module.debug("API request failed");
                settings.activateTest = function() {
                  return false;
                };
                settings.deactivateTest = function() {
                  return false;
                };
              }
              module.change.state();
            });
          }
        },
        // checks whether active/inactive state can be given
        change: {
          state: function() {
            module.debug("Determining state change direction");
            if (module.is.inactive()) {
              module.activate();
            } else {
              module.deactivate();
            }
            if (settings.sync) {
              module.sync();
            }
            settings.onChange.call(element2);
          },
          text: function() {
            if (module.is.textEnabled()) {
              if (module.is.disabled()) {
                module.verbose("Changing text to disabled text", text.hover);
                module.update.text(text.disabled);
              } else if (module.is.active()) {
                if (text.hover) {
                  module.verbose("Changing text to hover text", text.hover);
                  module.update.text(text.hover);
                } else if (text.deactivate) {
                  module.verbose("Changing text to deactivating text", text.deactivate);
                  module.update.text(text.deactivate);
                }
              } else {
                if (text.hover) {
                  module.verbose("Changing text to hover text", text.hover);
                  module.update.text(text.hover);
                } else if (text.activate) {
                  module.verbose("Changing text to activating text", text.activate);
                  module.update.text(text.activate);
                }
              }
            }
          }
        },
        activate: function() {
          if (settings.activateTest.call(element2)) {
            module.debug("Setting state to active");
            $module.addClass(className.active);
            module.update.text(text.active);
            settings.onActivate.call(element2);
          }
        },
        deactivate: function() {
          if (settings.deactivateTest.call(element2)) {
            module.debug("Setting state to inactive");
            $module.removeClass(className.active);
            module.update.text(text.inactive);
            settings.onDeactivate.call(element2);
          }
        },
        sync: function() {
          module.verbose("Syncing other buttons to current state");
          if (module.is.active()) {
            $allModules.not($module).state("activate");
          } else {
            $allModules.not($module).state("deactivate");
          }
        },
        get: {
          text: function() {
            return settings.selector.text ? $module.find(settings.selector.text).text() : $module.html();
          },
          textFor: function(state) {
            return text[state] || false;
          }
        },
        flash: {
          text: function(text2, duration, callback) {
            var previousText = module.get.text();
            module.debug("Flashing text message", text2, duration);
            text2 = text2 || settings.text.flash;
            duration = duration || settings.flashDuration;
            callback = callback || function() {
            };
            module.update.text(text2);
            setTimeout(function() {
              module.update.text(previousText);
              callback.call(element2);
            }, duration);
          }
        },
        reset: {
          // on mouseout sets text to previous value
          text: function() {
            var activeText = text.active || $module.data(metadata.storedText), inactiveText = text.inactive || $module.data(metadata.storedText);
            if (module.is.textEnabled()) {
              if (module.is.active() && activeText) {
                module.verbose("Resetting active text", activeText);
                module.update.text(activeText);
              } else if (inactiveText) {
                module.verbose("Resetting inactive text", activeText);
                module.update.text(inactiveText);
              }
            }
          }
        },
        update: {
          text: function(text2) {
            var currentText = module.get.text();
            if (text2 && text2 !== currentText) {
              module.debug("Updating text", text2);
              if (settings.selector.text) {
                $module.data(metadata.storedText, text2).find(settings.selector.text).text(text2);
              } else {
                $module.data(metadata.storedText, text2).html(text2);
              }
            } else {
              module.debug("Text is already set, ignoring update", text2);
            }
          }
        },
        setting: function(name, value) {
          module.debug("Changing setting", name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            if ($.isPlainObject(settings[name])) {
              $.extend(true, settings[name], value);
            } else {
              settings[name] = value;
            }
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.state.settings = {
    // module info
    name: "State",
    // debug output
    debug: false,
    // verbose debug output
    verbose: false,
    // namespace for events
    namespace: "state",
    // debug data includes performance
    performance: true,
    // callback occurs on state change
    onActivate: function() {
    },
    onDeactivate: function() {
    },
    onChange: function() {
    },
    // state test functions
    activateTest: function() {
      return true;
    },
    deactivateTest: function() {
      return true;
    },
    // whether to automatically map default states
    automatic: true,
    // activate / deactivate changes all elements instantiated at same time
    sync: false,
    // default flash text duration, used for temporarily changing text of an element
    flashDuration: 1e3,
    // selector filter
    filter: {
      text: ".loading, .disabled",
      active: ".disabled"
    },
    context: false,
    // error
    error: {
      method: "The method you called is not defined."
    },
    // metadata
    metadata: {
      promise: "promise",
      storedText: "stored-text"
    },
    // change class on state
    className: {
      active: "active",
      disabled: "disabled",
      error: "error",
      loading: "loading",
      success: "success",
      warning: "warning"
    },
    selector: {
      // selector for text node
      text: false
    },
    defaults: {
      input: {
        disabled: true,
        loading: true,
        active: true
      },
      button: {
        disabled: true,
        loading: true,
        active: true
      },
      progress: {
        active: true,
        success: true,
        warning: true,
        error: true
      }
    },
    states: {
      active: true,
      disabled: true,
      error: true,
      loading: true,
      success: true,
      warning: true
    },
    text: {
      disabled: false,
      flash: false,
      hover: false,
      active: false,
      inactive: false,
      activate: false,
      deactivate: false
    }
  };
})(jQuery, window, document);
(function($, window2, document2) {
  "use strict";
  function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  }
  window2 = window2 !== void 0 && window2.Math === Math ? window2 : globalThis;
  $.fn.visibility = function(parameters) {
    var $allModules = $(this), moduleSelector = $allModules.selector || "", time = Date.now(), performance = [], query = arguments[0], methodInvoked = typeof query === "string", queryArguments = [].slice.call(arguments, 1), returnedValue, moduleCount = $allModules.length, loadedCount = 0;
    $allModules.each(function() {
      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.visibility.settings, parameters) : $.extend({}, $.fn.visibility.settings), className = settings.className, namespace = settings.namespace, error = settings.error, metadata = settings.metadata, eventNamespace = "." + namespace, moduleNamespace = "module-" + namespace, $window = $(window2), $module = $(this), $context = [window2, document2].indexOf(settings.context) < 0 ? $(document2).find(settings.context) : $(settings.context), $placeholder, instance68 = $module.data(moduleNamespace), element2 = this, disabled = false, contextObserver, observer, module;
      module = {
        initialize: function() {
          module.debug("Initializing", settings);
          module.setup.cache();
          if (module.should.trackChanges()) {
            if (settings.type === "image") {
              module.setup.image();
            }
            if (settings.type === "fixed") {
              module.setup.fixed();
            }
            if (settings.observeChanges) {
              module.observeChanges();
            }
            module.bind.events();
          }
          module.save.position();
          if (!module.is.visible()) {
            module.error(error.visible, $module);
          }
          if (settings.initialCheck) {
            module.checkVisibility();
          }
          module.instantiate();
        },
        instantiate: function() {
          module.debug("Storing instance", module);
          $module.data(moduleNamespace, module);
          instance68 = module;
        },
        destroy: function() {
          module.verbose("Destroying previous module");
          if (observer) {
            observer.disconnect();
          }
          if (contextObserver) {
            contextObserver.disconnect();
          }
          $window.off("load" + eventNamespace, module.event.load).off("resize" + eventNamespace, module.event.resize);
          $context.off("scroll" + eventNamespace, module.event.scroll).off("scrollchange" + eventNamespace, module.event.scrollchange);
          if (settings.type === "fixed") {
            module.resetFixed();
            module.remove.placeholder();
          }
          $module.off(eventNamespace).removeData(moduleNamespace);
        },
        observeChanges: function() {
          if ("MutationObserver" in window2) {
            contextObserver = new MutationObserver(module.event.contextChanged);
            observer = new MutationObserver(module.event.changed);
            contextObserver.observe(document2, {
              childList: true,
              subtree: true
            });
            observer.observe(element2, {
              childList: true,
              subtree: true
            });
            module.debug("Setting up mutation observer", observer);
          }
        },
        bind: {
          events: function() {
            module.verbose("Binding visibility events to scroll and resize");
            if (settings.refreshOnLoad) {
              $window.on("load" + eventNamespace, module.event.load);
            }
            $window.on("resize" + eventNamespace, module.event.resize);
            $context.off("scroll" + eventNamespace).on("scroll" + eventNamespace, module.event.scroll).on("scrollchange" + eventNamespace, module.event.scrollchange);
          }
        },
        event: {
          changed: function(mutations) {
            module.verbose("DOM tree modified, updating visibility calculations");
            module.timer = setTimeout(function() {
              module.verbose("DOM tree modified, updating sticky menu");
              module.refresh();
            }, 100);
          },
          contextChanged: function(mutations) {
            [].forEach.call(mutations, function(mutation) {
              if (mutation.removedNodes) {
                [].forEach.call(mutation.removedNodes, function(node) {
                  if (node === element2 || $(node).find(element2).length > 0) {
                    module.debug("Element removed from DOM, tearing down events");
                    module.destroy();
                  }
                });
              }
            });
          },
          resize: function() {
            module.debug("Window resized");
            if (settings.refreshOnResize) {
              requestAnimationFrame(module.refresh);
            }
          },
          load: function() {
            module.debug("Page finished loading");
            requestAnimationFrame(module.refresh);
          },
          // publishes scrollchange event on one scroll
          scroll: function() {
            if (settings.throttle) {
              clearTimeout(module.timer);
              module.timer = setTimeout(function() {
                $context.triggerHandler("scrollchange" + eventNamespace, [$context.scrollTop()]);
              }, settings.throttle);
            } else {
              requestAnimationFrame(function() {
                $context.triggerHandler("scrollchange" + eventNamespace, [$context.scrollTop()]);
              });
            }
          },
          // subscribes to scrollchange
          scrollchange: function(event2, scrollPosition) {
            module.checkVisibility(scrollPosition);
          }
        },
        precache: function(images, callback) {
          if (!Array.isArray(images)) {
            images = [images];
          }
          var imagesLength = images.length, loadedCounter = 0, cache = [], cacheImage = document2.createElement("img"), handleLoad = function() {
            loadedCounter++;
            if (loadedCounter >= images.length) {
              if (isFunction(callback)) {
                callback();
              }
            }
          };
          while (imagesLength--) {
            cacheImage = document2.createElement("img");
            cacheImage.addEventListener("load", handleLoad);
            cacheImage.addEventListener("error", handleLoad);
            cacheImage.src = images[imagesLength];
            cache.push(cacheImage);
          }
        },
        enableCallbacks: function() {
          module.debug("Allowing callbacks to occur");
          disabled = false;
        },
        disableCallbacks: function() {
          module.debug("Disabling all callbacks temporarily");
          disabled = true;
        },
        should: {
          trackChanges: function() {
            if (methodInvoked) {
              module.debug("One time query, no need to bind events");
              return false;
            }
            module.debug("Callbacks being attached");
            return true;
          }
        },
        setup: {
          cache: function() {
            module.cache = {
              occurred: {},
              screen: {},
              element: {}
            };
          },
          image: function() {
            var src = $module.data(metadata.src);
            if (src) {
              module.verbose("Lazy loading image", src);
              settings.once = true;
              settings.observeChanges = false;
              settings.onOnScreen = function() {
                module.debug("Image on screen", element2);
                module.precache(src, function() {
                  module.set.image(src, function() {
                    loadedCount++;
                    if (loadedCount === moduleCount) {
                      settings.onAllLoaded.call(this);
                    }
                    settings.onLoad.call(this);
                  });
                });
              };
            }
          },
          fixed: function() {
            module.debug("Setting up fixed");
            settings.once = false;
            settings.observeChanges = false;
            settings.initialCheck = true;
            settings.refreshOnLoad = true;
            if (!parameters.transition) {
              settings.transition = false;
            }
            module.create.placeholder();
            module.debug("Added placeholder", $placeholder);
            settings.onTopPassed = function() {
              module.debug("Element passed, adding fixed position", $module);
              module.show.placeholder();
              module.set.fixed();
              if (settings.transition) {
                if ($.fn.transition !== void 0) {
                  $module.transition(settings.transition, settings.duration);
                }
              }
            };
            settings.onTopPassedReverse = function() {
              module.debug("Element returned to position, removing fixed", $module);
              module.hide.placeholder();
              module.remove.fixed();
            };
          }
        },
        create: {
          placeholder: function() {
            module.verbose("Creating fixed position placeholder");
            $placeholder = $module.clone(false).css("display", "none").addClass(className.placeholder).insertAfter($module);
          }
        },
        show: {
          placeholder: function() {
            module.verbose("Showing placeholder");
            $placeholder.css("display", "block").css("visibility", "hidden");
          }
        },
        hide: {
          placeholder: function() {
            module.verbose("Hiding placeholder");
            $placeholder.css("display", "none").css("visibility", "");
          }
        },
        set: {
          fixed: function() {
            module.verbose("Setting element to fixed position");
            $module.addClass(className.fixed).css({
              position: "fixed",
              top: settings.offset + "px",
              left: "auto",
              zIndex: settings.zIndex
            });
            settings.onFixed.call(element2);
          },
          image: function(src, callback) {
            $module.attr("src", src);
            if (settings.transition) {
              if ($.fn.transition !== void 0) {
                if ($module.hasClass(className.visible)) {
                  module.debug("Transition already occurred on this image, skipping animation");
                  return;
                }
                $module.transition(settings.transition, settings.duration, callback);
              } else {
                $module.fadeIn(settings.duration, callback);
              }
            } else {
              $module.show();
            }
          }
        },
        is: {
          onScreen: function() {
            var calculations = module.get.elementCalculations();
            return calculations.onScreen;
          },
          offScreen: function() {
            var calculations = module.get.elementCalculations();
            return calculations.offScreen;
          },
          visible: function() {
            if (module.cache && module.cache.element) {
              return !(module.cache.element.width === 0 && module.cache.element.offset.top === 0);
            }
            return false;
          },
          verticallyScrollableContext: function() {
            var overflowY = $context[0] !== window2 ? $context.css("overflow-y") : false;
            return overflowY === "auto" || overflowY === "scroll";
          },
          horizontallyScrollableContext: function() {
            var overflowX = $context[0] !== window2 ? $context.css("overflow-x") : false;
            return overflowX === "auto" || overflowX === "scroll";
          }
        },
        refresh: function() {
          module.debug("Refreshing constants (width/height)");
          if (settings.type === "fixed") {
            module.resetFixed();
          }
          module.reset();
          module.save.position();
          if (settings.checkOnRefresh) {
            module.checkVisibility();
          }
          settings.onRefresh.call(element2);
        },
        resetFixed: function() {
          module.remove.fixed();
          module.remove.occurred();
        },
        reset: function() {
          module.verbose("Resetting all cached values");
          if ($.isPlainObject(module.cache)) {
            module.cache.screen = {};
            module.cache.element = {};
          }
        },
        checkVisibility: function(scroll) {
          module.verbose("Checking visibility of element", module.cache.element);
          if (!disabled && module.is.visible()) {
            module.save.scroll(scroll);
            module.save.calculations();
            module.passed();
            module.passingReverse();
            module.topVisibleReverse();
            module.bottomVisibleReverse();
            module.topPassedReverse();
            module.bottomPassedReverse();
            module.onScreen();
            module.offScreen();
            module.passing();
            module.topVisible();
            module.bottomVisible();
            module.topPassed();
            module.bottomPassed();
            if (settings.onUpdate) {
              settings.onUpdate.call(element2, module.get.elementCalculations());
            }
          }
        },
        passed: function(amount, newCallback) {
          var calculations = module.get.elementCalculations();
          if (amount && newCallback) {
            settings.onPassed[amount] = newCallback;
          } else if (amount !== void 0) {
            return module.get.pixelsPassed(amount) > calculations.pixelsPassed;
          } else if (calculations.passing) {
            $.each(settings.onPassed, function(amount2, callback) {
              if (calculations.bottomVisible || calculations.pixelsPassed > module.get.pixelsPassed(amount2)) {
                module.execute(callback, amount2);
              } else if (!settings.once) {
                module.remove.occurred(callback);
              }
            });
          }
        },
        onScreen: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onOnScreen, callbackName = "onScreen";
          if (newCallback) {
            module.debug("Adding callback for onScreen", newCallback);
            settings.onOnScreen = newCallback;
          }
          if (calculations.onScreen) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback !== void 0) {
            return calculations.onOnScreen;
          }
        },
        offScreen: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onOffScreen, callbackName = "offScreen";
          if (newCallback) {
            module.debug("Adding callback for offScreen", newCallback);
            settings.onOffScreen = newCallback;
          }
          if (calculations.offScreen) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback !== void 0) {
            return calculations.onOffScreen;
          }
        },
        passing: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onPassing, callbackName = "passing";
          if (newCallback) {
            module.debug("Adding callback for passing", newCallback);
            settings.onPassing = newCallback;
          }
          if (calculations.passing) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback !== void 0) {
            return calculations.passing;
          }
        },
        topVisible: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onTopVisible, callbackName = "topVisible";
          if (newCallback) {
            module.debug("Adding callback for top visible", newCallback);
            settings.onTopVisible = newCallback;
          }
          if (calculations.topVisible) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return calculations.topVisible;
          }
        },
        bottomVisible: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onBottomVisible, callbackName = "bottomVisible";
          if (newCallback) {
            module.debug("Adding callback for bottom visible", newCallback);
            settings.onBottomVisible = newCallback;
          }
          if (calculations.bottomVisible) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return calculations.bottomVisible;
          }
        },
        topPassed: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onTopPassed, callbackName = "topPassed";
          if (newCallback) {
            module.debug("Adding callback for top passed", newCallback);
            settings.onTopPassed = newCallback;
          }
          if (calculations.topPassed) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return calculations.topPassed;
          }
        },
        bottomPassed: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onBottomPassed, callbackName = "bottomPassed";
          if (newCallback) {
            module.debug("Adding callback for bottom passed", newCallback);
            settings.onBottomPassed = newCallback;
          }
          if (calculations.bottomPassed) {
            module.execute(callback, callbackName);
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return calculations.bottomPassed;
          }
        },
        passingReverse: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onPassingReverse, callbackName = "passingReverse";
          if (newCallback) {
            module.debug("Adding callback for passing reverse", newCallback);
            settings.onPassingReverse = newCallback;
          }
          if (!calculations.passing) {
            if (module.get.occurred("passing")) {
              module.execute(callback, callbackName);
            }
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback !== void 0) {
            return !calculations.passing;
          }
        },
        topVisibleReverse: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onTopVisibleReverse, callbackName = "topVisibleReverse";
          if (newCallback) {
            module.debug("Adding callback for top visible reverse", newCallback);
            settings.onTopVisibleReverse = newCallback;
          }
          if (!calculations.topVisible) {
            if (module.get.occurred("topVisible")) {
              module.execute(callback, callbackName);
            }
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return !calculations.topVisible;
          }
        },
        bottomVisibleReverse: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onBottomVisibleReverse, callbackName = "bottomVisibleReverse";
          if (newCallback) {
            module.debug("Adding callback for bottom visible reverse", newCallback);
            settings.onBottomVisibleReverse = newCallback;
          }
          if (!calculations.bottomVisible) {
            if (module.get.occurred("bottomVisible")) {
              module.execute(callback, callbackName);
            }
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return !calculations.bottomVisible;
          }
        },
        topPassedReverse: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onTopPassedReverse, callbackName = "topPassedReverse";
          if (newCallback) {
            module.debug("Adding callback for top passed reverse", newCallback);
            settings.onTopPassedReverse = newCallback;
          }
          if (!calculations.topPassed) {
            if (module.get.occurred("topPassed")) {
              module.execute(callback, callbackName);
            }
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return !calculations.onTopPassed;
          }
        },
        bottomPassedReverse: function(newCallback) {
          var calculations = module.get.elementCalculations(), callback = newCallback || settings.onBottomPassedReverse, callbackName = "bottomPassedReverse";
          if (newCallback) {
            module.debug("Adding callback for bottom passed reverse", newCallback);
            settings.onBottomPassedReverse = newCallback;
          }
          if (!calculations.bottomPassed) {
            if (module.get.occurred("bottomPassed")) {
              module.execute(callback, callbackName);
            }
          } else if (!settings.once) {
            module.remove.occurred(callbackName);
          }
          if (newCallback === void 0) {
            return !calculations.bottomPassed;
          }
        },
        execute: function(callback, callbackName) {
          var calculations = module.get.elementCalculations(), screen = module.get.screenCalculations();
          callback = callback || false;
          if (callback) {
            if (settings.continuous) {
              module.debug("Callback being called continuously", callbackName, calculations);
              callback.call(element2, calculations, screen);
            } else if (!module.get.occurred(callbackName)) {
              module.debug("Conditions met", callbackName, calculations);
              callback.call(element2, calculations, screen);
            }
          }
          module.save.occurred(callbackName);
        },
        remove: {
          fixed: function() {
            module.debug("Removing fixed position");
            $module.removeClass(className.fixed).css({
              position: "",
              top: "",
              left: "",
              zIndex: ""
            });
            settings.onUnfixed.call(element2);
          },
          placeholder: function() {
            module.debug("Removing placeholder content");
            if ($placeholder) {
              $placeholder.remove();
            }
          },
          occurred: function(callback) {
            if (callback) {
              var occurred = module.cache.occurred;
              if (occurred[callback] !== void 0 && occurred[callback] === true) {
                module.debug("Callback can now be called again", callback);
                module.cache.occurred[callback] = false;
              }
            } else {
              module.cache.occurred = {};
            }
          }
        },
        save: {
          calculations: function() {
            module.verbose("Saving all calculations necessary to determine positioning");
            module.save.direction();
            module.save.screenCalculations();
            module.save.elementCalculations();
          },
          occurred: function(callback) {
            if (callback) {
              if (module.cache.occurred[callback] === void 0 || module.cache.occurred[callback] !== true) {
                module.verbose("Saving callback occurred", callback);
                module.cache.occurred[callback] = true;
              }
            }
          },
          scroll: function(scrollPosition) {
            scrollPosition = scrollPosition + settings.offset || $context.scrollTop() + settings.offset;
            module.cache.scroll = scrollPosition;
          },
          direction: function() {
            var scroll = module.get.scroll(), lastScroll = module.get.lastScroll(), direction;
            if (scroll > lastScroll && lastScroll) {
              direction = "down";
            } else if (scroll < lastScroll && lastScroll) {
              direction = "up";
            } else {
              direction = "static";
            }
            module.cache.direction = direction;
            return module.cache.direction;
          },
          elementPosition: function() {
            var element3 = module.cache.element, screen = module.get.screenSize();
            module.verbose("Saving element position");
            element3.fits = element3.height < screen.height;
            element3.offset = $module.offset();
            element3.width = $module.outerWidth();
            element3.height = $module.outerHeight();
            if (module.is.verticallyScrollableContext()) {
              element3.offset.top += $context.scrollTop() - $context.offset().top;
            }
            if (module.is.horizontallyScrollableContext()) {
              element3.offset.left += $context.scrollLeft() - $context.offset().left;
            }
            module.cache.element = element3;
            return element3;
          },
          elementCalculations: function() {
            var screen = module.get.screenCalculations(), element3 = module.get.elementPosition();
            if (settings.includeMargin) {
              element3.margin = {};
              element3.margin.top = parseInt($module.css("margin-top"), 10);
              element3.margin.bottom = parseInt($module.css("margin-bottom"), 10);
              element3.top = element3.offset.top - element3.margin.top;
              element3.bottom = element3.offset.top + element3.height + element3.margin.bottom;
            } else {
              element3.top = element3.offset.top;
              element3.bottom = element3.offset.top + element3.height;
            }
            element3.topPassed = screen.top >= element3.top;
            element3.bottomPassed = screen.top >= element3.bottom;
            element3.topVisible = screen.bottom >= element3.top && !element3.topPassed;
            element3.bottomVisible = screen.bottom >= element3.bottom && !element3.bottomPassed;
            element3.pixelsPassed = 0;
            element3.percentagePassed = 0;
            element3.onScreen = (element3.topVisible || element3.passing) && !element3.bottomPassed;
            element3.passing = element3.topPassed && !element3.bottomPassed;
            element3.offScreen = !element3.onScreen;
            if (element3.passing) {
              element3.pixelsPassed = screen.top - element3.top;
              element3.percentagePassed = (screen.top - element3.top) / element3.height;
            }
            module.cache.element = element3;
            module.verbose("Updated element calculations", element3);
            return element3;
          },
          screenCalculations: function() {
            var scroll = module.get.scroll();
            module.save.direction();
            module.cache.screen.top = scroll;
            module.cache.screen.bottom = scroll + module.cache.screen.height;
            return module.cache.screen;
          },
          screenSize: function() {
            module.verbose("Saving window position");
            module.cache.screen = {
              height: $context.height()
            };
          },
          position: function() {
            module.save.screenSize();
            module.save.elementPosition();
          }
        },
        get: {
          pixelsPassed: function(amount) {
            var element3 = module.get.elementCalculations();
            if (amount.search("%") > -1) {
              return element3.height * (parseInt(amount, 10) / 100);
            }
            return parseInt(amount, 10);
          },
          occurred: function(callback) {
            return module.cache.occurred !== void 0 ? module.cache.occurred[callback] || false : false;
          },
          direction: function() {
            if (module.cache.direction === void 0) {
              module.save.direction();
            }
            return module.cache.direction;
          },
          elementPosition: function() {
            if (module.cache.element === void 0) {
              module.save.elementPosition();
            }
            return module.cache.element;
          },
          elementCalculations: function() {
            if (module.cache.element === void 0) {
              module.save.elementCalculations();
            }
            return module.cache.element;
          },
          screenCalculations: function() {
            if (module.cache.screen === void 0) {
              module.save.screenCalculations();
            }
            return module.cache.screen;
          },
          screenSize: function() {
            if (module.cache.screen === void 0) {
              module.save.screenSize();
            }
            return module.cache.screen;
          },
          scroll: function() {
            if (module.cache.scroll === void 0) {
              module.save.scroll();
            }
            return module.cache.scroll;
          },
          lastScroll: function() {
            if (module.cache.screen === void 0) {
              module.debug("First scroll event, no last scroll could be found");
              return false;
            }
            return module.cache.screen.top;
          }
        },
        setting: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== void 0) {
            settings[name] = value;
          } else {
            return settings[name];
          }
        },
        internal: function(name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== void 0) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function() {
          if (!settings.silent && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function() {
          if (!settings.silent && settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ":");
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function() {
          if (!settings.silent) {
            module.error = Function.prototype.bind.call(console.error, console, settings.name + ":");
            module.error.apply(console, arguments);
          }
        },
        performance: {
          log: function(message) {
            var currentTime, executionTime, previousTime;
            if (settings.performance) {
              currentTime = Date.now();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                Name: message[0],
                Arguments: [].slice.call(message, 1) || "",
                Element: element2,
                "Execution Time": executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 500);
          },
          display: function() {
            var title = settings.name + ":", totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function(index, data) {
              totalTime += data["Execution Time"];
            });
            title += " " + totalTime + "ms";
            if (moduleSelector) {
              title += " '" + moduleSelector + "'";
            }
            if (performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function(index, data) {
                  console.log(data.Name + ": " + data["Execution Time"] + "ms");
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function(query2, passedArguments, context) {
          var object = instance68, maxDepth, found, response;
          passedArguments = passedArguments || queryArguments;
          context = context || element2;
          if (typeof query2 === "string" && object !== void 0) {
            query2 = query2.split(/[ .]/);
            maxDepth = query2.length - 1;
            $.each(query2, function(depth, value) {
              var camelCaseValue = depth !== maxDepth ? value + query2[depth + 1].charAt(0).toUpperCase() + query2[depth + 1].slice(1) : query2;
              if ($.isPlainObject(object[camelCaseValue]) && depth !== maxDepth) {
                object = object[camelCaseValue];
              } else if (object[camelCaseValue] !== void 0) {
                found = object[camelCaseValue];
                return false;
              } else if ($.isPlainObject(object[value]) && depth !== maxDepth) {
                object = object[value];
              } else if (object[value] !== void 0) {
                found = object[value];
                return false;
              } else {
                module.error(error.method, query2);
                return false;
              }
            });
          }
          if (isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== void 0) {
            response = found;
          }
          if (Array.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== void 0) {
            returnedValue = [returnedValue, response];
          } else if (response !== void 0) {
            returnedValue = response;
          }
          return found;
        }
      };
      if (methodInvoked) {
        if (instance68 === void 0) {
          module.initialize();
        }
        instance68.save.scroll();
        instance68.save.calculations();
        module.invoke(query);
      } else {
        if (instance68 !== void 0) {
          instance68.invoke("destroy");
        }
        module.initialize();
      }
    });
    return returnedValue !== void 0 ? returnedValue : this;
  };
  $.fn.visibility.settings = {
    name: "Visibility",
    namespace: "visibility",
    debug: false,
    verbose: false,
    performance: true,
    // whether to use mutation observers to follow changes
    observeChanges: true,
    // check position immediately on init
    initialCheck: true,
    // whether to refresh calculations after all page images load
    refreshOnLoad: true,
    // whether to refresh calculations after page resize event
    refreshOnResize: true,
    // should call callbacks on refresh event (resize, etc)
    checkOnRefresh: true,
    // callback should only occur one time
    once: true,
    // callback should fire continuously when evaluates to true
    continuous: false,
    // offset to use with scroll top
    offset: 0,
    // whether to include margin in elements position
    includeMargin: false,
    // scroll context for visibility checks
    context: window2,
    // visibility check delay in ms (defaults to animationFrame)
    throttle: false,
    // special visibility type (image, fixed)
    type: false,
    // z-index to use with visibility 'fixed'
    zIndex: "10",
    // image only animation settings
    transition: "fade in",
    duration: 1e3,
    // array of callbacks for percentage
    onPassed: {},
    // standard callbacks
    onOnScreen: false,
    onOffScreen: false,
    onPassing: false,
    onTopVisible: false,
    onBottomVisible: false,
    onTopPassed: false,
    onBottomPassed: false,
    // reverse callbacks
    onPassingReverse: false,
    onTopVisibleReverse: false,
    onBottomVisibleReverse: false,
    onTopPassedReverse: false,
    onBottomPassedReverse: false,
    // special callbacks for image
    onLoad: function() {
    },
    onAllLoaded: function() {
    },
    // special callbacks for fixed position
    onFixed: function() {
    },
    onUnfixed: function() {
    },
    // utility callbacks
    onUpdate: false,
    // disabled by default for performance
    onRefresh: function() {
    },
    metadata: {
      src: "src"
    },
    className: {
      fixed: "fixed",
      placeholder: "constraint",
      visible: "visible"
    },
    error: {
      method: "The method you called is not defined.",
      visible: "Element is hidden, you must call refresh after element becomes visible"
    }
  };
})(jQuery, window, document);

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Dropdown.svelte
var file9 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Dropdown.svelte";
function create_fragment9(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " dropdown"
    },
    { params: (
      /*params*/
      ctx[1]
    ) },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file9, 20, 0, 774);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*setSelected*/
          ctx[2],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        9 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " dropdown")) && { class: div_class_value },
        { params: (
          /*params*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "settings", "selected"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  let { ui = false } = $$props;
  let { settings = {} } = $$props;
  let { selected = "" } = $$props;
  let params = JSON.stringify(settings);
  function setSelected(e) {
    if (e.target.attributes["data-value"]) {
      $$invalidate(4, selected = e.target.attributes["data-value"].value);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("settings" in $$new_props)
      $$invalidate(5, settings = $$new_props.settings);
    if ("selected" in $$new_props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    settings,
    selected,
    params,
    setSelected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("settings" in $$props)
      $$invalidate(5, settings = $$new_props.settings);
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("params" in $$props)
      $$invalidate(1, params = $$new_props.params);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, params, setSelected, $$restProps, selected, settings, $$scope, slots];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { ui: 0, settings: 5, selected: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment9.name
    });
  }
  get ui() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get settings() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Calendar.svelte
import "/home/roycdavies/Development/UofA/svelte-fomantic-ui/svelte-fomantic-ui-test/node_modules/fomantic-ui-css/semantic.css";
var file10 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Calendar.svelte";
function create_fragment10(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " calendar"
    },
    { params: (
      /*params*/
      ctx[1]
    ) },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file10, 20, 0, 730);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "change",
          /*setSelected*/
          ctx[2],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        9 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " calendar")) && { class: div_class_value },
        { params: (
          /*params*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "selected", "settings"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, ["default"]);
  let { ui = false } = $$props;
  let { selected = "" } = $$props;
  let { settings = {} } = $$props;
  let params = JSON.stringify(settings);
  function setSelected(e) {
    if (e.target.value) {
      $$invalidate(4, selected = e.target.value);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("selected" in $$new_props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("settings" in $$new_props)
      $$invalidate(5, settings = $$new_props.settings);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    selected,
    settings,
    params,
    setSelected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("settings" in $$props)
      $$invalidate(5, settings = $$new_props.settings);
    if ("params" in $$props)
      $$invalidate(1, params = $$new_props.params);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, params, setSelected, $$restProps, selected, settings, $$scope, slots];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { ui: 0, selected: 4, settings: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment10.name
    });
  }
  get ui() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get settings() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Dimmer.svelte
var file11 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Dimmer.svelte";
function create_fragment11(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " dimmer"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file11, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " dimmer")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dimmer", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Dimmer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dimmer",
      options,
      id: create_fragment11.name
    });
  }
  get ui() {
    throw new Error("<Dimmer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Dimmer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dimmer_default = Dimmer;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Accordion.svelte
import "/home/roycdavies/Development/UofA/svelte-fomantic-ui/svelte-fomantic-ui-test/node_modules/fomantic-ui-css/semantic.css";
var file12 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/modules/Accordion.svelte";
function create_fragment12(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " accordion"
    },
    { params: (
      /*params*/
      ctx[1]
    ) },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file12, 20, 0, 764);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*setSelected*/
          ctx[2],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        9 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " accordion")) && { class: div_class_value },
        { params: (
          /*params*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "selected", "settings"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { ui = false } = $$props;
  let { selected = "" } = $$props;
  let { settings = {} } = $$props;
  let params = JSON.stringify(settings);
  function setSelected(e) {
    if (e.target.attributes["value"]) {
      $$invalidate(4, selected = e.target.attributes["value"].value);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("selected" in $$new_props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("settings" in $$new_props)
      $$invalidate(5, settings = $$new_props.settings);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    selected,
    settings,
    params,
    setSelected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("settings" in $$props)
      $$invalidate(5, settings = $$new_props.settings);
    if ("params" in $$props)
      $$invalidate(1, params = $$new_props.params);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, params, setSelected, $$restProps, selected, settings, $$scope, slots];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { ui: 0, selected: 4, settings: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment12.name
    });
  }
  get ui() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get settings() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Col.svelte
var file13 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Col.svelte";
function create_else_block(ctx) {
  let td;
  let td_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let td_levels = [
    {
      class: td_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      set_attributes(td, td_data);
      add_location(td, file13, 16, 4, 633);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        (!current || dirty & /*ui, $$restProps*/
        5 && td_class_value !== (td_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ))) && { class: td_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let th;
  let th_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let th_levels = [
    {
      class: th_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (default_slot)
        default_slot.c();
      set_attributes(th, th_data);
      add_location(th, file13, 12, 4, 515);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (default_slot) {
        default_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [
        (!current || dirty & /*ui, $$restProps*/
        5 && th_class_value !== (th_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ))) && { class: th_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(12:0) {#if head}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*head*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "head"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table_Col", slots, ["default"]);
  let { ui = false } = $$props;
  let { head = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("head" in $$new_props)
      $$invalidate(1, head = $$new_props.head);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui, head });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("head" in $$props)
      $$invalidate(1, head = $$new_props.head);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, head, $$restProps, $$scope, slots];
}
var Table_Col = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { ui: 0, head: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table_Col",
      options,
      id: create_fragment13.name
    });
  }
  get ui() {
    throw new Error("<Table_Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Table_Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get head() {
    throw new Error("<Table_Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set head(value) {
    throw new Error("<Table_Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_Col_default = Table_Col;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Row.svelte
var file14 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Row.svelte";
function create_fragment14(ctx) {
  let tr;
  let tr_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let tr_levels = [
    {
      class: tr_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let tr_data = {};
  for (let i = 0; i < tr_levels.length; i += 1) {
    tr_data = assign(tr_data, tr_levels[i]);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      set_attributes(tr, tr_data);
      add_location(tr, file14, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tr, tr_data = get_spread_update(tr_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && tr_class_value !== (tr_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ))) && { class: tr_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table_Row", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Table_Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table_Row",
      options,
      id: create_fragment14.name
    });
  }
  get ui() {
    throw new Error("<Table_Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Table_Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_Row_default = Table_Row;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Head.svelte
var file15 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Head.svelte";
function create_fragment15(ctx) {
  let thead;
  let thead_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let thead_levels = [
    {
      class: thead_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
      set_attributes(thead, thead_data);
      add_location(thead, file15, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && thead_class_value !== (thead_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ))) && { class: thead_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(thead);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table_Head", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Table_Head = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table_Head",
      options,
      id: create_fragment15.name
    });
  }
  get ui() {
    throw new Error("<Table_Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Table_Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_Head_default = Table_Head;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Body.svelte
var file16 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table_Body.svelte";
function create_fragment16(ctx) {
  let tbody;
  let tbody_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let tbody_levels = [
    {
      class: tbody_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let tbody_data = {};
  for (let i = 0; i < tbody_levels.length; i += 1) {
    tbody_data = assign(tbody_data, tbody_levels[i]);
  }
  const block = {
    c: function create() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
      set_attributes(tbody, tbody_data);
      add_location(tbody, file16, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && tbody_class_value !== (tbody_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ))) && { class: tbody_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tbody);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table_Body", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Table_Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table_Body",
      options,
      id: create_fragment16.name
    });
  }
  get ui() {
    throw new Error("<Table_Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Table_Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_Body_default = Table_Body;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table.svelte
var file17 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Table.svelte";
function create_fragment17(ctx) {
  let table;
  let table_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let table_levels = [
    {
      class: table_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " table"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      if (default_slot)
        default_slot.c();
      set_attributes(table, table_data);
      add_location(table, file17, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && table_class_value !== (table_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " table")) && { class: table_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment17.name
    });
  }
  get ui() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Section.svelte
var file18 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Section.svelte";
function create_fragment18(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " section"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file18, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " section")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Section = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment18.name
    });
  }
  get ui() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Section_default = Section;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Row.svelte
var file19 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Row.svelte";
function create_fragment19(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " row"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file19, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " row")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment19.name
    });
  }
  get ui() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Option.svelte
var file20 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Option.svelte";
function create_fragment20(ctx) {
  let option;
  let option_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let option_levels = [
    {
      class: option_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      )
    },
    { __value: (
      /*value*/
      ctx[1]
    ) },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let option_data = {};
  for (let i = 0; i < option_levels.length; i += 1) {
    option_data = assign(option_data, option_levels[i]);
  }
  const block = {
    c: function create() {
      option = element("option");
      if (default_slot)
        default_slot.c();
      set_attributes(option, option_data);
      add_location(option, file20, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      if (default_slot) {
        default_slot.m(option, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(option, option_data = get_spread_update(option_levels, [
        (!current || dirty & /*ui, $$restProps*/
        5 && option_class_value !== (option_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ))) && { class: option_class_value },
        (!current || dirty & /*value*/
        2) && { __value: (
          /*value*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Option", slots, ["default"]);
  let { ui = false } = $$props;
  let { value = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui, value });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, value, $$restProps, $$scope, slots];
}
var Option = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { ui: 0, value: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Option",
      options,
      id: create_fragment20.name
    });
  }
  get ui() {
    throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Option_default = Option;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Message.svelte
var file21 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Message.svelte";
function create_fragment21(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " message"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file21, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " message")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Message", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Message = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Message",
      options,
      id: create_fragment21.name
    });
  }
  get ui() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Message_default = Message;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Menu.svelte
var file22 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Menu.svelte";
function create_fragment22(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " menu"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file22, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " menu")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment22.name
    });
  }
  get ui() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Grid.svelte
var file23 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Grid.svelte";
function create_fragment23(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " grid"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file23, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " grid")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment23.name
    });
  }
  get ui() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Form.svelte
var file24 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Form.svelte";
function create_fragment24(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " form"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file24, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " form")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment24.name
    });
  }
  get ui() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Fields.svelte
var file25 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Fields.svelte";
function create_fragment25(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " fields"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file25, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " fields")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fields", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Fields = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fields",
      options,
      id: create_fragment25.name
    });
  }
  get ui() {
    throw new Error("<Fields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Fields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fields_default = Fields;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Field.svelte
var file26 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Field.svelte";
function create_fragment26(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " field"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file26, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " field")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Field", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Field = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Field",
      options,
      id: create_fragment26.name
    });
  }
  get ui() {
    throw new Error("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Field_default = Field;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Column.svelte
var file27 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Column.svelte";
function create_fragment27(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " column"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file27, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " column")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment27.name
    });
  }
  get ui() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Breadcrumb.svelte
var file28 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/collections/Breadcrumb.svelte";
function create_fragment28(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " breadcrumb"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file28, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " breadcrumb")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment28.name
    });
  }
  get ui() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Textarea.svelte
var file29 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Textarea.svelte";
function create_fragment29(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      add_location(textarea, file29, 11, 0, 498);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen_dev(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & /*ui, $$restProps*/
        6 && textarea_class_value !== (textarea_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        )) && { class: textarea_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textarea", slots, []);
  let { ui = false } = $$props;
  let { value = "" } = $$props;
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui, value });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, ui, $$restProps, textarea_input_handler];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { ui: 1, value: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment29.name
    });
  }
  get ui() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Radio.svelte
var file30 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Radio.svelte";
function create_else_block2(ctx) {
  let div;
  let input;
  let t;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " radio  checkbox"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[2]
      );
      input.__value = /*value*/
      ctx[3];
      input.value = input.__value;
      ctx[10][0].push(input);
      add_location(input, file30, 22, 8, 923);
      set_attributes(div, div_data);
      add_location(div, file30, 21, 4, 814);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*input_change_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*placeholder*/
      16) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*name*/
      4) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*value*/
      8) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[3]
        );
        input.value = input.__value;
      }
      if (dirty & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        66 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " radio  checkbox")) && { class: div_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[10][0].splice(
        /*$$binding_groups*/
        ctx[10][0].indexOf(input),
        1
      );
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let input;
  let t;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " radio checkbox"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[2]
      );
      input.value = /*value*/
      ctx[3];
      add_location(input, file30, 17, 8, 724);
      set_attributes(div, div_data);
      add_location(div, file30, 16, 4, 616);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*placeholder*/
      16) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*name*/
      4) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*value*/
      8) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[3]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        66 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " radio checkbox")) && { class: div_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(16:0) {#if single}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*single*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "name", "group", "value", "placeholder", "single"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Radio", slots, ["default"]);
  let { ui = false } = $$props;
  let { name = "" } = $$props;
  let { group = "" } = $$props;
  let { value = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { single = false } = $$props;
  const $$binding_groups = [[]];
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("single" in $$new_props)
      $$invalidate(5, single = $$new_props.single);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    name,
    group,
    value,
    placeholder,
    single
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("single" in $$props)
      $$invalidate(5, single = $$new_props.single);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    group,
    ui,
    name,
    value,
    placeholder,
    single,
    $$restProps,
    $$scope,
    slots,
    input_change_handler,
    $$binding_groups
  ];
}
var Radio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      ui: 1,
      name: 2,
      group: 0,
      value: 3,
      placeholder: 4,
      single: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment30.name
    });
  }
  get ui() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get single() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set single(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Radio_default = Radio;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Input_Wrapper.svelte
var file31 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Input_Wrapper.svelte";
function create_fragment31(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " input"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file31, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " input")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input_Wrapper", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Input_Wrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input_Wrapper",
      options,
      id: create_fragment31.name
    });
  }
  get ui() {
    throw new Error("<Input_Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Input_Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_Wrapper_default = Input_Wrapper;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Input.svelte
var file32 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Input.svelte";
function create_else_block3(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "text" },
    {
      class: input_class_value = uiProps(
        /*$$restProps*/
        ctx[3]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file32, 20, 4, 881);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[12]
          ),
          listen_dev(
            input,
            "click",
            /*doClick*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_1*/
            ctx[9],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_1*/
            ctx[10],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        dirty & /*$$restProps*/
        8 && input_class_value !== (input_class_value = uiProps(
          /*$$restProps*/
          ctx2[3]
        )) && { class: input_class_value },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "password" },
    {
      class: input_class_value = uiProps(
        /*$$restProps*/
        ctx[3]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file32, 18, 4, 716);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[11]
          ),
          listen_dev(
            input,
            "click",
            /*doClick*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[5],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[7],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "password" },
        dirty & /*$$restProps*/
        8 && input_class_value !== (input_class_value = uiProps(
          /*$$restProps*/
          ctx2[3]
        )) && { class: input_class_value },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(18:0) {#if password}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*password*/
      ctx2[1]
    )
      return create_if_block3;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "password", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, []);
  let { value = "" } = $$props;
  let { password = false } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_input_handler_1() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("password" in $$new_props)
      $$invalidate(1, password = $$new_props.password);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    createEventDispatcher,
    value,
    password,
    name,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("password" in $$props)
      $$invalidate(1, password = $$new_props.password);
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    password,
    doClick,
    $$restProps,
    name,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    keydown_handler_1,
    keypress_handler_1,
    keyup_handler_1,
    input_input_handler,
    input_input_handler_1
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { value: 0, password: 1, name: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment32.name
    });
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get password() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set password(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Fileinput.svelte
var file33 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Fileinput.svelte";
function create_fragment33(ctx) {
  let div;
  let input;
  let div_class_value;
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[2] ? "ui " : "") + /*style*/
      ctx[0] + " input"
    },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      attr_dev(input, "type", "file");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      add_location(input, file33, 16, 4, 680);
      set_attributes(div, div_data);
      add_location(div, file33, 15, 0, 612);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*ui, style*/
        5 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[2] ? "ui " : "") + /*style*/
        ctx2[0] + " input") && { class: div_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["style", "placeholder", "name", "value", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fileinput", slots, []);
  let { style = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { name = "" } = $$props;
  let { value = "" } = $$props;
  let { ui = false } = $$props;
  const dispatch = createEventDispatcher();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("placeholder" in $$new_props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(5, value = $$new_props.value);
    if ("ui" in $$new_props)
      $$invalidate(2, ui = $$new_props.ui);
  };
  $$self.$capture_state = () => ({
    style,
    placeholder,
    name,
    value,
    ui,
    createEventDispatcher,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("placeholder" in $$props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(5, value = $$new_props.value);
    if ("ui" in $$props)
      $$invalidate(2, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [style, name, ui, $$restProps, placeholder, value];
}
var Fileinput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      style: 0,
      placeholder: 4,
      name: 1,
      value: 5,
      ui: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fileinput",
      options,
      id: create_fragment33.name
    });
  }
  get style() {
    throw new Error("<Fileinput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fileinput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Fileinput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Fileinput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Fileinput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Fileinput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Fileinput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Fileinput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Fileinput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Fileinput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fileinput_default = Fileinput;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/SimpleDropdown.svelte
var file34 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/SimpleDropdown.svelte";
function create_fragment34(ctx) {
  let select;
  let select_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let select_levels = [
    {
      class: select_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " dropdown"
    },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      set_attributes(select, select_data);
      if (
        /*value*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[10].call(select)
        ));
      add_location(select, file34, 17, 0, 691);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      select_option(
        select,
        /*value*/
        ctx[0]
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[10]
          ),
          listen_dev(
            select,
            "click",
            /*doClick*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "keydown",
            /*keydown_handler*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "keypress",
            /*keypress_handler*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "keyup",
            /*keyup_handler*/
            ctx[9],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        (!current || dirty & /*ui, $$restProps*/
        10 && select_class_value !== (select_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " dropdown")) && { class: select_class_value },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
      if (dirty & /*ui, uiProps, $$restProps, otherProps*/
      10 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty & /*value*/
      1) {
        select_option(
          select,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "value", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SimpleDropdown", slots, ["default"]);
  let { ui = false } = $$props;
  let { value = "" } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    value,
    name,
    createEventDispatcher,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    ui,
    doClick,
    $$restProps,
    name,
    $$scope,
    slots,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    select_change_handler
  ];
}
var SimpleDropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { ui: 1, value: 0, name: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SimpleDropdown",
      options,
      id: create_fragment34.name
    });
  }
  get ui() {
    throw new Error("<SimpleDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<SimpleDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<SimpleDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SimpleDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SimpleDropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SimpleDropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SimpleDropdown_default = SimpleDropdown;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Checkbox.svelte
var file35 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/inputs/Checkbox.svelte";
function create_fragment35(ctx) {
  let div;
  let input;
  let t;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { name: (
      /*name*/
      ctx[2]
    ) },
    otherProps(
      /*$$restProps*/
      ctx[5]
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(input, input_data);
      add_location(input, file35, 19, 4, 865);
      attr_dev(div, "class", div_class_value = /*ui*/
      (ctx[3] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[5]
      ) + " checkbox");
      add_location(div, file35, 18, 0, 796);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[1];
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[8]
          ),
          listen_dev(
            input,
            "click",
            /*doClick*/
            ctx[4],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        (!current || dirty & /*name*/
        4) && { name: (
          /*name*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        32 && otherProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
      if (dirty & /*checked*/
      2) {
        input.checked = /*checked*/
        ctx2[1];
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*ui, $$restProps*/
      40 && div_class_value !== (div_class_value = /*ui*/
      (ctx2[3] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx2[5]
      ) + " checkbox")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "value", "checked", "ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["default"]);
  let { name = "" } = $$props;
  let { value = "" } = $$props;
  let { checked = false } = $$props;
  let { ui = false } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", {
      name: event2.target.name,
      value: event2.target.value,
      checked: event2.target.checked,
      target: event2.target
    });
  }
  function input_change_handler() {
    checked = this.checked;
    value = this.value;
    $$invalidate(1, checked);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("ui" in $$new_props)
      $$invalidate(3, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    name,
    value,
    checked,
    ui,
    createEventDispatcher,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("ui" in $$props)
      $$invalidate(3, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    checked,
    name,
    ui,
    doClick,
    $$restProps,
    $$scope,
    slots,
    input_change_handler
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { name: 2, value: 0, checked: 1, ui: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment35.name
    });
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ui() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Title.svelte
var file36 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Title.svelte";
function create_fragment36(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " title"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file36, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " title")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Title", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Title",
      options,
      id: create_fragment36.name
    });
  }
  get ui() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Title_default = Title;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Text.svelte
var file37 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Text.svelte";
function create_fragment37(ctx) {
  let span;
  let span_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let span_levels = [
    {
      class: span_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " text"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file37, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && span_class_value !== (span_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " text")) && { class: span_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment37.name
    });
  }
  get ui() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Steps.svelte
var file38 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Steps.svelte";
function create_fragment38(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " steps"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file38, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " steps")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Steps", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Steps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Steps",
      options,
      id: create_fragment38.name
    });
  }
  get ui() {
    throw new Error("<Steps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Steps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Steps_default = Steps;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Step.svelte
var file39 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Step.svelte";
function create_fragment39(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " step"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file39, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " step")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Step", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Step = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Step",
      options,
      id: create_fragment39.name
    });
  }
  get ui() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Step_default = Step;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Segments.svelte
var file40 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Segments.svelte";
function create_fragment40(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " segments"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file40, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " segments")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Segments", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Segments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Segments",
      options,
      id: create_fragment40.name
    });
  }
  get ui() {
    throw new Error("<Segments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Segments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Segments_default = Segments;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Segment.svelte
var file41 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Segment.svelte";
function create_fragment41(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " segment"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file41, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " segment")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Segment", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Segment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Segment",
      options,
      id: create_fragment41.name
    });
  }
  get ui() {
    throw new Error("<Segment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Segment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Segment_default = Segment;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Reveal.svelte
var file42 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Reveal.svelte";
function create_fragment42(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " reveal"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file42, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " reveal")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Reveal", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Reveal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Reveal",
      options,
      id: create_fragment42.name
    });
  }
  get ui() {
    throw new Error("<Reveal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Reveal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Reveal_default = Reveal;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Rail.svelte
var file43 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Rail.svelte";
function create_fragment43(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " rail"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file43, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " rail")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rail", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Rail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rail",
      options,
      id: create_fragment43.name
    });
  }
  get ui() {
    throw new Error("<Rail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Rail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Rail_default = Rail;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Placeholder.svelte
var file44 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Placeholder.svelte";
function create_fragment44(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " placeholder"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file44, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " placeholder")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Placeholder", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Placeholder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Placeholder",
      options,
      id: create_fragment44.name
    });
  }
  get ui() {
    throw new Error("<Placeholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Placeholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Placeholder_default = Placeholder;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Paragraph.svelte
var file45 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Paragraph.svelte";
function create_fragment45(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " paragraph"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file45, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " paragraph")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paragraph", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Paragraph = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paragraph",
      options,
      id: create_fragment45.name
    });
  }
  get ui() {
    throw new Error("<Paragraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Paragraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paragraph_default = Paragraph;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Loader.svelte
var file46 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Loader.svelte";
function create_fragment46(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " loader"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file46, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " loader")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Loader", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Loader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Loader",
      options,
      id: create_fragment46.name
    });
  }
  get ui() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Loader_default = Loader;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/List.svelte
var file47 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/List.svelte";
function create_fragment47(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " list"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file47, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " list")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment47.name
    });
  }
  get ui() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Link.svelte
var file48 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Link.svelte";
function create_fragment48(ctx) {
  let a;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let a_levels = [
    {
      class: a_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      )
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file48, 16, 0, 668);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*doClick*/
            ctx[1],
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keypress",
            /*keypress_handler*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[8],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*ui, $$restProps*/
        5 && a_class_value !== (a_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ))) && { class: a_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  let { ui = false } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    name,
    createEventDispatcher,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ui,
    doClick,
    $$restProps,
    name,
    $$scope,
    slots,
    keydown_handler,
    keypress_handler,
    keyup_handler
  ];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, { ui: 0, name: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment48.name
    });
  }
  get ui() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Line.svelte
var file49 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Line.svelte";
function create_fragment49(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " line"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file49, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " line")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Line = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment49.name
    });
  }
  get ui() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Labels.svelte
var file50 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Labels.svelte";
function create_fragment50(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " labels"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file50, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " labels")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Labels", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Labels = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Labels",
      options,
      id: create_fragment50.name
    });
  }
  get ui() {
    throw new Error("<Labels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Labels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Labels_default = Labels;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Label.svelte
var file51 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Label.svelte";
function create_else_block4(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " label"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file51, 17, 4, 605);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        5 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " label")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(17:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let label;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      add_location(label, file51, 13, 4, 555);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(12:0) {#if checkbox}",
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*checkbox*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "checkbox"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { ui = false } = $$props;
  let { checkbox = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("checkbox" in $$new_props)
      $$invalidate(1, checkbox = $$new_props.checkbox);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui, checkbox });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("checkbox" in $$props)
      $$invalidate(1, checkbox = $$new_props.checkbox);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, checkbox, $$restProps, $$scope, slots];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { ui: 0, checkbox: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment51.name
    });
  }
  get ui() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkbox() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkbox(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Images.svelte
var file52 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Images.svelte";
function create_fragment52(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " images"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file52, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " images")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Images", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Images = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Images",
      options,
      id: create_fragment52.name
    });
  }
  get ui() {
    throw new Error("<Images>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Images>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Images_default = Images;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Image_Wrapper.svelte
var file53 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Image_Wrapper.svelte";
function create_fragment53(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " image"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file53, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " image")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image_Wrapper", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Image_Wrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image_Wrapper",
      options,
      id: create_fragment53.name
    });
  }
  get ui() {
    throw new Error("<Image_Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Image_Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_Wrapper_default = Image_Wrapper;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Image.svelte
var file54 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Image.svelte";
function create_else_block5(ctx) {
  let img;
  let img_class_value;
  let img_levels = [
    {
      class: img_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " image"
    },
    { alt: (
      /*alt*/
      ctx[2]
    ) },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file54, 20, 4, 667);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*ui, $$restProps*/
        9 && img_class_value !== (img_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " image") && { class: img_class_value },
        dirty & /*alt*/
        4 && { alt: (
          /*alt*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(20:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "image header");
      add_location(div, file54, 16, 4, 601);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(15:0) {#if header}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "header", "alt"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, ["default"]);
  let { ui = false } = $$props;
  let { header = false } = $$props;
  let { alt = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("header" in $$new_props)
      $$invalidate(1, header = $$new_props.header);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui, header, alt });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("header" in $$props)
      $$invalidate(1, header = $$new_props.header);
    if ("alt" in $$props)
      $$invalidate(2, alt = $$new_props.alt);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, header, alt, $$restProps, $$scope, slots];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { ui: 0, header: 1, alt: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment54.name
    });
  }
  get ui() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Icons.svelte
var file55 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Icons.svelte";
function create_fragment55(ctx) {
  let i;
  let i_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let i_levels = [
    {
      class: i_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " icons"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file55, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
      if (default_slot) {
        default_slot.m(i, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && i_class_value !== (i_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " icons")) && { class: i_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icons", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Icons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icons",
      options,
      id: create_fragment55.name
    });
  }
  get ui() {
    throw new Error("<Icons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Icons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icons_default = Icons;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Icon.svelte
var file56 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Icon.svelte";
function create_else_block6(ctx) {
  let i;
  let i_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let i_levels = [
    {
      class: i_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " icon"
    },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file56, 22, 4, 885);
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
      if (default_slot) {
        default_slot.m(i, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*ui, $$restProps*/
        9 && i_class_value !== (i_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " icon")) && { class: i_class_value },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(22:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let i;
  let i_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let i_levels = [
    {
      class: i_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[3]
      ) + " icon"
    },
    otherProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file56, 18, 4, 708);
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
      if (default_slot) {
        default_slot.m(i, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            i,
            "click",
            /*doClick*/
            ctx[2],
            false,
            false,
            false
          ),
          listen_dev(
            i,
            "keydown",
            /*keydown_handler*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            i,
            "keypress",
            /*keypress_handler*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            i,
            "keyup",
            /*keyup_handler*/
            ctx[9],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*ui, $$restProps*/
        9 && i_class_value !== (i_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[3]
        ) + " icon")) && { class: i_class_value },
        dirty & /*$$restProps*/
        8 && otherProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(18:0) {#if link}",
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*link*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "link", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, ["default"]);
  let { ui = false } = $$props;
  let { link = false } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("link" in $$new_props)
      $$invalidate(1, link = $$new_props.link);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    createEventDispatcher,
    ui,
    link,
    name,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("link" in $$props)
      $$invalidate(1, link = $$new_props.link);
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ui,
    link,
    doClick,
    $$restProps,
    name,
    $$scope,
    slots,
    keydown_handler,
    keypress_handler,
    keyup_handler
  ];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { ui: 0, link: 1, name: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment56.name
    });
  }
  get ui() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Header.svelte
var file57 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Header.svelte";
function create_else_block7(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " header"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file57, 38, 4, 1327);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        65 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " header")) && { class: div_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(37:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let h5_1;
  let h5_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let h5_1_levels = [
    {
      class: h5_1_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " header"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let h5_1_data = {};
  for (let i = 0; i < h5_1_levels.length; i += 1) {
    h5_1_data = assign(h5_1_data, h5_1_levels[i]);
  }
  const block = {
    c: function create() {
      h5_1 = element("h5");
      if (default_slot)
        default_slot.c();
      set_attributes(h5_1, h5_1_data);
      add_location(h5_1, file57, 33, 4, 1173);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5_1, anchor);
      if (default_slot) {
        default_slot.m(h5_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h5_1, h5_1_data = get_spread_update(h5_1_levels, [
        (!current || dirty & /*ui, $$restProps*/
        65 && h5_1_class_value !== (h5_1_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " header")) && { class: h5_1_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(33:13) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let h4_1;
  let h4_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let h4_1_levels = [
    {
      class: h4_1_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " header"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let h4_1_data = {};
  for (let i = 0; i < h4_1_levels.length; i += 1) {
    h4_1_data = assign(h4_1_data, h4_1_levels[i]);
  }
  const block = {
    c: function create() {
      h4_1 = element("h4");
      if (default_slot)
        default_slot.c();
      set_attributes(h4_1, h4_1_data);
      add_location(h4_1, file57, 29, 4, 1037);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4_1, anchor);
      if (default_slot) {
        default_slot.m(h4_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h4_1, h4_1_data = get_spread_update(h4_1_levels, [
        (!current || dirty & /*ui, $$restProps*/
        65 && h4_1_class_value !== (h4_1_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " header")) && { class: h4_1_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(29:13) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let h3_1;
  let h3_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let h3_1_levels = [
    {
      class: h3_1_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " header"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let h3_1_data = {};
  for (let i = 0; i < h3_1_levels.length; i += 1) {
    h3_1_data = assign(h3_1_data, h3_1_levels[i]);
  }
  const block = {
    c: function create() {
      h3_1 = element("h3");
      if (default_slot)
        default_slot.c();
      set_attributes(h3_1, h3_1_data);
      add_location(h3_1, file57, 25, 4, 901);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3_1, anchor);
      if (default_slot) {
        default_slot.m(h3_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h3_1, h3_1_data = get_spread_update(h3_1_levels, [
        (!current || dirty & /*ui, $$restProps*/
        65 && h3_1_class_value !== (h3_1_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " header")) && { class: h3_1_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(25:13) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let h2_1;
  let h2_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let h2_1_levels = [
    {
      class: h2_1_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " header"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let h2_1_data = {};
  for (let i = 0; i < h2_1_levels.length; i += 1) {
    h2_1_data = assign(h2_1_data, h2_1_levels[i]);
  }
  const block = {
    c: function create() {
      h2_1 = element("h2");
      if (default_slot)
        default_slot.c();
      set_attributes(h2_1, h2_1_data);
      add_location(h2_1, file57, 21, 4, 765);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2_1, anchor);
      if (default_slot) {
        default_slot.m(h2_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h2_1, h2_1_data = get_spread_update(h2_1_levels, [
        (!current || dirty & /*ui, $$restProps*/
        65 && h2_1_class_value !== (h2_1_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " header")) && { class: h2_1_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(21:13) ",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let h1_1;
  let h1_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let h1_1_levels = [
    {
      class: h1_1_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[6]
      ) + " header"
    },
    otherProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let h1_1_data = {};
  for (let i = 0; i < h1_1_levels.length; i += 1) {
    h1_1_data = assign(h1_1_data, h1_1_levels[i]);
  }
  const block = {
    c: function create() {
      h1_1 = element("h1");
      if (default_slot)
        default_slot.c();
      set_attributes(h1_1, h1_1_data);
      add_location(h1_1, file57, 17, 4, 629);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h1_1, anchor);
      if (default_slot) {
        default_slot.m(h1_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h1_1, h1_1_data = get_spread_update(h1_1_levels, [
        (!current || dirty & /*ui, $$restProps*/
        65 && h1_1_class_value !== (h1_1_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[6]
        ) + " header")) && { class: h1_1_class_value },
        dirty & /*$$restProps*/
        64 && otherProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h1_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(17:0) {#if h1}",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block7,
    create_if_block_1,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_else_block7
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*h1*/
      ctx2[1]
    )
      return 0;
    if (
      /*h2*/
      ctx2[2]
    )
      return 1;
    if (
      /*h3*/
      ctx2[3]
    )
      return 2;
    if (
      /*h4*/
      ctx2[4]
    )
      return 3;
    if (
      /*h5*/
      ctx2[5]
    )
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "h1", "h2", "h3", "h4", "h5"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["default"]);
  let { ui = false } = $$props;
  let { h1 = false } = $$props;
  let { h2 = false } = $$props;
  let { h3 = false } = $$props;
  let { h4 = false } = $$props;
  let { h5 = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("h1" in $$new_props)
      $$invalidate(1, h1 = $$new_props.h1);
    if ("h2" in $$new_props)
      $$invalidate(2, h2 = $$new_props.h2);
    if ("h3" in $$new_props)
      $$invalidate(3, h3 = $$new_props.h3);
    if ("h4" in $$new_props)
      $$invalidate(4, h4 = $$new_props.h4);
    if ("h5" in $$new_props)
      $$invalidate(5, h5 = $$new_props.h5);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    h1,
    h2,
    h3,
    h4,
    h5
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("h1" in $$props)
      $$invalidate(1, h1 = $$new_props.h1);
    if ("h2" in $$props)
      $$invalidate(2, h2 = $$new_props.h2);
    if ("h3" in $$props)
      $$invalidate(3, h3 = $$new_props.h3);
    if ("h4" in $$props)
      $$invalidate(4, h4 = $$new_props.h4);
    if ("h5" in $$props)
      $$invalidate(5, h5 = $$new_props.h5);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, h1, h2, h3, h4, h5, $$restProps, $$scope, slots];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, { ui: 0, h1: 1, h2: 2, h3: 3, h4: 4, h5: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment57.name
    });
  }
  get ui() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get h1() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set h1(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get h2() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set h2(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get h3() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set h3(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get h4() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set h4(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get h5() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set h5(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Flag.svelte
var file58 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Flag.svelte";
function create_fragment58(ctx) {
  let i;
  let i_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let i_levels = [
    {
      class: i_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " flag"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file58, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
      if (default_slot) {
        default_slot.m(i, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && i_class_value !== (i_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " flag")) && { class: i_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Flag", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Flag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Flag",
      options,
      id: create_fragment58.name
    });
  }
  get ui() {
    throw new Error("<Flag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Flag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Flag_default = Flag;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Emoji.svelte
var file59 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Emoji.svelte";
function create_else_block8(ctx) {
  let em;
  let em_class_value;
  let em_data_emoji_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      em = element("em");
      if (default_slot)
        default_slot.c();
      attr_dev(em, "class", em_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + /*disabled*/
      (ctx[1] ? "disabled " : "") + /*loading*/
      (ctx[2] ? "loading " : "") + /*small*/
      (ctx[3] ? "small " : "") + /*medium*/
      (ctx[4] ? "medium " : "") + /*large*/
      (ctx[5] ? "large " : "") + /*big*/
      (ctx[6] ? "big " : "") + /*link*/
      (ctx[7] ? "link " : ""));
      attr_dev(em, "data-emoji", em_data_emoji_value = uiProps(
        /*$$restProps*/
        ctx[9]
      ));
      add_location(em, file59, 29, 4, 1193);
    },
    m: function mount(target, anchor) {
      insert_dev(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*ui, disabled, loading, small, medium, large, big, link*/
      255 && em_class_value !== (em_class_value = /*ui*/
      (ctx2[0] ? "ui " : "") + /*disabled*/
      (ctx2[1] ? "disabled " : "") + /*loading*/
      (ctx2[2] ? "loading " : "") + /*small*/
      (ctx2[3] ? "small " : "") + /*medium*/
      (ctx2[4] ? "medium " : "") + /*large*/
      (ctx2[5] ? "large " : "") + /*big*/
      (ctx2[6] ? "big " : "") + /*link*/
      (ctx2[7] ? "link " : ""))) {
        attr_dev(em, "class", em_class_value);
      }
      if (!current || dirty & /*$$restProps*/
      512 && em_data_emoji_value !== (em_data_emoji_value = uiProps(
        /*$$restProps*/
        ctx2[9]
      ))) {
        attr_dev(em, "data-emoji", em_data_emoji_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(em);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(29:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let em;
  let em_class_value;
  let em_data_emoji_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      em = element("em");
      if (default_slot)
        default_slot.c();
      attr_dev(em, "class", em_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + /*disabled*/
      (ctx[1] ? "disabled " : "") + /*loading*/
      (ctx[2] ? "loading " : "") + /*small*/
      (ctx[3] ? "small " : "") + /*medium*/
      (ctx[4] ? "medium " : "") + /*large*/
      (ctx[5] ? "large " : "") + /*big*/
      (ctx[6] ? "big " : "") + /*link*/
      (ctx[7] ? "link " : ""));
      attr_dev(em, "data-emoji", em_data_emoji_value = uiProps(
        /*$$restProps*/
        ctx[9]
      ));
      add_location(em, file59, 24, 4, 869);
    },
    m: function mount(target, anchor) {
      insert_dev(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            em,
            "click",
            /*doClick*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            em,
            "keydown",
            /*keydown_handler*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            em,
            "keyup",
            /*keyup_handler*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            em,
            "keypress",
            /*keypress_handler*/
            ctx[15],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*ui, disabled, loading, small, medium, large, big, link*/
      255 && em_class_value !== (em_class_value = /*ui*/
      (ctx2[0] ? "ui " : "") + /*disabled*/
      (ctx2[1] ? "disabled " : "") + /*loading*/
      (ctx2[2] ? "loading " : "") + /*small*/
      (ctx2[3] ? "small " : "") + /*medium*/
      (ctx2[4] ? "medium " : "") + /*large*/
      (ctx2[5] ? "large " : "") + /*big*/
      (ctx2[6] ? "big " : "") + /*link*/
      (ctx2[7] ? "link " : ""))) {
        attr_dev(em, "class", em_class_value);
      }
      if (!current || dirty & /*$$restProps*/
      512 && em_data_emoji_value !== (em_data_emoji_value = uiProps(
        /*$$restProps*/
        ctx2[9]
      ))) {
        attr_dev(em, "data-emoji", em_data_emoji_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(em);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(24:0) {#if link}",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*link*/
      ctx2[7]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "disabled", "loading", "small", "medium", "large", "big", "link", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Emoji", slots, ["default"]);
  let { ui = false } = $$props;
  let { disabled = false } = $$props;
  let { loading = false } = $$props;
  let { small = false } = $$props;
  let { medium = false } = $$props;
  let { large = false } = $$props;
  let { big = false } = $$props;
  let { link = false } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("loading" in $$new_props)
      $$invalidate(2, loading = $$new_props.loading);
    if ("small" in $$new_props)
      $$invalidate(3, small = $$new_props.small);
    if ("medium" in $$new_props)
      $$invalidate(4, medium = $$new_props.medium);
    if ("large" in $$new_props)
      $$invalidate(5, large = $$new_props.large);
    if ("big" in $$new_props)
      $$invalidate(6, big = $$new_props.big);
    if ("link" in $$new_props)
      $$invalidate(7, link = $$new_props.link);
    if ("name" in $$new_props)
      $$invalidate(10, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    disabled,
    loading,
    small,
    medium,
    large,
    big,
    link,
    name,
    createEventDispatcher,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("loading" in $$props)
      $$invalidate(2, loading = $$new_props.loading);
    if ("small" in $$props)
      $$invalidate(3, small = $$new_props.small);
    if ("medium" in $$props)
      $$invalidate(4, medium = $$new_props.medium);
    if ("large" in $$props)
      $$invalidate(5, large = $$new_props.large);
    if ("big" in $$props)
      $$invalidate(6, big = $$new_props.big);
    if ("link" in $$props)
      $$invalidate(7, link = $$new_props.link);
    if ("name" in $$props)
      $$invalidate(10, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ui,
    disabled,
    loading,
    small,
    medium,
    large,
    big,
    link,
    doClick,
    $$restProps,
    name,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var Emoji = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {
      ui: 0,
      disabled: 1,
      loading: 2,
      small: 3,
      medium: 4,
      large: 5,
      big: 6,
      link: 7,
      name: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Emoji",
      options,
      id: create_fragment59.name
    });
  }
  get ui() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get medium() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set medium(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get large() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set large(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get big() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set big(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get link() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Emoji>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Emoji>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Emoji_default = Emoji;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Divider.svelte
var file60 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Divider.svelte";
function create_fragment60(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " divider"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file60, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " divider")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Divider", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Divider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Divider",
      options,
      id: create_fragment60.name
    });
  }
  get ui() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Divider_default = Divider;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Detail.svelte
var file61 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Detail.svelte";
function create_fragment61(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " detail"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file61, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " detail")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Detail", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Detail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Detail",
      options,
      id: create_fragment61.name
    });
  }
  get ui() {
    throw new Error("<Detail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Detail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Detail_default = Detail;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Description.svelte
var file62 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Description.svelte";
function create_fragment62(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " description"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file62, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " description")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Description", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Description = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Description",
      options,
      id: create_fragment62.name
    });
  }
  get ui() {
    throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Description_default = Description;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Content.svelte
var file63 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Content.svelte";
function create_fragment63(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " content"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file63, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " content")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment63.name
    });
  }
  get ui() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Content_default = Content;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Container.svelte
var file64 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Container.svelte";
function create_fragment64(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[1]
      ) + " container"
    },
    otherProps(
      /*$$restProps*/
      ctx[1]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file64, 10, 0, 475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        3 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[1]
        ) + " container")) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && otherProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  let { ui = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ uiProps, otherProps, ui });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ui, $$restProps, $$scope, slots];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, { ui: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment64.name
    });
  }
  get ui() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Buttons.svelte
var file65 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Buttons.svelte";
function create_fragment65(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[0] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[2]
      ) + " buttons"
    },
    otherProps(
      /*$$restProps*/
      ctx[2]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file65, 16, 0, 668);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*doClick*/
            ctx[1],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keyup",
            /*keyup_handler*/
            ctx[8],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        5 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[0] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[2]
        ) + " buttons")) && { class: div_class_value },
        dirty & /*$$restProps*/
        4 && otherProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Buttons", slots, ["default"]);
  let { ui = false } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    name,
    createEventDispatcher,
    dispatch,
    doClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(0, ui = $$new_props.ui);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ui,
    doClick,
    $$restProps,
    name,
    $$scope,
    slots,
    keydown_handler,
    keypress_handler,
    keyup_handler
  ];
}
var Buttons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { ui: 0, name: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Buttons",
      options,
      id: create_fragment65.name
    });
  }
  get ui() {
    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Buttons_default = Buttons;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Button.svelte
var file66 = "node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/elements/Button.svelte";
var get_off_slot_changes = (dirty) => ({});
var get_off_slot_context = (ctx) => ({});
var get_on_slot_changes = (dirty) => ({});
var get_on_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[7]
      ) + " button"
    },
    otherProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file66, 35, 4, 1298);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*doClick*/
            ctx[5],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler_1*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keypress",
            /*keypress_handler_1*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keyup",
            /*keyup_handler_1*/
            ctx[16],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps*/
        130 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[7]
        ) + " button")) && { class: div_class_value },
        dirty & /*$$restProps*/
        128 && otherProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(34:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_12, create_else_block9];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*active*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = /*ui*/
      (ctx[1] ? "ui " : "") + uiProps(
        /*$$restProps*/
        ctx[7]
      ) + " " + /*active*/
      (ctx[0] ? (
        /*on_style*/
        ctx[3]
      ) : (
        /*off_style*/
        ctx[4]
      )) + " button"
    },
    otherProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file66, 26, 4, 944);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*doToggle*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keyup",
            /*keyup_handler*/
            ctx[13],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*ui, $$restProps, active, on_style, off_style*/
        155 && div_class_value !== (div_class_value = /*ui*/
        (ctx2[1] ? "ui " : "") + uiProps(
          /*$$restProps*/
          ctx2[7]
        ) + " " + /*active*/
        (ctx2[0] ? (
          /*on_style*/
          ctx2[3]
        ) : (
          /*off_style*/
          ctx2[4]
        )) + " button")) && { class: div_class_value },
        dirty & /*$$restProps*/
        128 && otherProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(26:0) {#if toggle}",
    ctx
  });
  return block;
}
function create_else_block9(ctx) {
  let current;
  const off_slot_template = (
    /*#slots*/
    ctx[10].off
  );
  const off_slot = create_slot(
    off_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_off_slot_context
  );
  const block = {
    c: function create() {
      if (off_slot)
        off_slot.c();
    },
    m: function mount(target, anchor) {
      if (off_slot) {
        off_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (off_slot) {
        if (off_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            off_slot,
            off_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              off_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_off_slot_changes
            ),
            get_off_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(off_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(off_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (off_slot)
        off_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(30:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const on_slot_template = (
    /*#slots*/
    ctx[10].on
  );
  const on_slot = create_slot(
    on_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_on_slot_context
  );
  const block = {
    c: function create() {
      if (on_slot)
        on_slot.c();
    },
    m: function mount(target, anchor) {
      if (on_slot) {
        on_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (on_slot) {
        if (on_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            on_slot,
            on_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              on_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_on_slot_changes
            ),
            get_on_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(on_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(on_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (on_slot)
        on_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(28:8) {#if active}",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block9, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*toggle*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  const omit_props_names = ["ui", "toggle", "name", "active", "on_style", "off_style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["on", "off", "default"]);
  let { ui = false } = $$props;
  let { toggle = false } = $$props;
  let { name = "" } = $$props;
  let { active = false } = $$props;
  let { on_style = "" } = $$props;
  let { off_style = "" } = $$props;
  const dispatch = createEventDispatcher();
  function doClick(event2) {
    dispatch("click", { name, target: event2.target });
  }
  function doToggle(event2) {
    $$invalidate(0, active = !active);
    dispatch("toggle", { name, active, target: event2.target });
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ui" in $$new_props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("toggle" in $$new_props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("name" in $$new_props)
      $$invalidate(8, name = $$new_props.name);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("on_style" in $$new_props)
      $$invalidate(3, on_style = $$new_props.on_style);
    if ("off_style" in $$new_props)
      $$invalidate(4, off_style = $$new_props.off_style);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    uiProps,
    otherProps,
    ui,
    toggle,
    name,
    active,
    on_style,
    off_style,
    createEventDispatcher,
    dispatch,
    doClick,
    doToggle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ui" in $$props)
      $$invalidate(1, ui = $$new_props.ui);
    if ("toggle" in $$props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("name" in $$props)
      $$invalidate(8, name = $$new_props.name);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("on_style" in $$props)
      $$invalidate(3, on_style = $$new_props.on_style);
    if ("off_style" in $$props)
      $$invalidate(4, off_style = $$new_props.off_style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    active,
    ui,
    toggle,
    on_style,
    off_style,
    doClick,
    doToggle,
    $$restProps,
    name,
    $$scope,
    slots,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    keydown_handler_1,
    keypress_handler_1,
    keyup_handler_1
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, {
      ui: 1,
      toggle: 2,
      name: 8,
      active: 0,
      on_style: 3,
      off_style: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment66.name
    });
  }
  get ui() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ui(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get on_style() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set on_style(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get off_style() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set off_style(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/svelte-fomantic-ui/src/lib/fomantic-ui/Core.svelte
function create_fragment67(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Core", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Core> was created with unknown prop '${key}'`);
  });
  return [];
}
var Core = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Core",
      options,
      id: create_fragment67.name
    });
  }
};
var Core_default = Core;
export {
  Accordion_default as Accordion,
  Advertisement_default as Advertisement,
  Breadcrumb_default as Breadcrumb,
  Button_default as Button,
  Buttons_default as Buttons,
  Calendar_default as Calendar,
  Card_default as Card,
  Cards_default as Cards,
  Checkbox_default as Checkbox,
  Column_default as Column,
  Container_default as Container,
  Content_default as Content,
  Description_default as Description,
  Detail_default as Detail,
  Dimmer_default as Dimmer,
  Divider_default as Divider,
  Dropdown_default as Dropdown,
  Emoji_default as Emoji,
  Feed_default as Feed,
  Field_default as Field,
  Fields_default as Fields,
  Fileinput_default as Fileinput,
  Flag_default as Flag,
  Form_default as Form,
  Grid_default as Grid,
  Header_default as Header,
  Icon_default as Icon,
  Icons_default as Icons,
  Image_default as Image,
  Image_Wrapper_default as Image_Wrapper,
  Images_default as Images,
  Input_default as Input,
  Input_Wrapper_default as Input_Wrapper,
  Item_default as Item,
  Items_default as Items,
  Label_default as Label,
  Labels_default as Labels,
  Line_default as Line,
  Link_default as Link,
  List_default as List,
  Loader_default as Loader,
  Menu_default as Menu,
  Message_default as Message,
  Option_default as Option,
  Paragraph_default as Paragraph,
  Placeholder_default as Placeholder,
  Radio_default as Radio,
  Rail_default as Rail,
  Reveal_default as Reveal,
  Row_default as Row,
  Section_default as Section,
  Segment_default as Segment,
  Segments_default as Segments,
  SimpleDropdown_default as SimpleDropdown,
  Statistic_default as Statistic,
  Statistics_default as Statistics,
  Step_default as Step,
  Steps_default as Steps,
  Table_default as Table,
  Table_Body_default as Table_Body,
  Table_Col_default as Table_Col,
  Table_Head_default as Table_Head,
  Table_Row_default as Table_Row,
  Text_default as Text,
  Textarea_default as Textarea,
  Title_default as Title,
  Core_default as default
};
/*! Bundled license information:

fomantic-ui-css/semantic.js:
  (*!
   * # Fomantic-UI 2.9.2 - Site
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Form Validation
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Accordion
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Calendar
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Checkbox
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Dimmer
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Dropdown
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Embed
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Flyout
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Modal
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Nag
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Popup
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Progress
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Slider
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Rating
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Search
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Shape
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Sidebar
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Sticky
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Tab
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Toast
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Transition
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - API
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - State
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
  (*!
   * # Fomantic-UI 2.9.2 - Visibility
   * https://github.com/fomantic/Fomantic-UI/
   *
   *
   * Released under the MIT license
   * https://opensource.org/licenses/MIT
   *
   *)
*/
//# sourceMappingURL=svelte-fomantic-ui.js.map
